<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\bullish as Exchange;

class bullish extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bullish',
            'name' => 'Bullish',
            'countries' => array( 'DE' ),
            'version' => 'v3',
            'rateLimit' => 20, // 50 requests per second
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'borrowMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'createDepositAddress' => false,
                'createLimitBuyOrder' => true,
                'createLimitOrder' => true,
                'createLimitSellOrder' => true,
                'createMarketBuyOrder' => true,
                'createMarketOrder' => true,
                'createMarketSellOrder' => true,
                'createOrder' => true,
                'createPostOnlyOrder' => true,
                'createTriggerOrder' => true,
                'deposit' => false,
                'editOrder' => true,
                'fetchAccounts' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => false,
                'fetchBorrowInterest' => false,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => true,
                'fetchCanceledAndClosedOrders' => true,
                'fetchCanceledOrders' => true,
                'fetchClosedOrder' => false,
                'fetchClosedOrders' => true,
                'fetchCrossBorrowRate' => false,
                'fetchCrossBorrowRates' => false,
                'fetchCurrencies' => true,
                'fetchDeposit' => false,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchDeposits' => false,
                'fetchDepositsWithdrawals' => true,
                'fetchDepositWithdrawFee' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => false,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => false,
                'fetchIndexOHLCV' => false,
                'fetchIsolatedBorrowRate' => false,
                'fetchIsolatedBorrowRates' => false,
                'fetchL3OrderBook' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => false,
                'fetchPositionHistory' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsForSymbol' => false,
                'fetchPositionsHistory' => false,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => true,
                'fetchTickers' => false,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTradingLimits' => false,
                'fetchTransactionFee' => false,
                'fetchTransactionFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => true,
                'fetchWithdrawal' => false,
                'fetchWithdrawals' => false,
                'fetchWithdrawalWhitelist' => false,
                'reduceMargin' => false,
                'repayMargin' => false,
                'setLeverage' => false,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'signIn' => true,
                'transfer' => true,
                'withdraw' => true,
                'ws' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '30m' => '30m',
                '1h' => '1h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1d',
            ),
            'urls' => array(
                'logo' => 'https://github.com/user-attachments/assets/68f0686b-84f0-4da9-a751-f7089af3a9ed',
                'api' => array(
                    'public' => 'https://api.exchange.bullish.com/trading-api',
                    'private' => 'https://api.exchange.bullish.com/trading-api',
                ),
                'test' => array(
                    'public' => 'https://api.simnext.bullish-test.com/trading-api',
                    'private' => 'https://api.simnext.bullish-test.com/trading-api',
                ),
                'www' => 'https://bullish.com/',
                'referral' => '',
                'doc' => array(
                    'https://api.exchange.bullish.com/docs/api/rest/',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'v1/nonce' => 1,
                        'v1/time' => 1,
                        'v1/assets' => 1,
                        'v1/assets/{symbol}' => 1,
                        'v1/markets' => 1,
                        'v1/markets/{symbol}' => 1,
                        'v1/history/markets/{symbol}' => 1,
                        'v1/markets/{symbol}/orderbook/hybrid' => 1,
                        'v1/markets/{symbol}/trades' => 1,
                        'v1/markets/{symbol}/tick' => 1,
                        'v1/markets/{symbol}/candle' => 1,
                        'v1/history/markets/{symbol}/trades' => 1,
                        'v1/history/markets/{symbol}/funding-rate' => 1,
                        'v1/index-prices' => 1,
                        'v1/index-prices/{assetSymbol}' => 1,
                        'v1/expiry-prices/{symbol}' => 1,
                        'v1/option-ladder' => 1,
                        'v1/option-ladder/{symbol}' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'v2/orders' => 1,
                        'v2/history/orders' => 1,
                        'v2/orders/{orderId}' => 1,
                        'v2/amm-instructions' => 1,
                        'v2/amm-instructions/{instructionId}' => 1,
                        'v1/wallets/transactions' => 1,
                        'v1/wallets/limits/{symbol}' => 1,
                        'v1/wallets/deposit-instructions/crypto/{symbol}' => 1,
                        'v1/wallets/withdrawal-instructions/crypto/{symbol}' => 1,
                        'v1/wallets/deposit-instructions/fiat/{symbol}' => 1,
                        'v1/wallets/withdrawal-instructions/fiat/{symbol}' => 1,
                        'v1/wallets/self-hosted/verification-attempts' => 1,
                        'v1/trades' => 5,
                        'v1/history/trades' => 5,
                        'v1/trades/{tradeId}' => 5,
                        'v1/trades/client-order-id/{clientOrderId}' => 1,
                        'v1/accounts/asset' => 1,
                        'v1/accounts/asset/{symbol}' => 1,
                        'v1/users/logout' => 1,
                        'v1/users/hmac/login' => 1,
                        'v1/accounts/trading-accounts' => 1,
                        'v1/accounts/trading-accounts/{tradingAccountId}' => 1,
                        'v1/derivatives-positions' => 1,
                        'v1/history/derivatives-settlement' => 1,
                        'v1/history/transfer' => 1,
                        'v1/history/borrow-interest' => 1,
                        'v2/mmp-configuration' => 1,
                        'v2/otc-trades' => 1,
                        'v2/otc-trades/{otcTradeId}' => 1,
                        'v2/otc-trades/unconfirmed-trade' => 1,
                    ),
                    'post' => array(
                        'v2/orders' => 5,
                        'v2/command' => 5,
                        'v2/amm-instructions' => 1,
                        'v1/wallets/withdrawal' => 1,
                        'v2/users/login' => 1,
                        'v1/simulate-portfolio-margin' => 1,
                        'v1/wallets/self-hosted/initiate' => 1,
                        'v2/mmp-configuration' => 1,
                        'v2/otc-trades' => 1,
                        'v2/otc-command' => 1,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    // todo check fees
                    'taker' => $this->parse_number('0.001'),
                    'maker' => $this->parse_number('0.001'),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            // exchange-specific options
            'options' => array(
                'timeDifference' => 0, // the difference between system clock and Binance clock
                'adjustForTimeDifference' => false, // controls the adjustment logic upon instantiation
                'networks' => array(
                    'BTC' => 'BTC',
                    'EOS' => 'EOS',
                    'ERC20' => 'ETH',
                ),
                'defaultNetwork' => 'ERC20',
                'defaultNetworks' => array(
                    'USDC' => 'ERC20',
                ),
                'tradingAccountId' => null,
            ),
            'features' => array(
                'default' => array(
                    'sandbox' => true,
                    'createOrder' => array(
                        'marginMode' => false,
                        'triggerPrice' => true,
                        'triggerPriceType' => null,
                        'triggerDirection' => false,
                        'stopLossPrice' => false,
                        'takeProfitPrice' => false,
                        'attachedStopLossTakeProfit' => null,
                        'timeInForce' => array(
                            'IOC' => true,
                            'FOK' => true,
                            'PO' => true,
                            'GTD' => false,
                        ),
                        'hedged' => false,
                        'trailing' => false,
                        'leverage' => false,
                        'marketBuyByCost' => false,
                        'marketBuyRequiresPrice' => false,
                        'selfTradePrevention' => false,
                        'iceberg' => false,
                    ),
                    'createOrders' => null,
                    'fetchMyTrades' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 90,
                        'symbolRequired' => false,
                        'untilDays' => 90,
                    ),
                    'fetchOrder' => array(
                        'marginMode' => false,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 90,
                        'untilDays' => 90,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOpenOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 90,
                        'untilDays' => 90,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchCanceledAndClosedOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 90,
                        'untilDays' => 90,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchClosedOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 1,
                        'daysBackCanceled' => 1,
                        'untilDays' => 1,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchCanceledOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 1,
                        'untilDays' => 1,
                        'trigger' => false,
                        'trailing' => false,
                        'symbolRequired' => false,
                    ),
                    'fetchOHLCV' => array(
                        'limit' => 1000,
                    ),
                ),
                'spot' => array(
                    'extends' => 'default',
                ),
                'swap' => array(
                    'linear' => array(
                        'extends' => 'default',
                    ),
                    'inverse' => null,
                ),
                'future' => array(
                    'linear' => array(
                        'extends' => 'default',
                    ),
                    'inverse' => null,
                ),
            ),
            'exceptions' => array(
                'exact' => array(
                    '1' => '\\ccxt\\BadRequest', // Unknown symbol
                    '5' => '\\ccxt\\InvalidOrder', // Unknown order
                    '6' => '\\ccxt\\DuplicateOrderId', // Duplicate order
                    '13' => '\\ccxt\\BadRequest', // Incorrect quantity
                    '15' => '\\ccxt\\BadRequest', // Invalid account
                    '18' => '\\ccxt\\BadRequest', // Invalid price
                    '1002' => '\\ccxt\\BadRequest', // Unable to place request
                    '2001' => '\\ccxt\\BadRequest', // Bad incoming request
                    '2002' => '\\ccxt\\BadRequest', // Invalid user's client id
                    '2003' => '\\ccxt\\BadRequest', // Invalid handle
                    '2004' => '\\ccxt\\BadRequest', // Invalid quantity
                    '2005' => '\\ccxt\\ExchangeError', // Unknown error
                    '2006' => '\\ccxt\\BadRequest', // Invalid account type, //  account must be spot
                    '2007' => '\\ccxt\\BadRequest', // Account already exist
                    '2008' => '\\ccxt\\BadRequest', // Invalid side, //  side must me from buy or sell
                    '2009' => '\\ccxt\\BadSymbol', // Invalid market
                    '2010' => '\\ccxt\\AuthenticationError', // Account doesn't exist
                    '2011' => '\\ccxt\\AuthenticationError', // Account types are different
                    '2012' => '\\ccxt\\BadRequest', // Invalid price
                    '2013' => '\\ccxt\\InvalidOrder', // Invalid order type, //  type must be from limit, //  market, //  stop-limit
                    '2015' => '\\ccxt\\OperationRejected', // Exceeded maximum amount of allowed open margin orders
                    '2016' => '\\ccxt\\BadRequest', // Unknown request type
                    '2017' => '\\ccxt\\BadRequest', // Invalid order id
                    '2018' => '\\ccxt\\BadRequest', // Unknown time in force option
                    '2020' => '\\ccxt\\PermissionDenied', // Margin trading is not allowed
                    '2021' => '\\ccxt\\OperationRejected', // Exceeded maximum amount of allowed open spot orders
                    '2029' => '\\ccxt\\InvalidNonce', // Invalid request id
                    '2035' => '\\ccxt\\InvalidNonce', // Invalid nonce
                    '3001' => '\\ccxt\\InsufficientFunds', // Account doesn't have sufficient balance
                    '3002' => '\\ccxt\\OrderNotFound', // Order is not found
                    '3003' => '\\ccxt\\PermissionDenied', // Borrowing is unavailable
                    '3004' => '\\ccxt\\InsufficientFunds', // Unable to adjust balance
                    '3005' => '\\ccxt\\InsufficientFunds', // Insufficient balance
                    '3006' => '\\ccxt\\InsufficientFunds', // Insufficient collateral
                    '3007' => '\\ccxt\\DuplicateOrderId', // Duplicated order id
                    '3031' => '\\ccxt\\BadRequest', // Price is out of range
                    '3032' => '\\ccxt\\BadRequest', // Order is either closed or rejected
                    '3033' => '\\ccxt\\PermissionDenied', // Leverage increase not permitted
                    '3034' => '\\ccxt\\RateLimitExceeded', // Rate limit exceeded
                    '3035' => '\\ccxt\\RateLimitExceeded', // Global rate limit exceeded
                    '3047' => '\\ccxt\\OperationRejected', // Leverage increase not permitted
                    '3048' => '\\ccxt\\OperationRejected', // Reached max borrowing
                    '3049' => '\\ccxt\\OperationRejected', // No more open loans available
                    '3051' => '\\ccxt\\InsufficientFunds', // Insufficient iou balance
                    '3052' => '\\ccxt\\InsufficientFunds', // Insufficient uoi balance
                    '3063' => '\\ccxt\\BadRequest', // Missing request id
                    '3064' => '\\ccxt\\OrderNotFillable', // Incoming order failed to make or take
                    '3065' => '\\ccxt\\MarketClosed', // Market open interest limit exceeded
                    '3066' => '\\ccxt\\ExchangeError', // Account concentration limit exceeded
                    '3067' => '\\ccxt\\MarketClosed', // MarketClosed
                    '6007' => '\\ccxt\\InvalidOrder', // Self cross prevention
                    '6011' => '\\ccxt\\InvalidOrder', // Self cross prevention amend
                    '6012' => '\\ccxt\\InvalidOrder', // Stop limit amend
                    '6013' => '\\ccxt\\InvalidOrder', // Partially filled
                    '8301' => '\\ccxt\\ExchangeError', // Unexpected Error
                    '8305' => '\\ccxt\\ExchangeError', // Withdraw assertion failed
                    '8306' => '\\ccxt\\ExchangeError', // Custody bad user
                    '8307' => '\\ccxt\\ExchangeError', // Unexpected withdraw exception
                    '8310' => '\\ccxt\\InvalidAddress', // Cannot find withdrawal destination
                    '8311' => '\\ccxt\\BadRequest', // Missing fields in withdraw
                    '8313' => '\\ccxt\\BadRequest', // Unsupported coin
                    '8315' => '\\ccxt\\OperationRejected', // Crypto deposit not found
                    '8316' => '\\ccxt\\OperationRejected', // Unable to allocate deposit address
                    '8317' => '\\ccxt\\OperationRejected', // Swift code is on the restricted list
                    '8318' => '\\ccxt\\NotSupported', // Unsupported operation
                    '8319' => '\\ccxt\\NotSupported', // Custody operation has been disabled
                    '8320' => '\\ccxt\\InvalidAddress', // Address failed validation
                    '8322' => '\\ccxt\\BadRequest', // Bad withdrawal amount
                    '8327' => '\\ccxt\\AuthenticationError', // Invalid Login
                    '8329' => '\\ccxt\\ExchangeError', // Unexpected destination exception
                    '8331' => '\\ccxt\\InvalidAddress', // Invalid Destination
                    '8332' => '\\ccxt\\BadRequest', // Bad network specified
                    '8333' => '\\ccxt\\BadRequest', // Bad symbol specified
                    '8334' => '\\ccxt\\BadRequest', // Bad authentication type
                    '8335' => '\\ccxt\\InvalidAddress', // Withdrawal destination does not belong to user
                    '8336' => '\\ccxt\\InvalidAddress', // Withdrawal destination not whitelisted
                    '8399' => '\\ccxt\\ExchangeError', // Unknown error
                ),
                'broad' => array(
                    'HttpInvalidParameterException' => '\\ccxt\\BadRequest',
                    'UNAUTHORIZED_COMMAND' => '\\ccxt\\AuthenticationError', // array("message":"Unauthorized to execute command","raw":null,"errorCode":6105,"errorCodeName":"UNAUTHORIZED_COMMAND")
                    'QUERY_FILTER_ERROR' => '\\ccxt\\BadRequest', // array("message":"Field 'settlementDatetime' cannot be filtered","errorCode":23001,"errorCodeName":"QUERY_FILTER_ERROR")
                    'INVALID_SYMBOL' => '\\ccxt\\BadSymbol', // array("message":"Invalid symbol provided","errorCode":28004,"errorCodeName":"INVALID_SYMBOL")
                ),
            ),
        ));
    }

    public function fetch_time($params = array ()): ?int {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--time
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $response = $this->publicGetV1Time ($params);
        //
        //     {
        //         "datetime" => "2025-05-05T20:05:50.999Z",
        //         "timestamp" => 1746475550999
        //     }
        //
        return $this->safe_integer($response, 'timestamp');
    }

    public function fetch_currencies($params = array ()): ?array {
        /**
         * fetches all available currencies on an exchange
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/assets
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an associative dictionary of currencies
         */
        $response = $this->publicGetV1Assets ($params);
        //
        //     array(
        //         {
        //             "assetId" => "72",
        //             "symbol" => "BTT1M",
        //             "name" => "BitTorrent (millions)",
        //             "precision" => "5",
        //             "minBalanceInterest" => "0.00000",
        //             "apr" => "10.00",
        //             "minFee" => "0.00000",
        //             "maxBorrow" => "0.00000",
        //             "totalOfferedLoanQuantity" => "0.00000",
        //             "loanBorrowedQuantity" => "0.00000",
        //             "collateralBands":
        //                 array(
        //                     array(
        //                         "collateralPercentage" => "90.00",
        //                         "bandLimitUSD" => "100000.0000"
        //                     ),
        //                     array(
        //                         "collateralPercentage" => "68.00",
        //                         "bandLimitUSD" => "300000.0000"
        //                     ),
        //                     {
        //                         "collateralPercentage" => "25.00",
        //                         "bandLimitUSD" => "600000.0000"
        //                     }
        //                 ),
        //             "underlyingAsset":
        //                 array(
        //                     "symbol" => "BTT1M",
        //                     "assetId" => "72",
        //                     "bpmMinReturnStart" => "0.9200",
        //                     "bpmMinReturnEnd" => "0.9300",
        //                     "bpmMaxReturnStart" => "1.0800",
        //                     "bpmMaxReturnEnd" => "1.0800",
        //                     "marketRiskFloorPctStart" => "2.60",
        //                     "marketRiskFloorPctEnd" => "2.50",
        //                     "bpmTransitionDateTimeStart" => "2025-05-05T08:00:00.000Z",
        //                     "bpmTransitionDateTimeEnd" => "2025-05-08T08:00:00.000Z"
        //                 }
        //         ), ...
        //     )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $currency = $response[$i];
            $id = $this->safe_string($currency, 'symbol');
            $code = $this->safe_currency_code($id);
            $name = $this->safe_string($currency, 'name');
            $precision = $this->safe_string($currency, 'precision');
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'name' => $name,
                'active' => null,
                'deposit' => null,
                'withdraw' => null,
                'fee' => $this->safe_number($currency, 'minFee'),
                'precision' => $this->parse_number($this->parse_precision($precision)),
                'limits' => array(
                    'amount' => array( 'min' => null, 'max' => null ),
                    'withdraw' => array( 'min' => null, 'max' => null ),
                ),
                'networks' => array(),
                'type' => 'crypto',
                'info' => $currency,
            );
        }
        return $result;
    }

    public function fetch_markets($params = array ()): array {
        /**
         * retrieves data on all markets for ace
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        if ($this->options['adjustForTimeDifference']) {
            $this->load_time_difference();
        }
        $response = $this->publicGetV1Markets ($params);
        return $this->parse_markets($response);
    }

    public function parse_market(array $market): array {
        //
        //     {
        //         "marketId" => "20069",
        //         "symbol" => "BTC-USDC-20250516",
        //         "quoteAssetId" => "5",
        //         "baseAssetId" => "1",
        //         "quoteSymbol" => "USDC",
        //         "baseSymbol" => "BTC",
        //         "quotePrecision" => "4",
        //         "basePrecision" => "8",
        //         "pricePrecision" => "4",
        //         "quantityPrecision" => "8",
        //         "costPrecision" => "4",
        //         "minQuantityLimit" => "0.00050000",
        //         "maxQuantityLimit" => "200.00000000",
        //         "maxPriceLimit" => null,
        //         "minPriceLimit" => null,
        //         "maxCostLimit" => null,
        //         "minCostLimit" => null,
        //         "timeZone" => "Etc/UTC",
        //         "tickSize" => "0.1000",
        //         "liquidityTickSize" => "100.0000",
        //         "liquidityPrecision" => "4",
        //         "makerFee" => "0",
        //         "takerFee" => "2",
        //         "roundingCorrectionFactor" => "0.00000100",
        //         "makerMinLiquidityAddition" => "1000000",
        //         "orderTypes":
        //             array(
        //                 "LMT",
        //                 "MKT",
        //                 "STOP_LIMIT",
        //                 "POST_ONLY"
        //             ),
        //         "spotTradingEnabled" => true,
        //         "marginTradingEnabled" => true,
        //         "marketEnabled" => true,
        //         "createOrderEnabled" => true,
        //         "cancelOrderEnabled" => true,
        //         "liquidityInvestEnabled" => true,
        //         "liquidityWithdrawEnabled" => true,
        //         "feeTiers":
        //             array(
        //                 array(
        //                     "feeTierId" => "1",
        //                     "staticSpreadFee" => "0.00000000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "10",
        //                     "staticSpreadFee" => "0.00100000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "11",
        //                     "staticSpreadFee" => "0.00150000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "12",
        //                     "staticSpreadFee" => "0.00150000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "13",
        //                     "staticSpreadFee" => "0.00300000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "14",
        //                     "staticSpreadFee" => "0.00300000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "15",
        //                     "staticSpreadFee" => "0.00500000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "16",
        //                     "staticSpreadFee" => "0.00500000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "17",
        //                     "staticSpreadFee" => "0.01000000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "18",
        //                     "staticSpreadFee" => "0.01000000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "19",
        //                     "staticSpreadFee" => "0.01500000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "2",
        //                     "staticSpreadFee" => "0.00000000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "20",
        //                     "staticSpreadFee" => "0.01500000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "21",
        //                     "staticSpreadFee" => "0.02000000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "22",
        //                     "staticSpreadFee" => "0.02000000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "3",
        //                     "staticSpreadFee" => "0.00010000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "4",
        //                     "staticSpreadFee" => "0.00010000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "5",
        //                     "staticSpreadFee" => "0.00020000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "6",
        //                     "staticSpreadFee" => "0.00020000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 array(
        //                     "feeTierId" => "7",
        //                     "staticSpreadFee" => "0.00060000",
        //                     "isDislocationEnabled" => false
        //                 ),
        //                 array(
        //                     "feeTierId" => "8",
        //                     "staticSpreadFee" => "0.00060000",
        //                     "isDislocationEnabled" => true
        //                 ),
        //                 {
        //                     "feeTierId" => "9",
        //                     "staticSpreadFee" => "0.00100000",
        //                     "isDislocationEnabled" => false
        //                 }
        //             ),
        //         "marketType" => "DATED_FUTURE",
        //         "contractMultiplier" => "1",
        //         "settlementAssetSymbol" => "USDC",
        //         "underlyingQuoteSymbol" => "USDC",
        //         "underlyingBaseSymbol" => "BTC",
        //         "openInterestLimitUSD" => "100000000.0000",
        //         "concentrationRiskPercentage" => "100.00",
        //         "concentrationRiskThresholdUSD" => "30000000.0000",
        //         "expiryDatetime" => "2025-05-16T08:00:00.000Z",
        //         "priceBuffer" => "0.1",
        //         "feeGroupId" => "4"
        //     }
        //
        // $option
        //     {
        //         "marketId" => "20997",
        //         "symbol" => "BTC-USDC-20260130-160000-P",
        //         "quoteAssetId" => "5",
        //         "baseAssetId" => "1",
        //         "quoteSymbol" => "USDC",
        //         "baseSymbol" => "BTC",
        //         "quotePrecision" => "4",
        //         "basePrecision" => "8",
        //         "pricePrecision" => "4",
        //         "quantityPrecision" => "8",
        //         "costPrecision" => "4",
        //         "minQuantityLimit" => "0.00050000",
        //         "maxQuantityLimit" => "200.00000000",
        //         "maxPriceLimit" => null,
        //         "minPriceLimit" => null,
        //         "maxCostLimit" => null,
        //         "minCostLimit" => null,
        //         "timeZone" => "Etc/UTC",
        //         "tickSize" => "10.0000",
        //         "makerFee" => "0",
        //         "takerFee" => "2",
        //         "roundingCorrectionFactor" => "0.00000100",
        //         "makerMinLiquidityAddition" => "-1",
        //         "orderTypes" => array( "LMT", "MKT", "STOP_LIMIT", "POST_ONLY" ),
        //         "spotTradingEnabled" => true,
        //         "marginTradingEnabled" => true,
        //         "marketEnabled" => true,
        //         "createOrderEnabled" => true,
        //         "cancelOrderEnabled" => true,
        //         "amendOrderEnabled" => true,
        //         "marketType" => "OPTION",
        //         "contractMultiplier" => "1",
        //         "settlementAssetSymbol" => "USDC",
        //         "underlyingQuoteSymbol" => "USDC",
        //         "underlyingBaseSymbol" => "BTC",
        //         "openInterestLimitUSD" => "100000000.0000",
        //         "concentrationRiskPercentage" => "100.00",
        //         "concentrationRiskThresholdUSD" => "30000000.0000",
        //         "expiryDatetime" => "2026-01-30T08:00:00.000Z",
        //         "priceBuffer" => "0",
        //         "feeGroupId" => "10",
        //         "optionStrikePrice" => "160000.0000",
        //         "optionType" => "PUT",
        //         "premiumCapRatio" => "0.1000"
        //     }
        //
        $id = $this->safe_string($market, 'symbol');
        $baseId = $this->safe_string($market, 'baseSymbol');
        $quoteId = $this->safe_string($market, 'quoteSymbol');
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $symbol = $base . '/' . $quote;
        $basePrecision = $this->safe_string($market, 'basePrecision');
        $quotePrecision = $this->safe_string($market, 'quotePrecision');
        $amountPrecision = $this->safe_string($market, 'quantityPrecision');
        $pricePrecision = $this->safe_string($market, 'pricePrecision');
        $costPrecision = $this->safe_string($market, 'costPrecision');
        $minQuantityLimit = $this->safe_string($market, 'minQuantityLimit');
        $maxQuantityLimit = $this->safe_string($market, 'maxQuantityLimit');
        $minPriceLimit = $this->safe_string($market, 'minPriceLimit');
        $maxPriceLimit = $this->safe_string($market, 'maxPriceLimit');
        $minCostLimit = $this->safe_string($market, 'minCostLimit');
        $maxCostLimit = $this->safe_string($market, 'maxCostLimit');
        $settleId = $this->safe_string($market, 'settlementAssetSymbol');
        $settle = $this->safe_currency_code($settleId);
        $type = $this->parse_market_type($this->safe_string($market, 'marketType'), 'spot');
        $spot = false;
        $swap = false;
        $future = false;
        $option = false;
        $contract = true;
        $linear = null;
        $inverse = null;
        $expiryDatetime = null;
        $contractSize = null;
        $optionType = null;
        $strike = null;
        $margin = false;
        if ($type === 'spot') {
            $spot = true;
            $contract = false;
            $margin = $this->safe_bool($market, 'marginTradingEnabled');
        } else {
            $contractSize = $this->safe_number($market, 'contractMultiplier');
            $symbol .= ':' . $settle;
            $linear = $settle === $quote;
            $inverse = !$linear;
            if ($type === 'swap') {
                $swap = true;
            } else {
                $expiryDatetime = $this->safe_string($market, 'expiryDatetime');
                $idParts = explode('-', $id);
                $datePart = $this->safe_string($idParts, 2);
                $symbol .= '-' . $datePart;
                if ($type === 'future') {
                    $future = true;
                } elseif ($type === 'option') {
                    $option = true;
                    $optionType = $this->safe_string_lower($market, 'optionType');
                    $strike = $this->parse_to_numeric($this->safe_string($market, 'optionStrikePrice'));
                    $symbol .= '-' . $this->number_to_string($strike) . '-' . $this->safe_string($idParts, 4);
                }
            }
        }
        return $this->safe_market_structure(array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'baseId' => $baseId,
            'quote' => $quote,
            'quoteId' => $quoteId,
            'settle' => $settle,
            'settleId' => $settleId,
            'type' => $type,
            'spot' => $spot,
            'margin' => $margin,
            'swap' => $swap,
            'future' => $future,
            'option' => $option,
            'contract' => $contract,
            'linear' => $linear,
            'inverse' => $inverse,
            'taker' => $this->fees['trading']['taker'],
            'maker' => $this->fees['trading']['maker'],
            'contractSize' => $contractSize,
            'expiry' => $this->parse8601($expiryDatetime),
            'expiryDatetime' => $expiryDatetime,
            'strike' => $strike,
            'optionType' => $optionType,
            'limits' => array(
                'amount' => array(
                    'min' => $this->parse_number($minQuantityLimit),
                    'max' => $this->parse_number($maxQuantityLimit),
                ),
                'price' => array(
                    'min' => $this->parse_number($minPriceLimit),
                    'max' => $this->parse_number($maxPriceLimit),
                ),
                'cost' => array(
                    'min' => $this->parse_number($minCostLimit),
                    'max' => $this->parse_number($maxCostLimit),
                ),
                'leverage' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'precision' => array(
                'amount' => $this->parse_number($this->parse_precision($amountPrecision)),
                'price' => $this->parse_number($this->parse_precision($pricePrecision)),
                'cost' => $this->parse_number($this->parse_precision($costPrecision)),
                'base' => $this->parse_number($this->parse_precision($basePrecision)),
                'quote' => $this->parse_number($this->parse_precision($quotePrecision)),
            ),
            'active' => $this->safe_bool($market, 'marketEnabled'),
            'created' => null,
            'info' => $market,
        ));
    }

    public function parse_market_type(string $type, ?string $defaultType = null): string {
        $types = array(
            'SPOT' => 'spot',
            'PERPETUAL' => 'swap',
            'DATED_FUTURE' => 'future',
            'OPTION' => 'option',
        );
        return $this->safe_string($types, $type, $defaultType);
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-$symbol-/orderbook/hybrid
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return (not used by bullish)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->publicGetV1MarketsSymbolOrderbookHybrid ($this->extend($request, $params));
        //
        //     {
        //         "bids" => array(
        //             {
        //                 "price" => "1.00000000",
        //                 "priceLevelQuantity" => "1.00000000"
        //             }
        //         ),
        //         "asks" => array(
        //             {
        //                 "price" => "1.00000000",
        //                 "priceLevelQuantity" => "1.00000000"
        //             }
        //         ),
        //         "datetime" => "2021-05-20T01:01:01.000Z",
        //         "timestamp" => "1621490985000",
        //         "sequenceNumber" => 999
        //     }
        //
        $timestamp = $this->safe_integer($response, 'timestamp');
        return $this->parse_order_book($response, $symbol, $timestamp, 'bids', 'asks', 'price', 'priceLevelQuantity');
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-$symbol-/trades
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/markets/-$symbol-/trades
         *
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum amount of trades to fetch (max 100)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest trade to fetch
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/?id=public-trades trade structures~
         */
        $this->load_markets();
        $maxLimit = 100;
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchFundingRateHistory', 'paginate');
        if ($paginate) {
            $params = $this->handle_pagination_params('fetchTrades', $since, $params);
            return $this->fetch_paginated_call_dynamic('fetchTrades', $symbol, $since, $limit, $params, $maxLimit);
        }
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $params = $this->handle_since_and_until($since, $params);
        if ($limit !== null) {
            $request['_pageSize'] = $this->get_closest_limit($limit);
        }
        $response = $this->publicGetV1HistoryMarketsSymbolTrades ($this->extend($request, $params));
        //
        //     array(
        //         array(
        //             "tradeId" => "100178000000367159",
        //             "symbol" => "BTCUSDC",
        //             "price" => "103891.8977",
        //             "quantity" => "0.00029411",
        //             "quoteAmount" => "30.5556",
        //             "side" => "BUY",
        //             "isTaker" => true,
        //             "createdAtTimestamp" => "1747768055826",
        //             "createdAtDatetime" => "2025-05-20T19:07:35.826Z"
        //         ), ...
        //     )
        //
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all trades made by the user
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/trades
         *
         * @param {string} [$symbol] unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch trades for
         * @param {string} [$params->orderId] the order id to fetch trades for
         * @param {string} [$params->clientOrderId] the client order id to fetch trades for
         * @param {string} [$params->tradingAccountId] the trading account id to fetch trades for
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/?id=trade-structure trade structures~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $request = array(
            'tradingAccountId' => $tradingAccountId,
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        $response = null;
        if ($clientOrderId !== null) {
            $response = $this->privateGetV1TradesClientOrderIdClientOrderId ($this->extend($request, $params));
        } else {
            $paginate = false;
            list($paginate, $params) = $this->handle_option_and_params($params, 'fetchMyTrades', 'paginate');
            if ($paginate) {
                $params = $this->handle_pagination_params('fetchMyTrades', $since, $params);
                return $this->fetch_paginated_call_dynamic('fetchMyTrades', $symbol, $since, $limit, $params, 100);
            }
            $params = $this->handle_since_and_until($since, $params);
            if ($limit !== null) {
                $request['_pageSize'] = $this->get_closest_limit($limit);
            }
            //
            //     array(
            //         array(
            //             "baseFee" => "0.00000000",
            //             "createdAtDatetime" => "2025-05-18T15:57:28.132Z",
            //             "createdAtTimestamp" => "1747583848132",
            //             "handle" => null,
            //             "isTaker" => true,
            //             "orderId" => "844242293909618689",
            //             "price" => "103942.7048",
            //             "publishedAtTimestamp" => "1747769786131",
            //             "quantity" => "1.00000000",
            //             "quoteAmount" => "103942.7048",
            //             "quoteFee" => "0.0000",
            //             "side" => "BUY",
            //             "symbol" => "BTCUSDC",
            //             "tradeId" => "100178000000288892"
            //         ), ...
            //     )
            //
            $response = $this->privateGetV1HistoryTrades ($this->extend($request, $params));
        }
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all the trades made from a single order
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/trades
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->clientOrderId] the client order $id to fetch trades for
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?$id=trade-structure trade structures~
         */
        $this->load_markets();
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId === null) {
            $params = $this->extend(array( 'orderId' => $id ), $params);
        }
        return $this->fetch_my_trades($symbol, $since, $limit, $params);
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        //
        // fetchTrades
        //     array(
        //         array(
        //             "tradeId" => "100178000000367159",
        //             "symbol" => "BTCUSDC",
        //             "price" => "103891.8977",
        //             "quantity" => "0.00029411",
        //             "quoteAmount" => "30.5556",
        //             "side" => "BUY",
        //             "isTaker" => true,
        //             "createdAtTimestamp" => "1747768055826",
        //             "createdAtDatetime" => "2025-05-20T19:07:35.826Z"
        //         ), ...
        //     )
        //
        //     array(
        //         {
        //             "tradeId" => "100020000000000060",
        //             "symbol" => "BTCUSDC",
        //             "price" => "1.00000000",
        //             "quantity" => "1.00000000",
        //             "side" => "BUY",
        //             "isTaker" => true,
        //             "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //             "createdAtTimestamp" => "1621490985000"
        //         }
        //     )
        //
        // fetchMyTrades
        //     array(
        //         array(
        //             "baseFee" => "0.00000000",
        //             "createdAtDatetime" => "2025-05-18T15:57:28.132Z",
        //             "createdAtTimestamp" => "1747583848132",
        //             "handle" => null,
        //             "isTaker" => true,
        //             "orderId" => "844242293909618689",
        //             "price" => "103942.7048",
        //             "publishedAtTimestamp" => "1747769786131",
        //             "quantity" => "1.00000000",
        //             "quoteAmount" => "103942.7048",
        //             "quoteFee" => "0.0000",
        //             "side" => "BUY",
        //             "symbol" => "BTCUSDC",
        //             "tradeId" => "100178000000288892"
        //         ), ...
        //     )
        //
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($trade, 'createdAtTimestamp');
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'quantity');
        $side = $this->safe_string_lower($trade, 'side');
        $isTaker = $this->safe_bool($trade, 'isTaker');
        $currency = $market['quote'];
        $code = $this->safe_currency_code($currency);
        $feeCost = $this->safe_number($trade, 'quoteFee');
        $fee = null;
        if ($feeCost !== null) {
            $fee = array( 'currency' => $code, 'cost' => $feeCost );
        }
        $takerOrMaker = null;
        if ($isTaker) {
            $takerOrMaker = 'taker';
        } else {
            $takerOrMaker = 'maker';
        }
        $orderId = $this->safe_string($trade, 'orderId');
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $this->safe_string($trade, 'tradeId'),
            'order' => $orderId,
            'type' => null,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_ticker(string $symbol, $params = array ()): array {
        /**
         * fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-$symbol-/tick
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/?id=ticker-structure ticker structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->publicGetV1MarketsSymbolTick ($this->extend($request, $params));
        //
        //     {
        //         "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //         "createdAtTimestamp" => "1621490985000",
        //         "high" => "1.00000000",
        //         "low" => "1.00000000",
        //         "bestBid" => "1.00000000",
        //         "bidVolume" => "1.00000000",
        //         "bestAsk" => "1.00000000",
        //         "askVolume" => "1.00000000",
        //         "vwap" => "1.00000000",
        //         "open" => "1.00000000",
        //         "close" => "1.00000000",
        //         "last" => "1.00000000",
        //         "change" => "1.00000000",
        //         "percentage" => "1.00000000",
        //         "average" => "1.00000000",
        //         "baseVolume" => "1.00000000",
        //         "quoteVolume" => "1.00000000",
        //         "bancorPrice" => "1.00000000",
        //         "markPrice" => "19999.00",
        //         "fundingRate" => "0.01",
        //         "openInterest" => "100000.32452",
        //         "lastTradeDatetime" => "2021-05-20T01:01:01.000Z",
        //         "lastTradeTimestamp" => "1621490985000",
        //         "lastTradeQuantity" => "1.00000000",
        //         "ammData" => array(
        //             {
        //                 "feeTierId" => "1",
        //                 "bidSpreadFee" => "0.00040000",
        //                 "askSpreadFee" => "0.00040000",
        //                 "baseReservesQuantity" => "245.56257825",
        //                 "quoteReservesQuantity" => "3424383.3629",
        //                 "currentPrice" => "16856.0000"
        //             }
        //         )
        //     }
        //
        return $this->parse_ticker($response, $market);
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //     {
        //         "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //         "createdAtTimestamp" => "1621490985000",
        //         "high" => "1.00000000",
        //         "low" => "1.00000000",
        //         "bestBid" => "1.00000000",
        //         "bidVolume" => "1.00000000",
        //         "bestAsk" => "1.00000000",
        //         "askVolume" => "1.00000000",
        //         "vwap" => "1.00000000",
        //         "open" => "1.00000000",
        //         "close" => "1.00000000",
        //         "last" => "1.00000000",
        //         "change" => "1.00000000",
        //         "percentage" => "1.00000000",
        //         "average" => "1.00000000",
        //         "baseVolume" => "1.00000000",
        //         "quoteVolume" => "1.00000000",
        //         "bancorPrice" => "1.00000000",
        //         "markPrice" => "19999.00",
        //         "fundingRate" => "0.01",
        //         "openInterest" => "100000.32452",
        //         "lastTradeDatetime" => "2021-05-20T01:01:01.000Z",
        //         "lastTradeTimestamp" => "1621490985000",
        //         "lastTradeQuantity" => "1.00000000",
        //         "ammData" => array(
        //             {
        //                 "feeTierId" => "1",
        //                 "bidSpreadFee" => "0.00040000",
        //                 "askSpreadFee" => "0.00040000",
        //                 "baseReservesQuantity" => "245.56257825",
        //                 "quoteReservesQuantity" => "3424383.3629",
        //                 "currentPrice" => "16856.0000"
        //             }
        //         )
        //     }
        //
        $marketId = $this->safe_string($ticker, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($ticker, 'createdAtTimestamp');
        return $this->safe_ticker(array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string_2($ticker, 'bid', 'bestBid'),
            'bidVolume' => $this->safe_string($ticker, 'bidVolume'),
            'ask' => $this->safe_string_2($ticker, 'ask', 'bestAsk'),
            'askVolume' => $this->safe_string($ticker, 'askVolume'),
            'vwap' => $this->safe_string($ticker, 'vwap'),
            'open' => $this->safe_string($ticker, 'open'),
            'close' => $this->safe_string($ticker, 'close'),
            'last' => $this->safe_string($ticker, 'last'),
            'previousClose' => null,
            'change' => $this->safe_string($ticker, 'change'),
            'percentage' => $this->safe_string($ticker, 'percentage'),
            'average' => $this->safe_string($ticker, 'average'),
            'baseVolume' => $this->safe_string($ticker, 'baseVolume'),
            'quoteVolume' => $this->safe_string($ticker, 'quoteVolume'),
            'markPrice' => $this->safe_string($ticker, 'markPrice'),
            'info' => $ticker,
        ), $market);
    }

    public function safe_deterministic_call(string $method, ?string $symbol = null, ?int $since = null, ?int $limit = null, ?string $timeframe = null, $params = array ()) {
        $maxRetries = null;
        list($maxRetries, $params) = $this->handle_option_and_params($params, $method, 'maxRetries', 3);
        $errors = 0;
        $params = $this->omit($params, 'until');
        // the exchange returns the most recent data, so we do not need to pass until into paginated calls
        // the correct util value will be calculated inside of the $method
        while ($errors <= $maxRetries) {
            try {
                if ($timeframe && $method !== 'fetchFundingRateHistory') {
                    return $this->$method ($symbol, $timeframe, $since, $limit, $params);
                } else {
                    return $this->$method ($symbol, $since, $limit, $params);
                }
            } catch (Exception $e) {
                if ($e instanceof RateLimitExceeded) {
                    throw $e; // if we are rate limited, we should not retry and fail fast
                }
                $errors += 1;
                if ($errors > $maxRetries) {
                    throw $e;
                }
            }
        }
        return array();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-$symbol-/candle
         *
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch (max 100)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest entry
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $maxLimit = 100;
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchOHLCV', 'paginate');
        if ($paginate) {
            return $this->fetch_paginated_call_deterministic('fetchOHLCV', $symbol, $since, $limit, $timeframe, $params, $maxLimit);
        }
        $request = array(
            'symbol' => $market['id'],
            'timeBucket' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
            '_pageSize' => $maxLimit,
        );
        list($request, $params) = $this->handle_until_option('createdAtDatetime[lte]', $request, $params);
        $until = $this->safe_integer($request, 'createdAtDatetime[lte]');
        $duration = $this->parse_timeframe($timeframe);
        $maxDelta = 1000 * $duration * $maxLimit;
        $startTime = $since;
        // both of $since and $until are required
        if ($startTime === null && $until === null) {
            $until = $this->milliseconds();
            $startTime = $until - $maxDelta;
        } elseif ($startTime === null) {
            $startTime = $until - $maxDelta;
        } elseif ($until === null) {
            $until = $this->sum($startTime, $maxDelta);
        }
        $request['createdAtDatetime[gte]'] = $this->iso8601($startTime);
        $request['createdAtDatetime[lte]'] = $this->iso8601($until);
        $response = $this->publicGetV1MarketsSymbolCandle ($this->extend($request, $params));
        //
        //     array(
        //         array(
        //             "open" => "100846.7490",
        //             "high" => "100972.4001",
        //             "low" => "100840.8129",
        //             "close" => "100972.2602",
        //             "volume" => "30.56064890",
        //             "createdAtTimestamp" => "1746720540000",
        //             "createdAtDatetime" => "2025-05-08T16:09:00.000Z",
        //             "publishedAtTimestamp" => "1746720636007"
        //         ), ...
        //     )
        //
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, ?array $market = null): array {
        return array(
            $this->safe_integer($ohlcv, 'createdAtTimestamp'),
            $this->safe_number($ohlcv, 'open'),
            $this->safe_number($ohlcv, 'high'),
            $this->safe_number($ohlcv, 'low'),
            $this->safe_number($ohlcv, 'close'),
            $this->safe_number($ohlcv, 'volume'),
        );
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical funding rate prices
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/markets/-$symbol-/funding-rate
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int} [$since] not sent to exchange api, exchange api always returns the most recent data, only used to filter exchange $response
         * @param {int} [$limit] the maximum amount of funding rate structures to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=funding-rate-history-structure funding rate structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        $this->load_markets();
        $maxLimit = 100;
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchFundingRateHistory', 'paginate');
        if ($paginate) {
            $params = $this->handle_pagination_params('fetchFundingRateHistory', $since, $params);
            return $this->fetch_paginated_call_dynamic('fetchFundingRateHistory', $symbol, $since, $limit, $params, $maxLimit);
        }
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new BadRequest($this->id . ' fetchFundingRateHistory() supports swap markets only');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['_pageSize'] = $this->get_closest_limit($limit);
        }
        $params = $this->handle_since_and_until($since, $params, 'updatedAtDatetime[gte]', 'updatedAtDatetime[lte]');
        $response = $this->publicGetV1HistoryMarketsSymbolFundingRate ($this->extend($request, $params));
        //
        //     array(
        //         array(
        //             "fundingRate" => "0.00125",
        //             "updatedAtDatetime" => "2025-05-18T09:06:04.074Z"
        //         ),
        //         array(
        //             "fundingRate" => "0.00125",
        //             "updatedAtDatetime" => "2025-05-18T08:59:59.033Z"
        //         ), ...
        //     )
        //
        $rates = array();
        $result = $this->to_array($response);
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $datetime = $this->safe_string($entry, 'updatedAtDatetime');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $this->parse8601($datetime),
                'datetime' => $datetime,
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $market['symbol'], $since, $limit);
    }

    public function fetch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple orders made by the user
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--orders
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--history
         *
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve (5, 25, 50, 100, default is 25)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest order to fetch
         * @param {string} [$params->tradingAccountId] the trading account id (mandatory parameter)
         * @param {string} [$params->orderId] the id of the order to fetch for
         * @param {string} [$params->clientOrderId] the client id of the order to fetch for
         * @param {string} [$params->status] filter by order status, 'OPEN', 'CANCELLED', 'CLOSED', 'REJECTED'
         * @param {bool} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $paginate = $this->safe_bool($params, 'paginate', false);
        if ($paginate) {
            $params = $this->handle_pagination_params('fetchOrders', $since, $params);
            return $this->fetch_paginated_call_dynamic('fetchOrders', $symbol, $since, $limit, $params, 100);
        }
        $market = null;
        $request = array(
            'tradingAccountId' => $tradingAccountId,
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $params = $this->handle_since_and_until($since, $params);
        if ($limit !== null) {
            $request['_pageSize'] = $this->get_closest_limit($limit);
        }
        $method = 'privateGetV2HistoryOrders';
        list($method, $params) = $this->handle_option_and_params($params, 'fetchOrders', 'method', $method);
        $response = null;
        if ($method === 'privateGetV2Orders') {
            //
            //     array(
            //         {
            //             "clientOrderId" => "187",
            //             "orderId" => "297735387747975681",
            //             "symbol" => "BTCUSDC",
            //             "price" => "1.00000000",
            //             "averageFillPrice" => "1.00000000",
            //             "stopPrice" => "1.00000000",
            //             "allowBorrow" => false,
            //             "quantity" => "1.00000000",
            //             "quantityFilled" => "1.00000000",
            //             "quoteAmount" => "1.00000000",
            //             "baseFee" => "0.00100000",
            //             "quoteFee" => "0.0010",
            //             "borrowedBaseQuantity" => "1.00000000",
            //             "borrowedQuoteQuantity" => "1.00000000",
            //             "isLiquidation" => false,
            //             "side" => "BUY",
            //             "type" => "LMT",
            //             "timeInForce" => "GTC",
            //             "status" => "OPEN",
            //             "statusReason" => "User cancelled",
            //             "statusReasonCode" => "1002",
            //             "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
            //             "createdAtTimestamp" => "1621490985000",
            //         }
            //     )
            //
            $response = $this->privateGetV2Orders ($this->extend($request, $params));
        } elseif ($method === 'privateGetV2HistoryOrders') {
            $response = $this->privateGetV2HistoryOrders ($this->extend($request, $params));
        } else {
            throw new BadRequest($this->id . ' fetchOrders() $method parameter must be either "privateGetV2Orders" or "privateGetV2HistoryOrders"');
        }
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function handle_pagination_params(string $method, ?int $since = null, array $params = array ()): array {
        $ninetyDays = 90 * 24 * 60 * 60 * 1000;
        $now = $this->milliseconds();
        $allowedSince = $now - $ninetyDays;
        if (($since !== null) && ($since < $allowedSince)) {
            throw new BadRequest($this->id . ' ' . $method . '() only allows fetching entries up to 90 days in the past');
        }
        $params = $this->omit($params, 'paginate');
        $params = $this->extend($params, array( 'paginationDirection' => 'backward' ));
        $until = $this->safe_integer($params, 'until');
        if ($until === null) {
            $params = $this->extend($params, array( 'until' => $now ));
        }
        return $params;
    }

    public function handle_since_and_until(?int $since = null, array $params = array (), ?string $sinceKey = 'createdAtDatetime[gte]', ?string $untilKey = 'createdAtDatetime[lte]'): array {
        $until = $this->safe_integer($params, 'until');
        if (($since !== null) || ($until !== null)) {
            $timeDelta = 7 * 24 * 60 * 60 * 1000; // 7 days
            if ($since === null) {
                $since = $until - $timeDelta;
                $params = $this->omit($params, 'until');
            } elseif ($until === null) {
                $until = $this->sum($since, $timeDelta);
                $now = $this->milliseconds();
                if ($until > $now) {
                    $until = $now;
                }
            }
            $sinceDate = $this->iso8601($since);
            $untilDate = $this->iso8601($until);
            $params[$sinceKey] = $sinceDate;
            $params[$untilKey] = $untilDate;
        }
        return $params;
    }

    public function get_closest_limit(?int $limit): ?int {
        $pageSize = 5;
        if (($limit > 5) && ($limit < 26)) {
            $pageSize = 25;
        } elseif (($limit > 25) && ($limit < 51)) {
            $pageSize = 50;
        } elseif ($limit > 50) {
            $pageSize = 100;
        }
        return $pageSize;
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all unfilled currently open orders
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--history
         *
         * @param {string} $symbol unified market $symbol of the market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->tradingAccountId the trading account id (mandatory parameter)
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $request = array(
            'status' => 'OPEN',
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_canceled_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple canceled orders made by the user
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--orders
         *
         * @param {string} $symbol unified market $symbol of the canceled orders
         * @param {int} [$since] timestamp in ms of the earliest order
         * @param {int} [$limit] the max number of canceled orders to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->tradingAccountId] the trading account id (mandatory parameter)
         * @return {array} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $request = array(
            'status' => 'CANCELLED',
            'method' => 'privateGetV2Orders', // current endpoint distinquishes between CLOSED and CANCELLED orders
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple closed orders made by the user
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--orders
         *
         * @param {string} $symbol unified market $symbol of the closed orders
         * @param {int} [$since] timestamp in ms of the earliest order
         * @param {int} [$limit] the max number of closed orders to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->tradingAccountId the trading account id (mandatory parameter)
         * @return {array} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $request = array(
            'status' => 'CLOSED',
            'method' => 'privateGetV2Orders', // current endpoint distinquishes between CLOSED and CANCELLED orders
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_canceled_and_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple canceled orders made by the user
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--history
         *
         * @param {string} $symbol unified market $symbol of the closed orders
         * @param {int} [$since] timestamp in ms of the earliest order
         * @param {int} [$limit] the max number of closed orders to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->tradingAccountId] the trading account id (mandatory parameter)
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $request = array(
            'status' => 'CLOSED',
            'method' => 'privateGetV2HistoryOrders', // current endpoint returns both CLOSED and CANCELLED orders
        );
        return $this->fetch_orders($symbol, $since, $limit, $this->extend($request, $params));
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetches information on an order made by the user
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v2/orders/-orderId-
         *
         * @param {string} $id the order $id
         * @param {string} [$symbol] unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->traidingAccountId] the trading account $id (mandatory parameter)
         * @return {array} An ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'orderId' => $id,
            'tradingAccountId' => $tradingAccountId,
        );
        $response = $this->privateGetV2OrdersOrderId ($this->extend($request, $params));
        //
        //     {
        //         "clientOrderId" => "187",
        //         "orderId" => "297735387747975680",
        //         "symbol" => "BTCUSDC",
        //         "price" => "1.00000000",
        //         "averageFillPrice" => "1.00000000",
        //         "stopPrice" => "1.00000000",
        //         "allowBorrow" => false,
        //         "quantity" => "1.00000000",
        //         "quantityFilled" => "1.00000000",
        //         "quoteAmount" => "1.00000000",
        //         "baseFee" => "0.00100000",
        //         "quoteFee" => "0.0010",
        //         "borrowedBaseQuantity" => "1.00000000",
        //         "borrowedQuoteQuantity" => "1.00000000",
        //         "isLiquidation" => false,
        //         "side" => "BUY",
        //         "type" => "LMT",
        //         "timeInForce" => "GTC",
        //         "status" => "OPEN",
        //         "statusReason" => "User cancelled",
        //         "statusReasonCode" => "1002",
        //         "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //         "createdAtTimestamp" => "1621490985000",
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): array {
        /**
         * create a trade order
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/orders
         *
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit' or 'STOP_LIMIT' or 'POST_ONLY'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->clientOrderId] a custom client order id
         * @param {float} [$params->triggerPrice] the $price at which a stop order is triggered at
         * @param {string} [$params->timeInForce] the time in force for the order, either 'GTC' (Good Till Cancelled) or 'IOC' (Immediate or Cancel), default is 'GTC'
         * @param {bool} [$params->allowBorrow] if true, the order will be allowed to borrow assets to fulfill the order (default is false)
         * @param {bool} [$params->postOnly] if true, the order will only be posted to the order book and not executed immediately (default is false)
         * @param {string} $params->traidingAccountId the trading account id (mandatory parameter)
         * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $market = $this->market($symbol);
        $request = array(
            'commandType' => 'V3CreateOrder',
            'symbol' => $market['id'],
            'side' => strtoupper($side),
            'quantity' => $this->amount_to_precision($symbol, $amount),
            'tradingAccountId' => $tradingAccountId,
        );
        $isMarketOrder = (($type === 'market') || $type === 'MARKET');
        $postOnly = false;
        list($postOnly, $params) = $this->handle_post_only($isMarketOrder, $type === 'POST_ONLY', $params);
        if ($postOnly) {
            $type = 'POST_ONLY';
        }
        $timeInForce = 'GTC'; // is mandatory
        list($timeInForce, $params) = $this->handle_option_and_params($params, 'createOrder', 'timeInForce', $timeInForce);
        $params['timeInForce'] = strtoupper($timeInForce);
        if (!$isMarketOrder) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $triggerPrice = $this->safe_string($params, 'triggerPrice');
        if ($triggerPrice !== null) {
            if ($isMarketOrder) {
                throw new NotSupported($this->id . ' createOrder() does not support $market trigger orders');
            }
            $request['stopPrice'] = $this->price_to_precision($symbol, $triggerPrice);
            $type = 'STOP_LIMIT';
            $params = $this->omit($params, 'triggerPrice');
        }
        $request['type'] = strtoupper($type);
        $response = $this->privatePostV2Orders ($this->extend($request, $params));
        //
        //     {
        //         "message" => "Command acknowledged - CreateOrder",
        //         "requestId" => "633910976353665024",
        //         "orderId" => "633910775316480001",
        //         "clientOrderId" => "1234567"
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        /**
         * edit a trade limit order
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/command-amend
         *
         * @param {string} $id order $id
         * @param {string} [$symbol] unified $symbol of the $market to create an order in
         * @param {string} [$type] 'limit' or 'POST_ONLY'
         * @param {string} [$side] not used by bullish editOrder
         * @param {float} [$amount] how much of the currency you want to trade in units of the base currency
         * @param {float} [$price] the $price for the order, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->traidingAccountId] the trading account $id (mandatory parameter)
         * @param {bool} [$params->postOnly] if true, the order will only be posted to the order book and not executed immediately (default is false)
         * @param {string} [$params->clientOrderId] a unique identifier for the order, automatically generated if not sent
         * @return {array} an ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $market = $this->market($symbol);
        $request = array(
            'commandType' => 'V1AmendOrder',
            'symbol' => $market['id'],
            'tradingAccountId' => $tradingAccountId,
        );
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId === null) {
            $request['orderId'] = $id;
        }
        if ($type !== null) {
            $request['type'] = strtoupper($type);
        }
        $postOnly = $this->safe_bool($params, 'postOnly', false);
        if ($postOnly) {
            $params = $this->omit($params, 'postOnly');
            $request['type'] = 'POST_ONLY';
        }
        if ($amount !== null) {
            $request['quantity'] = $this->amount_to_precision($symbol, $amount);
        }
        if ($price !== null) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $response = $this->privatePostV2Command ($this->extend($request, $params));
        return $this->parse_order($response, $market);
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * cancels an open order
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/command-cancellations
         *
         * @param {string} [$id] order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->commandType the command type, default is 'V3CancelOrder' (mandatory parameter)
         * @param {string} [$params->traidingAccountId] the trading account $id (mandatory parameter)
         * @return {array} An ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'tradingAccountId' => $tradingAccountId,
            'commandType' => $this->safe_string($params, 'commandType', 'V3CancelOrder'),
            'orderId' => $id,
        );
        $response = $this->privatePostV2Command ($this->extend($request, $params));
        //
        //     {
        //         "message" => "Command acknowledged - CancelOrder",
        //         "requestId" => "844658480774644736",
        //         "orderId" => "297735387747975680",
        //         "clientOrderId" => null
        //     }
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()): array {
        /**
         * cancel all open $orders in a $market
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/command-cancellations
         *
         * @param {string} [$symbol] alpaca cancelAllOrders cannot setting $symbol, it will cancel all open $orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->traidingAccountId the trading account id (mandatory parameter)
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $request = array(
            'tradingAccountId' => $tradingAccountId,
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
            $request['commandType'] = 'V1CancelAllOrdersByMarket';
        } else {
            $request['commandType'] = 'V1CancelAllOrders';
        }
        $response = $this->privatePostV2Command ($this->extend($request, $params));
        //
        //     {
        //         "message" => "Command acknowledged - CancelAllOrders",
        //         "requestId" => "633900538459062272"
        //     }
        //
        $orders = array( $response );
        return $this->parse_orders($orders, $market);
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        // fetchOrders, fetchOrder
        //     {
        //         "clientOrderId" => "187",
        //         "orderId" => "297735387747975680",
        //         "symbol" => "BTCUSDC",
        //         "price" => "1.00000000",
        //         "averageFillPrice" => "1.00000000",
        //         "stopPrice" => "1.00000000",
        //         "allowBorrow" => false,
        //         "quantity" => "1.00000000",
        //         "quantityFilled" => "1.00000000",
        //         "quoteAmount" => "1.00000000",
        //         "baseFee" => "0.00100000",
        //         "quoteFee" => "0.0010",
        //         "borrowedBaseQuantity" => "1.00000000",
        //         "borrowedQuoteQuantity" => "1.00000000",
        //         "isLiquidation" => false,
        //         "side" => "BUY",
        //         "type" => "LMT",
        //         "timeInForce" => "GTC",
        //         "status" => "OPEN",
        //         "statusReason" => "User cancelled",
        //         "statusReasonCode" => "1002",
        //         "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //         "createdAtTimestamp" => "1621490985000",
        //     }
        //
        // createOrder
        //     {
        //         "message" => "Command acknowledged - CreateOrder",
        //         "requestId" => "633910976353665024",
        //         "orderId" => "633910775316480001",
        //         "clientOrderId" => "1234567"
        //     }
        //
        // cancelOrder
        //     {
        //         "message" => "Command acknowledged - CancelOrder",
        //         "requestId" => "633910976353665024",
        //         "orderId" => "633910775316480001"
        //     }
        //
        // cancelAllOrders
        //     {
        //         "message" => "Command acknowledged - CancelAllOrders",
        //         "requestId" => "633900538459062272"
        //     }
        //
        $marketId = $this->safe_string($order, 'symbol');
        if ($market === null) {
            $market = $this->safe_market($marketId);
        }
        $symbol = $this->safe_symbol($marketId, $market);
        $id = $this->safe_string($order, 'orderId');
        $timestamp = $this->safe_integer($order, 'createdAtTimestamp');
        $type = $this->safe_string($order, 'type');
        $side = $this->safe_string_lower($order, 'side');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string($order, 'quantity');
        $filled = $this->safe_string($order, 'quantityFilled');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        if ($status === 'closed') {
            $statusReason = $this->safe_string($order, 'statusReason');
            if ($statusReason === 'User cancelled') {
                $status = 'canceled';
            }
        }
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $stopPrice = $this->safe_string($order, 'stopPrice');
        $cost = $this->safe_string($order, 'quoteAmount');
        $fee = array();
        $quoteFee = $this->safe_number($order, 'quoteFee');
        if ($quoteFee !== null) {
            $fee['cost'] = $quoteFee;
            $fee['currency'] = $market['quote'];
        }
        $average = $this->safe_string($order, 'averageFillPrice');
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $this->safe_string($order, 'clientOrderId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $this->parse_order_type($type),
            'timeInForce' => $timeInForce,
            'postOnly' => $type === 'POST_ONLY',
            'side' => $side,
            'price' => $price,
            'triggerPrice' => $stopPrice,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'cost' => $cost,
            'trades' => null,
            'fee' => $fee,
            'info' => $order,
            'average' => $average,
        ), $market);
    }

    public function parse_order_status(?string $status) {
        $statuses = array(
            'OPEN' => 'open',
            'CLOSED' => 'closed',
            'CANCELLED' => 'canceled',
            'REJECTED' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type(?string $type) {
        $types = array(
            'LMT' => 'limit',
            'MKT' => 'market',
            'POST_ONLY' => 'limit',
            'STOP_LIMIT' => 'limit',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function fetch_deposits_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch history of deposits and withdrawals
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/wallets/transactions
         *
         * @param {string} [$code] unified $currency $code for the $currency of the deposit/withdrawals, default is null
         * @param {int} [$since] timestamp in ms of the earliest deposit/withdrawal, default is null
         * @param {int} [$limit] max number of deposit/withdrawals to return, default is null
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a list of ~@link https://docs.ccxt.com/?id=transaction-structure transaction structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $request = array();
        list($request, $params) = $this->handle_until_option('createdAtDatetime[lte]', $request, $params);
        $until = $this->safe_integer($request, 'createdAtDatetime[lte]');
        if ($until !== null) {
            $request['createdAtDatetime[lte]'] = $this->iso8601($until);
        }
        if ($since !== null) {
            $request['createdAtDatetime[gte]'] = $this->iso8601($since);
        }
        $response = $this->privateGetV1WalletsTransactions ($this->extend($request, $params));
        //
        //     {
        //         "data" => array(
        //             {
        //                 "custodyTransactionId" => "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
        //                 "direction" => "DEPOSIT",
        //                 "quantity" => "150",
        //                 "symbol" => "USDC",
        //                 "fee" => "0",
        //                 "memo" => "0x34625d5f0b6575503a0669994dea24271bfbd443",
        //                 "createdAtDateTime" => "2025-11-04T14:31:17.000Z",
        //                 "updatedAtDateTime" => "2025-11-04T14:44:17.500Z",
        //                 "status" => "COMPLETE",
        //                 "statusReason" => "OK",
        //                 "network" => "ETH",
        //                 "transactionDetails" => {
        //                     "address" => "0x34625d5f0b6575503a0669994dea24271bfbd443",
        //                     "blockchainTxId" => "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
        //                     "swiftUetr" => null,
        //                     "sources" => array(
        //                         {
        //                             "address" => "0x2653435d52a5f49551ebb757f25b2c8bb954859b"
        //                         }
        //                     )
        //                 }
        //             }
        //         ),
        //         "links" => array(
        //             "previous" => null,
        //             "next" => null
        //         ),
        //         "totalCount" => 1
        //     }
        //
        $data = $this->safe_list($response, 'data', array());
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
        }
        return $this->parse_transactions($data, $currency, $since, $limit);
    }

    public function withdraw(string $code, float $amount, string $address, ?string $tag = null, $params = array ()): array {
        /**
         * make a withdrawal
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v1/wallets/withdrawal
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string} [$tag]
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->timestamp the timestamp of the withdrawal $request (mandatory)
         * @param {string} $params->nonce the nonce of the withdrawal $request (mandatory)
         * @param {string} $params->network network for withdraw (mandatory)
         * @return {array} a ~@link https://docs.ccxt.com/?id=transaction-structure transaction structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        // todo check this method properly
        $currency = $this->currency($code);
        $request = array(
            'command' => array(
                'commandType' => 'V1Withdraw',
                'destinationId' => $address,
                'symbol' => $currency['id'],
                'quantity' => $this->currency_to_precision($code, $amount),
            ),
        );
        $networkCode = null;
        list($networkCode, $params) = $this->handle_network_code_and_params($params);
        if ($networkCode !== null) {
            $request['network'] = $this->network_code_to_id($networkCode);
        } else {
            throw new ArgumentsRequired($this->id . ' withdraw() requires a network parameter');
        }
        $response = $this->privatePostV1WalletsWithdrawal ($this->extend($request, $params));
        //
        //     {
        //         "code" => "00000",
        //         "msg" => "success",
        //         "data" => {
        //             "orderId":888291686266343424",
        //             "clientOrderId":"123"
        //         }
        //     }
        //
        return $this->parse_transaction($response, $currency);
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        //
        //     {
        //         "custodyTransactionId" => "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
        //         "direction" => "DEPOSIT",
        //         "quantity" => "150",
        //         "symbol" => "USDC",
        //         "fee" => "0",
        //         "memo" => "0x34625d5f0b6575503a0669994dea24271bfbd443",
        //         "createdAtDateTime" => "2025-11-04T14:31:17.000Z",
        //         "updatedAtDateTime" => "2025-11-04T14:44:17.500Z",
        //         "status" => "COMPLETE",
        //         "statusReason" => "OK",
        //         "network" => "ETH",
        //         "transactionDetails" => {
        //             "address" => "0x34625d5f0b6575503a0669994dea24271bfbd443",
        //             "blockchainTxId" => "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
        //             "swiftUetr" => null,
        //             "sources" => array(
        //                 {
        //                     "address" => "0x2653435d52a5f49551ebb757f25b2c8bb954859b"
        //                 }
        //             )
        //         }
        //     }
        //
        $id = $this->safe_string($transaction, 'custodyTransactionId');
        $type = $this->safe_string($transaction, 'direction');
        $timestamp = $this->parse8601($this->safe_string($transaction, 'createdAtDateTime'));
        $updated = $this->parse8601($this->safe_string($transaction, 'updatedAtDateTime'));
        $network = $this->safe_string($transaction, 'network');
        $transactionDetails = $this->safe_dict($transaction, 'transactionDetails');
        $txid = $this->safe_string($transactionDetails, 'blockchainTxId');
        $address = $this->safe_string($transactionDetails, 'address');
        $amount = $this->safe_number($transaction, 'quantity');
        $currencyId = $this->safe_string($transaction, 'symbol');
        $code = $this->safe_currency_code($currencyId, $currency);
        $status = $this->safe_string($transaction, 'status');
        $sources = $this->safe_list($transactionDetails, 'sources', array());
        $source = $this->safe_dict($sources, 0, array());
        $sourceAddress = $this->safe_string($source, 'address');
        $fee = array(
            'currency' => null,
            'cost' => null,
            'rate' => null,
        );
        $feeCost = $this->safe_number($transaction, 'fee');
        if ($feeCost !== null) {
            $fee['cost'] = $feeCost;
            $fee['currency'] = $code;
        }
        return array(
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $this->network_id_to_code($network),
            'addressFrom' => $sourceAddress,
            'address' => $address,
            'addressTo' => $address,
            'amount' => $amount,
            'type' => $this->parse_transaction_type($type),
            'currency' => $code,
            'status' => $this->parse_transaction_status($status),
            'updated' => $updated,
            'tagFrom' => null,
            'tag' => null,
            'tagTo' => null,
            'comment' => null,
            'internal' => null,
            'fee' => $fee,
            'info' => $transaction,
        );
    }

    public function parse_transaction_type($type) {
        $types = array(
            'DEPOSIT' => 'deposit',
            'WITHDRAW' => 'withdrawal',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_transaction_status(?string $status) {
        $statuses = array(
            'COMPLETE' => 'ok',
            'FAILED' => 'failed',
            'PENDING' => 'pending',
            'CANCELLED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function load_account($params = array ()) {
        $tradingAccountId = null;
        list($tradingAccountId, $params) = $this->handle_option_and_params($params, 'fetchMyTrades', 'tradingAccountId');
        if ($tradingAccountId === null) {
            $response = $this->privateGetV1AccountsTradingAccounts ($params);
            for ($i = 0; $i < count($response); $i++) {
                $account = $response[$i];
                $name = $this->safe_string($account, 'tradingAccountName');
                if ($name === 'Primary Account') {
                    $tradingAccountId = $this->safe_string($account, 'tradingAccountId');
                    break;
                }
            }
        }
        if ($tradingAccountId === null) {
            throw new ArgumentsRequired($this->id . ' loadAccount() requires a $tradingAccountId parameter in options["tradingAccountId"] or $params["tradingAccountId"], fetchAccounts() was not able to find the Primary account');
        }
        $this->options['tradingAccountId'] = $tradingAccountId;
        return $tradingAccountId;
    }

    public function fetch_accounts($params = array ()): array {
        /**
         * fetch all the accounts associated with a profile
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--trading-accounts
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/?id=account-structure account structures~ indexed by the account type
         */
        array( $this->load_markets(), $this->handle_token() );
        $response = $this->privateGetV1AccountsTradingAccounts ($params);
        //
        //     array(
        //         {
        //             "defaultedMarginUSD" => "0.0000",
        //             "endCustomerId" => "222801149768465",
        //             "fullLiquidationMarginUSD" => "0.0000",
        //             "initialMarginUSD" => "0.0000",
        //             "isBorrowing" => "false",
        //             "isConcentrationRiskEnabled" => "true",
        //             "isDefaulted" => "false",
        //             "isLending" => "false",
        //             "isPrimaryAccount" => "true",
        //             "liquidationMarginUSD" => "0.0000",
        //             "liquidityAddonUSD" => "0.0000",
        //             "makerFee" => "0.00000000",
        //             "marginProfile" => array(
        //                 "defaultedMarketRiskMultiplierPct" => "50.00",
        //                 "fullLiquidationMarketRiskMultiplierPct" => "75.00",
        //                 "initialMarketRiskMultiplierPct" => "200.00",
        //                 "liquidationMarketRiskMultiplierPct" => "100.00",
        //                 "warningMarketRiskMultiplierPct" => "150.00"
        //             ),
        //             "marketRiskUSD" => "0.0000",
        //             "maxInitialLeverage" => "1",
        //             "rateLimitToken" => "7fc358f0bad4124528318ff415e24f1ad6e530321827162a5e35d8de8dcfc750",
        //             "riskLimitUSD" => "0.0000",
        //             "takerFee" => "0.00000002",
        //             "totalBorrowedUSD" => "0.0000",
        //             "totalCollateralUSD" => "0.0000",
        //             "totalLiabilitiesUSD" => "0.0000",
        //             "tradeFeeRate" => array(
        //                 array(
        //                     "feeGroupId" => "1",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 array(
        //                     "feeGroupId" => "2",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 array(
        //                     "feeGroupId" => "3",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 array(
        //                     "feeGroupId" => "4",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 array(
        //                     "feeGroupId" => "5",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 array(
        //                     "feeGroupId" => "6",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 array(
        //                     "feeGroupId" => "7",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 ),
        //                 {
        //                     "feeGroupId" => "8",
        //                     "makerFee" => "0.00000000",
        //                     "takerFee" => "0.00000000"
        //                 }
        //             ),
        //             "tradingAccountDescription" => null,
        //             "tradingAccountId" => "111309424211255",
        //             "tradingAccountName" => "Primary Account",
        //             "warningMarginUSD" => "0.0000"
        //         }
        //     )
        //
        return $this->parse_accounts($response, $params);
    }

    public function parse_account(array $account): array {
        return array(
            'id' => $this->safe_string($account, 'tradingAccountId'),
            'type' => null,
            'code' => null,
            'info' => $account,
        );
    }

    public function fetch_deposit_address(string $code, $params = array ()): array {
        /**
         * fetch the deposit address for a $currency associated with this account
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/wallets/deposit-instructions/crypto/-symbol-
         *
         * @param {string} $code unified $currency $code
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->network] $network for deposit address
         * @return {array} an ~@link https://docs.ccxt.com/?id=address-structure address structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $currency = $this->currency($code);
        $request = array(
            'symbol' => $currency['id'],
        );
        $response = $this->privateGetV1WalletsDepositInstructionsCryptoSymbol ($this->extend($request, $params));
        //
        //     array(
        //         {
        //             "network" => "ETH",
        //             "address" => "0xc2fc755082d052bb334763b144851a0031999f33",
        //             "symbol" => "ETH"
        //         }
        //     )
        //
        $safeResponse = $this->to_array($response);
        $length = count($safeResponse);
        $data = $this->safe_dict($safeResponse, 0, array());
        $network = null;
        list($network, $params) = $this->handle_network_code_and_params($params);
        $networkDefinedByUser = $network !== null;
        if (($length > 1) || ($networkDefinedByUser)) {
            // some currencies have multiple networks
            if ($network === null) {
                // use default $network if not specified and multiple are available
                $network = $this->default_network_code($code);
            }
            if ($network !== null) {
                // find the $entry that matches the $network or return first $entry if not found and user did not specify a $network
                for ($i = 0; $i < count($safeResponse); $i++) {
                    $entry = $this->safe_dict($safeResponse, $i, array());
                    $networkId = $this->safe_string($entry, 'network');
                    $networkCode = $this->network_id_to_code($networkId);
                    if ($network === $networkCode) {
                        $data = $entry;
                        break;
                    }
                }
                if ($networkDefinedByUser) {
                    $data = array(); // return an empty structure if the user-defined $network was not found
                }
            }
        }
        return $this->parse_deposit_address($data, $currency);
    }

    public function parse_deposit_address($depositAddress, ?array $currency = null): array {
        $id = $this->safe_string($depositAddress, 'symbol');
        $network = $this->safe_string($depositAddress, 'network');
        return array(
            'info' => $depositAddress,
            'currency' => $this->safe_currency_code($id, $currency),
            'network' => $this->network_id_to_code($network),
            'address' => $this->safe_string($depositAddress, 'address'),
            'tag' => null,
        );
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/accounts/asset
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/accounts/asset/-symbol-
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->tradingAccountId the trading account id (mandatory parameter)
         * @param {string} [$params->code] unified currency $code, default is null
         * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $request = array(
            'tradingAccountId' => $tradingAccountId,
        );
        $response = null;
        $code = $this->safe_string($params, 'code');
        if ($code !== null) {
            $request['symbol'] = $this->currency($code)['id'];
            $response = $this->privateGetV1AccountsAssetSymbol ($this->extend($request, $params));
            return $this->parse_balance_for_single_currency($response, $code);
        } else {
            $response = $this->privateGetV1AccountsAsset ($this->extend($request, $params));
            //
            //     array(
            //         array(
            //             "assetId" => "10",
            //             "assetSymbol" => "AAVE",
            //             "availableQuantity" => "10000000.00000000",
            //             "borrowedQuantity" => "0.00000000",
            //             "loanedQuantity" => "0.00000000",
            //             "lockedQuantity" => "0.00000000",
            //             "publishedAtTimestamp" => "1747942728870",
            //             "tradingAccountId" => "111309424211255",
            //             "updatedAtDatetime" => "2025-05-13T11:33:08.801Z",
            //             "updatedAtTimestamp" => "1747135988801"
            //         ), ...
            //     )
            //
            return $this->parse_balance($response);
        }
    }

    public function parse_balance_for_single_currency($response, ?string $code): array {
        $result = array( 'info' => $response );
        $account = $this->account();
        $account['free'] = $this->safe_string($response, 'availableQuantity');
        $account['used'] = $this->safe_string($response, 'lockedQuantity');
        $result[$code] = $account;
        return $this->safe_balance($result);
    }

    public function parse_balance($response): array {
        $result = array(
            'info' => $response,
        );
        for ($i = 0; $i < count($response); $i++) {
            $balance = $response[$i];
            $symbol = $this->safe_string($balance, 'assetSymbol');
            $code = $this->safe_currency_code($symbol);
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'availableQuantity');
            $account['used'] = $this->safe_string($balance, 'lockedQuantity');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_positions(?array $symbols = null, $params = array ()): array {
        /**
         * fetch all open positions
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/derivatives-positions
         *
         * @param {string[]|null} $symbols list of unified market $symbols
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} $params->tradingAccountId the trading account id
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=position-structure position structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $request = array(
            'tradingAccountId' => $tradingAccountId,
        );
        $response = $this->privateGetV1DerivativesPositions ($this->extend($request, $params));
        //
        //     array(
        //         {
        //             "tradingAccountId" => "111000000000001",
        //             "symbol" => "BTC-USDC-PERP",
        //             "side" => "BUY",
        //             "quantity" => "1.00000000",
        //             "notional" => "1.0000",
        //             "entryNotional" => "1.0000",
        //             "mtmPnl" => "1.0000",
        //             "reportedMtmPnl" => "1.0000",
        //             "reportedFundingPnl" => "1.0000",
        //             "realizedPnl" => "1.0000",
        //             "settlementAssetSymbol" => "USDC",
        //             "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //             "createdAtTimestamp" => "1621490985000",
        //             "updatedAtDatetime" => "2021-05-20T01:01:01.000Z",
        //             "updatedAtTimestamp" => "1621490985000"
        //         }
        //     )
        //
        $results = $this->parse_positions($response, $symbols);
        return $this->filter_by_array_positions($results, 'symbol', $symbols, false);
    }

    public function parse_position(array $position, ?array $market = null) {
        //
        //     array(
        //         {
        //             "tradingAccountId" => "111000000000001",
        //             "symbol" => "BTC-USDC-PERP",
        //             "side" => "BUY",
        //             "quantity" => "1.00000000",
        //             "notional" => "1.0000",
        //             "entryNotional" => "1.0000",
        //             "mtmPnl" => "1.0000",
        //             "reportedMtmPnl" => "1.0000",
        //             "reportedFundingPnl" => "1.0000",
        //             "realizedPnl" => "1.0000",
        //             "settlementAssetSymbol" => "USDC",
        //             "createdAtDatetime" => "2021-05-20T01:01:01.000Z",
        //             "createdAtTimestamp" => "1621490985000",
        //             "updatedAtDatetime" => "2021-05-20T01:01:01.000Z",
        //             "updatedAtTimestamp" => "1621490985000"
        //         }
        //     )
        //
        $market = $this->safe_market($this->safe_string($position, 'symbol'), $market);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($position, 'createdAtTimestamp');
        $side = $this->safe_string($position, 'side');
        return $this->safe_position(array(
            'info' => $position,
            'id' => null,
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastUpdateTimestamp' => $this->safe_integer($position, 'updatedAtTimestamp'),
            'hedged' => null,
            'side' => $this->parse_position_side($side),
            'contracts' => $this->safe_number($position, 'quantity'),
            'contractSize' => null,
            'entryPrice' => null,
            'markPrice' => null,
            'lastPrice' => null,
            'notional' => $this->safe_number($position, 'notional'),
            'leverage' => null,
            'collateral' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'unrealizedPnl' => null,
            'liquidationPrice' => null,
            'marginMode' => null,
            'marginRatio' => null,
            'percentage' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
        ));
    }

    public function parse_position_side(?string $side) {
        $sides = array(
            'BUY' => 'long',
            'SELL' => 'short',
        );
        return $this->safe_string($sides, $side, $side);
    }

    public function fetch_transfers(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch a history of internal transfers made on an account
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/transfer
         *
         * @param {string} $code unified $currency $code of the $currency transferred
         * @param {int} [$since] the earliest time in ms to fetch transfers for
         * @param {int} [$limit] the maximum number of transfer structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} $params->until the latest time in ms to fetch transfers for (default time $now)
         * @param {string} $params->tradingAccountId the trading account id
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=transfer-structure transfer structures~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $maxLimit = 100;
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchTransfers', 'paginate');
        if ($paginate) {
            $params = $this->handle_pagination_params('fetchTransfers', $since, $params);
            return $this->fetch_paginated_call_dynamic('fetchTransfers', $code, $since, $limit, $params, $maxLimit);
        }
        $request = array(
            'tradingAccountId' => $tradingAccountId,
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['assetSymbol'] = $currency['id'];
        }
        $until = $this->safe_integer($params, 'until');
        if (($since === null) && ($until === null)) {
            // $since and $until are mandatory for this endpoint, set $until to $now if both are null
            $now = $this->milliseconds();
            $params = $this->extend($params, array( 'until' => $now ));
        }
        $params = $this->handle_since_and_until($since, $params);
        if ($limit !== null) {
            $request['_pageSize'] = $this->get_closest_limit($limit);
        }
        $response = $this->privateGetV1HistoryTransfer ($this->extend($request, $params));
        //
        //     array(
        //         {
        //             "requestId" => "1",
        //             "toTradingAccountId" => "111000000000001",
        //             "fromTradingAccountId" => "121000000000001",
        //             "assetSymbol" => "BTC",
        //             "quantity" => "1.00000000",
        //             "status" => "CLOSED",
        //             "statusReasonCode" => "6002",
        //             "statusReason" => "Executed",
        //             "createdAtTimestamp" => "1621490985000",
        //             "createdAtDatetime" => "2021-05-20T01:01:01.000Z"
        //         }
        //     )
        //
        return $this->parse_transfers($response, $currency, $since, $limit);
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): array {
        /**
         * $transfer $currency internally between wallets on the same account
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v1/command-commandType-V1TransferAsset
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to $transfer
         * @param {string} $fromAccount account ID to $transfer from
         * @param {string} $toAccount account ID to $transfer to
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/?id=$transfer-structure $transfer structure~
         */
        array( $this->load_markets(), $this->handle_token() );
        // todo check this method properly
        $currency = $this->currency($code);
        $request = array(
            'commandType' => 'V2TransferAsset',
            'assetSymbol' => $currency['id'],
            'quantity' => $this->currency_to_precision($code, $amount),
            'fromTradingAccountId' => $fromAccount,
            'toTradingAccountId' => $toAccount,
        );
        $response = $this->privatePostV2Command ($this->extend($request, $params));
        //
        //     {
        //         "message" => "Command acknowledged - TransferAsset",
        //         "requestId" => "633909659774222336"
        //     }
        //
        $transferOptions = $this->safe_dict($this->options, 'transfer', array());
        $fillResponseFromRequest = $this->safe_bool($transferOptions, 'fillResponseFromRequest', true);
        $transfer = $this->parse_transfer($response, $currency);
        if ($fillResponseFromRequest) {
            $transfer['fromAccount'] = $fromAccount;
            $transfer['toAccount'] = $toAccount;
            $transfer['amount'] = $amount;
            $transfer['currency'] = $code;
        }
        return $transfer;
    }

    public function parse_transfer($transfer, ?array $currency = null) {
        //
        // fetchTransfers
        //     {
        //         "requestId" => "1",
        //         "toTradingAccountId" => "111000000000001",
        //         "fromTradingAccountId" => "121000000000001",
        //         "assetSymbol" => "BTC",
        //         "quantity" => "1.00000000",
        //         "status" => "CLOSED",
        //         "statusReasonCode" => "6002",
        //         "statusReason" => "Executed",
        //         "createdAtTimestamp" => "1621490985000",
        //         "createdAtDatetime" => "2021-05-20T01:01:01.000Z"
        //     }
        //
        // $transfer
        //     {
        //         "message" => "Command acknowledged - TransferAsset",
        //         "requestId" => "633909659774222336"
        //     }
        //
        $timestamp = $this->safe_integer($transfer, 'createdAtTimestamp');
        $currencyId = $this->safe_string($transfer, 'assetSymbol');
        $status = $this->safe_string($transfer, 'status');
        if ($status === null) {
            $status = $this->safe_string($transfer, 'message');
        }
        return array(
            'id' => $this->safe_string($transfer, 'requestId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $this->safe_number($transfer, 'quantity'),
            'fromAccount' => $this->safe_string($transfer, 'fromTradingAccountId'),
            'toAccount' => $this->safe_string($transfer, 'toTradingAccountId'),
            'status' => $this->parse_transfer_status($status),
            'info' => $transfer,
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'CLOSED' => 'ok',
            'OPEN' => 'pending',
            'REJECTED' => 'failed',
            'Command acknowledged - TransferAsset' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_borrow_rate_history(string $code, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * retrieves a history of a currencies borrow interest rate at specific time slots
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/borrow-interest
         *
         * @param {string} $code unified $currency $code
         * @param {int} [$since] timestamp for the earliest borrow rate
         * @param {int} [$limit] the maximum number of ~@link https://docs.ccxt.com/?id=borrow-rate-structure borrow rate structures~ to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} $params->until the latest time in ms to fetch entries for
         * @param {string} $params->tradingAccountId the trading account id
         * @return {array[]} an array of ~@link https://docs.ccxt.com/?id=borrow-rate-structure borrow rate structures~
         */
        array( $this->load_markets(), $this->handle_token() );
        $tradingAccountId = $this->load_account($params);
        $currency = $this->currency($code);
        $request = array(
            'assetSymbol' => $currency['id'],
            'tradingAccountId' => $tradingAccountId,
        );
        $now = $this->milliseconds();
        $startTimestamp = $since;
        list($request, $params) = $this->handle_until_option('createdAtDatetime[lte]', $request, $params);
        $until = $this->safe_integer($request, 'createdAtDatetime[lte]');
        // current endpoint requires both $since and $until parameters
        if ($startTimestamp === null) {
            $startTimestamp = $now - 1000 * 60 * 60 * 24 * 90; // Only the last 90 days of data is available for querying
        }
        if ($until === null) {
            $until = $now;
        }
        $request['createdAtDatetime[gte]'] = $this->iso8601($startTimestamp);
        $request['createdAtDatetime[lte]'] = $this->iso8601($until);
        $response = $this->privateGetV1HistoryBorrowInterest ($this->extend($request, $params));
        //
        //     array(
        //         {
        //             "assetId" => "1",
        //             "assetSymbol" => "BTC",
        //             "borrowedQuantity" => "1.00000000",
        //             "totalBorrowedQuantity" => "1.00000000",
        //             "createdAtDatetime" => "2020-08-21T08:00:00.000Z",
        //             "createdAtTimestamp" => "1621490985000"
        //         }
        //     )
        //
        return $this->parse_borrow_rate_history($response, $code, $since, $limit);
    }

    public function parse_borrow_rate($info, ?array $currency = null) {
        //
        //     {
        //         "assetId" => "1",
        //         "assetSymbol" => "BTC",
        //         "borrowedQuantity" => "1.00000000",
        //         "totalBorrowedQuantity" => "1.00000000",
        //         "createdAtDatetime" => "2020-08-21T08:00:00.000Z",
        //         "createdAtTimestamp" => "1621490985000"
        //     }
        //
        $timestamp = $this->safe_integer($info, 'createdAtTimestamp');
        $currencyId = $this->safe_string($info, 'assetSymbol');
        return array(
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'rate' => $this->safe_number($info, 'borrowedQuantity'),
            'period' => 86400000,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function get_timestamp() {
        return $this->milliseconds() - $this->options['timeDifference'];
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $request = $this->omit($params, $this->extract_params($path));
        $endpoint = '/' . $this->implode_params($path, $params);
        $url = $this->urls['api'][$api] . $endpoint;
        if ($api === 'private') {
            $this->check_required_credentials();
            $nonce = (string) $this->microseconds();
            $timestamp = (string) $this->get_timestamp();
            if ($method === 'GET') {
                $payload = $timestamp . $nonce . $method . '/trading-api/' . $path;
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'hex');
                $headers = array(
                    'BX-TIMESTAMP' => $timestamp,
                    'BX-NONCE' => $nonce,
                    'BX-SIGNATURE' => $signature,
                );
            } elseif ($method === 'POST') {
                $body = $this->json($params);
                $payload = $timestamp . $nonce . $method . '/trading-api/' . $path . $body;
                $digest = $this->hash($this->encode($payload), 'sha256', 'hex');
                $signature = $this->hmac($this->encode($digest), $this->encode($this->secret), 'sha256', 'hex');
                $headers = array(
                    'BX-TIMESTAMP' => $timestamp,
                    'BX-NONCE' => $nonce,
                    'BX-SIGNATURE' => $signature,
                    'Content-Type' => 'application/json',
                );
                $headers['Content-Type'] = 'application/json';
                $rateLimitToken = $this->safe_string($request, 'rateLimitToken');
                if ($rateLimitToken !== null) {
                    $headers['BX-RATE-LIMIT-TOKEN'] = $rateLimitToken;
                }
            }
            if ($path === 'v1/users/hmac/login') {
                $headers['BX-PUBLIC-KEY'] = $this->apiKey;
            } else {
                $token = $this->token;
                if (($token === null)) {
                    throw new AuthenticationError($this->id . ' requires a $token, please call signIn() first');
                }
                $headers['Authorization'] = 'Bearer ' . $token;
                // $headers['BX-NONCE-WINDOW-ENABLED'] = 'false'; // default is false
            }
        }
        if ($method === 'GET') {
            $query = $this->urlencode($request);
            if (strlen($query)) {
                $url .= '?' . $query;
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function sign_in($params = array ()) {
        /**
         * sign in, must be called prior to using other authenticated methods
         *
         * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--add-authenticated-request-header
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return $response from exchange
         */
        $response = $this->privateGetV1UsersHmacLogin ($params);
        //
        //     {
        //         "authorizer" => "113363EFA2CA00007368524E02000000",
        //         "ownerAuthorizer" => "113363EFA2CA00007368524E02000000",
        //         "token" => "eyJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJiMXgtYXV0aC1zZXJ2aWNlIiwic3ViIjoiNDY0OTc4MzAiLCJleHAiOjE3NDczMzgzNDMsIlNUQUdFIjoiQVVUSEVOVElDQVRFRF9XSVRIX0JMT0NLQ0hBSU4ifQ.5FSyrihzc1wsJqAY8pVX36Y4ZXg3HopLJypPEbHg5bBK8FbL_oLxkj6zM_iOYL2a1x6-ICG0pQjr8hF_k8Yg-w"
        //     }
        //
        $token = $this->safe_string($response, 'token');
        $authorizer = $this->safe_string($response, 'authorizer');
        $this->options['authorizer'] = $authorizer;
        $this->token = $token;
        $this->options['tokenExpires'] = $this->sum($this->milliseconds(), 1000 * 60 * 60 * 24); // $token expires in 24 hours
        return $token;
    }

    public function handle_token($params = array ()) {
        $now = $this->milliseconds();
        $token = $this->token;
        $tokenExpires = $this->safe_integer($this->options, 'tokenExpires');
        if (($token === null) || ($tokenExpires === null) || ($now > $tokenExpires)) {
            return $this->sign_in();
        } else {
            return $this->token;
        }
    }

    public function handle_errors(int $httpCode, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return null; // fallback to default error handler
        }
        //
        //         {
        //             "type" => "HttpInvalidParameterException",
        //             "message" => "HTTP_INVALID_PARAMETER => '100m' is not a valid time bucket"
        //         }
        //
        //         {
        //             "message" => "Order size outside valid range",
        //             "raw" => null,
        //             "errorCode" => 6023,
        //             "errorCodeName" => "ORDER_SIZE_OUTSIDE_VALID_RANGE"
        //         }
        //
        $code = $this->safe_string($response, 'errorCode');
        $type = $this->safe_string($response, 'type');
        if (($code !== null && $code !== '0' && $code !== '1001') || ($type !== null && $type === 'HttpInvalidParameterException')) {
            $message = '';
            $errorCodeName = $this->safe_string($response, 'errorCodeName');
            if ($errorCodeName !== null) {
                $message = $errorCodeName;
            } else {
                $message = $type;
            }
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
        return null;
    }
}
