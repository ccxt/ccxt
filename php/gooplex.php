<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\PermissionDenied;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\InvalidAddress;
use \ccxt\NotSupported;

class gooplex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'gooplex',
            'name' => 'Gooplex',
            'countries' => array( 'BR' ), // US
            'certified' => false,
            'pro' => false,
            'has' => array(
                'cancelAllOrders' => 'emulated',
                'cancelOrder' => true,
                'CORS' => false,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchBidsAsks' => true,
                'fetchClosedOrders' => 'emulated',
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchFundingFees' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrders' => true,
                'fetchOrderBook' => true,
                'fetchStatus' => 'emulated',
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => 'emulated',
                'fetchTradingFees' => 'emulated',
                'fetchTransactions' => false,
                'fetchWithdrawals' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '8h' => '8h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1M',
            ),
            'urls' => array(
                'doc' => 'https://www.gooplex.com.br/apidocs/#api-document-description',
                'fees' => 'https://gooplex.zendesk.com/hc/pt/articles/360049326131-O-que-s%C3%A3o-taxas-de-negocia%C3%A7%C3%A3o-',
                'logo' => 'https://user-images.githubusercontent.com/228850/93481157-a0a2cb00-f8d4-11ea-8608-d56dd916a9ed.jpg',
                'referral' => 'https://www.gooplex.com.br/account/signup?ref=H8QQ57WT',
                'www' => 'https://www.gooplex.com.br',
                // API
                'api' => array(
                    'open' => 'https://www.gooplex.com.br/open/v1',
                    'signed' => 'https://www.gooplex.com.br/open/v1',
                    'api' => 'https://api.binance.com/api',
                    'public' => 'https://api.binance.com/api/v3',
                ),
            ),
            'api' => array(
                'open' => array(               // public
                    'get' => array(
                        'common/time',
                        'common/symbols',
                        'market/depth',
                    ),
                ),
                'signed' => array(             // private
                    'get' => array(
                        'orders',
                        'orders/detail',
                        'orders/trades',
                        'account/spot',
                        'deposits',
                        'deposits/address',
                        'withdraws',
                    ),
                    'post' => array(
                        'orders',
                        'orders/cancel',
                        'withdraws',
                    ),
                ),
                'api' => array(
                    'get' => array(
                        'v3/depth',
                        'v3/trades',
                        'v3/aggTrades',
                    ),
                ),
                'public' => array(
                    'get' => array(
                        'ping',
                        'time',
                        'depth',
                        'trades',
                        'aggTrades',
                        'historicalTrades',
                        'klines',
                        'ticker/24hr',
                        'ticker/price',
                        'ticker/bookTicker',
                        'exchangeInfo',
                    ),
                    'put' => array( 'userDataStream' ),
                    'post' => array( 'userDataStream' ),
                    'delete' => array( 'userDataStream' ),
                ),
            ),
            'orderlimits' => array(
                5,
                10,
                20,
                50,
                100,
                500,
            ),
            'sides' => array(
                'buy' => 0,
                'sell' => 1,
            ),
            'types' => array(
                'limit' => 1,
                'market' => 2,
                'stop_loss' => 3,
                'stop_loss_limit' => 4,
                'take_profit' => 5,
                'take_profit_limit' => 6,
                'limit_maker' => 7,
            ),
            'fees' => array(
                'trading' => array(
                    'taker' => 0.0022, // 0.22% trading fee
                    'maker' => 0.0022, // 0.22% trading fee
                ),
            ),
        ));
    }

    public function sign($path, $api = 'open', $method = 'GET', $params = array (), $headers = null, $body = null) {
        if (!(is_array($this->urls['api']) && array_key_exists($api, $this->urls['api']))) {
            throw new NotSupported($this->id . ' does not have a testnet/sandbox URL for ' . $api . ' endpoints');
        }
        $url = $this->urls['api'][$api];
        $url .= '/' . $path;
        if ($api === 'signed') {
            $this->check_required_credentials();
            $headers = array(
                'X-MBX-APIKEY' => $this->apiKey,
            );
            $recvWindow = $this->safe_integer($this->options, 'recvWindow', 5000);
            $query = null;
            $query = $this->urlencode_with_array_repeat(array_merge(array(
                'timestamp' => $this->nonce(),
                'recvWindow' => $recvWindow,
            ), $params));
            $signature = $this->hmac($this->encode($query), $this->encode($this->secret));
            $query .= '&$signature=' . $signature;
            $url .= '?' . $query;
        } else {
            if ($method === 'GET') {
                if ($params) {
                    $url .= '?' . $this->urlencode($params);
                }
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function get_fees() {
        $feesKey = 'fees';
        $fees = $this->$feesKey;
        return $this->safe_value($fees, 'trading');
    }

    public function symbol_display($originalSymbol) {
        return str_replace('_', '/', $originalSymbol);
    }

    public function symbol_original($displaySymbol) {
        $marketId = $this->market_id($displaySymbol);
        return $marketId;
    }

    public function symbol_binance($displaySymbol) {
        return str_replace('/', '', $displaySymbol);
    }

    public function convert_symbol($market) {
        $trading_fees = $this->get_fees();
        $symbol = $this->safe_string($market, 'symbol');
        $entry = array(
            'id' => $symbol,
            'symbol' => $this->symbol_display($symbol),
            'base' => $this->safe_currency_code($this->safe_value($market, 'baseAsset')),
            'quote' => $this->safe_currency_code($this->safe_value($market, 'quoteAsset')),
            'active' => true,
            'taker' => $this->safe_float($trading_fees, 'taker'),
            'maker' => $this->safe_float($trading_fees, 'maker'),
            'percetage' => true,
            'tierBase' => false,
            'precision' => array(
                'price' => $this->safe_integer($market, 'quotePrecision'),
                'amount' => $this->safe_integer($market, 'basePrecision'),
                'cost' => $this->safe_integer($market, 'basePrecision'),
            ),
            'limits' => array(
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'info' => $market,
        );
        return $entry;
    }

    public function convert_trade($symbol, $trade) {
        $id = $this->safe_string($trade, 'id');
        $timestamp = $this->safe_timestamp($trade, 'time') / 1000;
        $datetime = $this->iso8601($timestamp);
        $fee = null;
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'qty');
        $order = '';
        $type = 'limit';
        $side = 'buy';
        $cost = 0.00;
        $takerOrMaker = null;
        if ($this->safe_value($trade, 'isBuyerMaker')) {
            $takerOrMaker = 'maker';
        } else {
            $takerOrMaker = 'taker';
        }
        $info = array(
            'M' => $trade['isBestMatch'],
            'T' => $trade['time'],
            'a' => $trade['id'],
            'f' => null,
            'l' => null,
            'm' => $trade['isBuyerMaker'],
            'p' => $trade['price'],
            'q' => $trade['qty'],
        );
        $entry = array(
            'info' => $info,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'fee' => $fee,
            'symbol' => $symbol,
            'order' => $order,
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
        );
        return $entry;
    }

    public function fetch_time($params = array ()) {
        $method = 'openGetCommonTime';
        $response = $this->$method ($params);
        return $this->safe_integer($response, 'timestamp');
    }

    public function fetch_status($params = array ()) {
        $status = 'ok';
        $this->status = array_merge($this->status, array(
            'status' => $status,
            'updated' => $this->milliseconds(),
        ));
        return $this->status;
    }

    public function fetch_markets($params = array ()) {
        $method = 'openGetCommonSymbols';
        $response = $this->$method ($params);
        $data = $this->safe_value($response, 'data');
        $markets = $this->safe_value($data, 'list');
        $marketType = 'spot';
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $future = false;
            $delivery = false;
            $tierBased = false;
            $spot = !($future || $delivery);
            $conversion = $this->convert_symbol($market);
            $id = $conversion['id'];
            $lowercaseId = $this->safe_string_lower($conversion, 'id');
            $baseId = $this->safe_string($market, 'baseAsset');
            $quoteId = $this->safe_string($market, 'quoteAsset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $delivery ? $id : ($base . '/' . $quote);
            $precision = array(
                'base' => $this->safe_integer($market, 'basePrecision'),
                'quote' => $this->safe_integer($market, 'quotePrecision'),
                'amount' => $this->safe_integer($market, 'basePrecision'),
                'price' => $this->safe_integer($market, 'quotePrecision'),
            );
            if (is_array($market) && array_key_exists('maintMarginPercent', $market)) {
                $delivery = (is_array($market) && array_key_exists('marginAsset', $market));
                $future = !$delivery;
                $marketType = $delivery ? 'delivery' : 'future';
            }
            $status = $this->safe_string_2($market, 'status', 'contractStatus');
            $active = ($status === 'TRADING');
            $margin = $this->safe_value($market, 'isMarginTradingAllowed', $future || $delivery);
            $entry = array(
                'id' => $id,
                'lowercaseId' => $lowercaseId,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'type' => $marketType,
                'spot' => $spot,
                'margin' => $margin,
                'future' => $future,
                'delivery' => $delivery,
                'active' => $active,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => pow(10, -$precision['amount']),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'market' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'tierBased' => $tierBased,
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('fetchOrderBook requires a $symbol argument');
        }
        $method = 'openGetMarketDepth';
        $request = array(
            'symbol' => $this->symbol_original($symbol),
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        return $this->parse_order_book($response);
    }

    public function convert_order($order) {
        $timestamp = $order['createTime'];
        $side = $order['side'];
        $type = $order['type'];
        return array(
            'info' => $order,
            'id' => $order['orderId'],
            'clientOrderId' => $order['orderId'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $this->symbol_display($order['symbol']),
            'type' => $type,
            'timeInForce' => $order['timeInForce'],
            'postOnly' => '',
            'side' => $side,
            'price' => $order['price'],
            'stopPrice' => $order['stopPrice'],
            'amount' => $order['origQty'],
            'cost' => '',
            'average' => '',
            'filled' => '',
            'remaining' => '',
            'status' => $order['status'],
            'fee' => '',
            'trades' => '',
        );
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('fetchOrders requires a $symbol argument');
        }
        $method = 'signedGetOrders';
        $request = array(
            'symbol' => $this->symbol_original($symbol),
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        $data = $this->safe_value($response, 'data');
        $list = $this->safe_value($data, 'list');
        $result = array();
        for ($i = 0; $i < count($list); $i++) {
            $order = $list[$i];
            $result[] = $this->convert_order($order);
        }
        return $result;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $requestSide = null;
        $requestType = null;
        if ($symbol === null) {
            throw new ArgumentsRequired('createOrder requires a $symbol argument');
        }
        if (is_array($this->sides) && array_key_exists($side, $this->sides)) {
            $requestSide = $this->sides[$side];
        } else {
            throw new NotSupported('Side ' . $side . ' not supported');
        }
        if (is_array($this->types) && array_key_exists($type, $this->types)) {
            $requestType = $this->types[$type];
        } else {
            throw new NotSupported('Type ' . $type . ' not supported.');
        }
        $method = 'signedPostOrders';
        $request = array(
            'symbol' => $this->symbol_original($symbol),
            'side' => $requestSide,
            'type' => $requestType,
            'quantity' => $amount,
        );
        if ($price !== null) {
            $request['price'] = $price;
        }
        $response = $this->$method (array_merge($request, $params));
        $data = $this->safe_value($response, 'data');
        return $this->convert_order($data);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $method = 'signedGetOrdersDetail';
        $request = array(
            'orderId' => $id,
        );
        $response = $this->$method (array_merge($request, $params));
        return $this->convert_order($this->safe_value($response, 'data'));
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchClosedOrders requires a $symbol argument');
        }
        $orders = $this->fetch_orders($symbol, $since, $limit, $params);
        $code = (string) $orders['code'];
        if ($code === '3701') {
            throw new PermissionDenied('fetchClosedOrders Invalid API-key, IP, or permissions for action.');
        }
        return $this->filter_by($orders, 'status', 'closed');
    }

    public function parse_transaction_status_by_type($status, $type = null) {
        $statusesByType = array(
            'deposit' => array(
                '0' => 'pending',
                '1' => 'ok',
            ),
            'withdrawal' => array(
                '0' => 'pending', // Email Sent
                '1' => 'canceled', // Cancelled (different from 1 = ok in deposits)
                '2' => 'pending', // Awaiting Approval
                '3' => 'failed', // Rejected
                '4' => 'pending', // Processing
                '5' => 'failed', // Failure
                '6' => 'ok', // Completed
            ),
        );
        $statuses = $this->safe_value($statusesByType, $type, array());
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        $id = $this->safe_string($transaction, 'id');
        $address = $this->safe_string($transaction, 'address');
        $tag = $this->safe_string($transaction, 'addressTag'); // set but unused
        if ($tag !== null) {
            if (strlen($tag) < 1) {
                $tag = null;
            }
        }
        $txid = $this->safe_string($transaction, 'txId');
        $currencyId = $this->safe_string($transaction, 'asset');
        $code = $this->safe_currency_code($currencyId, $currency);
        $timestamp = null;
        $insertTime = $this->safe_integer($transaction, 'insertTime');
        $applyTime = $this->safe_integer($transaction, 'applyTime');
        $type = $this->safe_string($transaction, 'type');
        if ($type === null) {
            if (($insertTime !== null) && ($applyTime === null)) {
                $type = 'deposit';
                $timestamp = $insertTime;
            } else if (($insertTime === null) && ($applyTime !== null)) {
                $type = 'withdrawal';
                $timestamp = $applyTime;
            }
        }
        $status = $this->parse_transaction_status_by_type($this->safe_string($transaction, 'status'), $type);
        $amount = $this->safe_float($transaction, 'amount');
        $feeCost = $this->safe_float($transaction, 'transactionFee');
        $fee = null;
        $transactions = array(
            'address' => $address,
            'addressTag' => $tag,
            'amount' => $amount,
            'asset' => $currencyId,
            'creator' => $id,
            'insertTime' => $insertTime,
            'status' => $transaction['status'],
            'txId' => $txid,
        );
        if ($feeCost !== null) {
            $fee = array( 'currency' => $code, 'cost' => $feeCost );
        }
        return array(
            'info' => $transactions,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => $address,
            'tag' => $tag,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => null,
            'fee' => $fee,
        );
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'asset' => $currency['id'],
        );
        $response = $this->signedGetDepositsAddress (array_merge($request, $params));
        $success = $this->safe_value($response, 'msg');
        if ($success !== 'Success') {
            throw new InvalidAddress($this->id . ' fetchDepositAddress returned an empty $response â€“ create the deposit $address in the user settings first.');
        }
        $address = $this->safe_string($response['data'], 'address');
        $tag = $this->safe_string($response['data'], 'addressTag');
        $status = intval($response['data']['status']);
        $response_status = false;
        if ($status === 1) {
            $response_status = true;
        } else {
            $response_status = false;
        }
        $info = array(
            'address' => $response['data']['address'],
            'addressTag' => $response['data']['addressTag'],
            'asset' => $response['data']['asset'],
            'success' => $response_status,
            'url' => 'https://blockchair.com/bitcoin/address/' . $address,
        );
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'info' => $info,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $currency = null;
        $request = array();
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['asset'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
            // max 3 months range https://github.com/ccxt/ccxt/issues/6495
            $request['endTime'] = $this->sum($since, 7776000000);
        }
        $response = $this->signedGetDeposits (array_merge($request, $params));
        return $this->parse_transactions($response['data']['list'], $currency, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $currency = null;
        $request = array();
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['asset'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
            // max 3 months range https://github.com/ccxt/ccxt/issues/6495
            $request['endTime'] = $this->sum($since, 7776000000);
        }
        $response = $this->signedGetWithdraws (array_merge($request, $params));
        return $this->parse_transactions($response['data']['list'], $currency, $since, $limit);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        $this->check_address($address);
        $this->load_markets();
        $currency = $this->currency($code);
        // $name is optional, can be overrided via $params
        $name = mb_substr($address, 0, 20 - 0);
        $request = array(
            'asset' => $currency['id'],
            'address' => $address,
            'amount' => floatval($amount),
            'name' => $name, // $name is optional, can be overrided via $params
        );
        if ($tag !== null) {
            $request['addressTag'] = $tag;
        }
        $response = $this->signedPostWithdraws (array_merge($request, $params));
        return array(
            'info' => $response,
            'id' => $this->safe_string($response, 'id'),
        );
    }

    public function parse_trading_fee($fee, $market = null) {
        $marketId = $this->safe_string($fee, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        return array(
            'info' => $fee,
            'symbol' => $symbol,
            'maker' => $this->safe_float($fee, 'maker'),
            'taker' => $this->safe_float($fee, 'taker'),
        );
    }

    public function fetch_trading_fee($symbol, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('fetchTradingFee requires a $symbol argument');
        }
        $fees = $this->get_fees();
        $response = $this->convert_trading_fees($symbol, $fees['maker'], $fees['taker']);
        return $response;
    }

    public function convert_trading_fees($symbol, $maker, $taker) {
        return array(
            'info' => array(
                'maker' => $maker,
                'symbol' => $this->symbol_original($symbol),
                'taker' => $taker,
            ),
            'maker' => $maker,
            'symbol' => $symbol,
            'taker' => $taker,
        );
    }

    public function fetch_trading_fees($params = array ()) {
        $this->load_markets();
        $markets = $this->fetch_markets();
        $fees = $this->get_fees();
        $response = array();
        for ($index = 0; $index < count($markets); $index++) {
            $symbol = $markets[$index]['symbol'];
            $response[$symbol] = ($this->convert_trading_fees($symbol, $fees['maker'], $fees['taker']));
        }
        return $response;
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($id === null) {
            throw new ArgumentsRequired('cancelOrder requires a $id argument');
        }
        $method = 'signedPostOrdersCancel';
        $request = array(
            'orderId' => $id,
        );
        $response = $this->$method (array_merge($request, $params));
        return $response;                        // map
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('cancelAllOrders requires a $symbol argument');
        }
        $orders = $this->fetch_orders($symbol);
        $method = 'signedPostOrdersCancel';
        $response = array();
        for ($index = 0; $index < count($orders); $index++) {
            $order = $orders[$index];
            $request = array(
                'orderId' => $order['id'],
                'timestamp' => $this->nonce(),
            );
            $data = $this->$method (array_merge($request));
            $response[] = $data;
        }
        return $response;
    }

    public function fetch_balance($params = array ()) {
        $method = 'signedGetAccountSpot';
        $response = $this->$method ($params);
        $balance = $response['data']['accountAssets'];
        if ($balance === null) {
            throw new BadRequest('This operation is not supported');
        }
        $data = array();
        $exp_free = array();
        $exp_used = array();
        $exp_total = array();
        $pre_permitidos = array();
        $pre_permitidos[] = 'SPOT';
        $exp_balances = array();
        $timestamp = $response['timestamp'];
        $buyerCommission = floatval($response['data']['buyerCommission']);
        $makerCommission = floatval($response['data']['makerCommission']);
        $takerCommission = floatval($response['data']['takerCommission']);
        $sellerCommission = floatval($response['data']['sellerCommission']);
        $canDeposit = $response['data']['canDeposit'];
        $canTrade = $response['data']['canTrade'];
        $canWithdraw = $response['data']['canWithdraw'];
        $dict_free = array( 'free' => array( ));
        $dict_total = array( 'total' => array( ));
        $dict_used = array( 'used' => array( ));
        for ($i = 0; $i < count($balance); $i++) {
            $ativo = $balance[$i]['asset'];
            $free = floatval($balance[$i]['free']);
            $locked = floatval($balance[$i]['locked']);
            $total = $free . $locked;
            $exp_free[] = [$ativo, $free];
            $dict_free[$ativo] = $free;
            $dict_total[$ativo] = $total;
            $dict_used[$ativo] = $locked;
            $exp_total[] = [$ativo, $total];
            $exp_used[] = [$ativo, $locked];
            $pre_balance = array();
            $pre_balance['asset'] = $ativo;
            $pre_balance['free'] = (string) $free;
            $pre_balance['locked'] = (string) $locked;
            $exp_balances[] = $pre_balance;
            $pre_data_dict = array();
            $pre_data_dict['free'] = $free;
            $pre_data_dict['total'] = $free;
            $pre_data_dict['used'] = $locked;
            $data[$ativo] = $pre_data_dict;
        }
        $info = array(
            'accountType' => 'SPOT',
            'balances' => $exp_balances,
            'permissions' => $pre_permitidos,
            'buyerCommission' => $buyerCommission,
            'canDeposit' => $canDeposit === 1 ? true : false,
            'canTrade' => $canTrade === 1 ? true : false,
            'canWithdraw' => $canWithdraw === 1 ? true : false,
            'makerCommission' => $makerCommission,
            'sellerCommission' => $sellerCommission,
            'takerCommission' => $takerCommission,
            'updateTime' => $timestamp,
        );
        $data['free'] = $dict_free;
        $data['info'] = $info;
        $data['total'] = $dict_total;
        $data['used'] = $dict_used;
        return $data;
    }

    public function fetch_bids_asks($symbols = null, $params = array ()) {
        $this->load_markets();
        $query = $this->omit($params, 'type');
        $method = 'publicGetTickerBookTicker';
        $response = $this->$method ($query);
        return $this->parse_tickers($response, $symbols);
    }

    public function parse_ticker($ticker, $market = null) {
        $timestamp = $this->safe_integer($ticker, 'closeTime');
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_float($ticker, 'lastPrice');
        return array(
            'symbol' => $this->symbol_display($symbol),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_float($ticker, 'highPrice'),
            'low' => $this->safe_float($ticker, 'lowPrice'),
            'bid' => $this->safe_float($ticker, 'bidPrice'),
            'bidVolume' => $this->safe_float($ticker, 'bidQty'),
            'ask' => $this->safe_float($ticker, 'askPrice'),
            'askVolume' => $this->safe_float($ticker, 'askQty'),
            'vwap' => $this->safe_float($ticker, 'weightedAvgPrice'),
            'open' => $this->safe_float($ticker, 'openPrice'),
            'close' => $last,
            'last' => $last,
            'previousClose' => $this->safe_float($ticker, 'prevClosePrice'), // previous day close
            'change' => $this->safe_float($ticker, 'priceChange'),
            'percentage' => $this->safe_float($ticker, 'priceChangePercent'),
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'volume'),
            'quoteVolume' => $this->safe_float($ticker, 'quoteVolume'),
            'info' => $ticker,
        );
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $this->symbol_binance($symbol),
        );
        $method = 'publicGetTicker24hr';
        $response = $this->$method (array_merge($request, $params));
        if (gettype($response) === 'array' && count(array_filter(array_keys($response), 'is_string')) == 0) {
            $firstTicker = $this->safe_value($response, 0, array());
            return $this->parse_ticker($firstTicker, $market);
        }
        return $this->parse_ticker($response, $market);
    }

    public function parse_tickers($rawTickers, $symbols = null) {
        $tickers = array();
        for ($i = 0; $i < count($rawTickers); $i++) {
            $tickers[] = $this->parse_ticker($rawTickers[$i]);
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $query = $this->omit($params, 'type');
        $defaultMethod = 'publicGetTicker24hr';
        $method = $this->safe_string($this->options, 'fetchTickersMethod', $defaultMethod);
        $response = $this->$method ($query);
        return $this->parse_tickers($response, $symbols);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_float($ohlcv, 1),
            $this->safe_float($ohlcv, 2),
            $this->safe_float($ohlcv, 3),
            $this->safe_float($ohlcv, 4),
            $this->safe_float($ohlcv, 5),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $this->symbol_binance($symbol),
            'interval' => $this->timeframes[$timeframe],
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default == max == 500
        }
        $method = 'publicGetKlines';
        $response = $this->$method (array_merge($request, $params));
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders requires a $symbol argument');
        }
        $orders = $this->fetch_orders($symbol, $since, $limit, $params);
        $code = (string) $orders['code'];
        if ($code === '3701') {
            throw new PermissionDenied('fetchOpenOrders Invalid API-key, IP, or permissions for action.');
        }
        return $this->filter_by($orders, 'status', 'open');
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $method = 'apiGetV3Trades';
        $request = array(
            'symbol' => $this->symbol_binance($symbol),
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $result[] = $this->convert_trade($symbol, $response[$i]);
        }
        return $result;
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('fetchOrders requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $method = 'signedGetOrdersTrades';
        $request = array(
            'symbol' => $this->symbol_original($symbol),
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        $response = $response['data']['list'];
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_l2($entry) {
        $timestamp = $this->safe_timestamp($entry, 'T');
        $datetime = $this->iso8601($timestamp / 1000);
        return array(
            'tradeId' => $this->safe_integer($entry, 'a'),
            'price' => $this->safe_float($entry, 'p'),
            'quantity' => $this->safe_float($entry, 'q'),
            'firstTradeId' => $this->safe_integer($entry, 'f'),
            'lastTradeId' => $this->safe_integer($entry, 'l'),
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'maker' => $this->safe_value($entry, 'm'),
            'bestPriceMatch' => $this->safe_value($entry, 'M'),
        );
    }

    public function fetch_agg_trades($symbol, $limit = null, $params = array ()) {
        $method = 'apiGetV3AggTrades';
        $request = array(
            'symbol' => $this->symbol_binance($symbol),
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $result[] = $this->parse_l2($response[$i]);
        }
        return $result;
    }
}
