<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\abstract\deepcoin as Exchange;

class deepcoin extends Exchange {

    public function describe(): mixed {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'deepcoin',
            'name' => 'DeepCoin',
            'countries' => array( 'SG' ), // Singapore
            'rateLimit' => 200, // 5 times per second
            'version' => 'v1',
            'certified' => false,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelAllOrdersAfter' => false,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'cancelWithdraw' => false,
                'closePosition' => true,
                'createConvertTrade' => false,
                'createDepositAddress' => false,
                'createLimitBuyOrder' => true,
                'createLimitOrder' => true,
                'createLimitSellOrder' => true,
                'createMarketBuyOrder' => true,
                'createMarketBuyOrderWithCost' => true,
                'createMarketOrder' => true,
                'createMarketOrderWithCost' => true,
                'createMarketSellOrder' => true,
                'createMarketSellOrderWithCost' => true,
                'createOrder' => true,
                'createOrders' => false,
                'createOrderWithTakeProfitAndStopLoss' => true,
                'createPostOnlyOrder' => true,
                'createReduceOnlyOrder' => true,
                'createStopLossOrder' => false,
                'createTakeProfitOrder' => false,
                'createTrailingAmountOrder' => false,
                'createTrailingPercentOrder' => false,
                'createTriggerOrder' => true,
                'editOrder' => true,
                'fetchAccounts' => false,
                'fetchBalance' => true,
                'fetchCanceledAndClosedOrders' => true,
                'fetchCanceledOrders' => true,
                'fetchClosedOrder' => true,
                'fetchClosedOrders' => true,
                'fetchConvertCurrencies' => false,
                'fetchConvertQuote' => false,
                'fetchConvertTrade' => false,
                'fetchConvertTradeHistory' => false,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => true,
                'fetchDeposits' => true,
                'fetchDepositsWithdrawals' => false,
                'fetchDepositWithdrawFees' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => true,
                'fetchLedger' => true,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarginAdjustmentHistory' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => false,
                'fetchOpenInterestHistory' => false,
                'fetchOpenOrder' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => false,
                'fetchOrderBook' => true,
                'fetchOrders' => false,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositionHistory' => false,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPositionsForSymbol' => true,
                'fetchPositionsHistory' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchStatus' => false,
                'fetchTicker' => false,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTransactions' => false,
                'fetchTransfers' => false,
                'fetchWithdrawals' => true,
                'reduceMargin' => false,
                'sandbox' => false,
                'setLeverage' => true,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'transfer' => true,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1H',
                '4h' => '4H',
                '12h' => '12H',
                '1d' => '1D',
                '1w' => '1W',
                '1M' => '1M',
                '1y' => '1Y',
            ),
            'urls' => array(
                'logo' => 'https://github.com/user-attachments/assets/ddf3e178-c3b6-409d-8f9f-af8b7cf80454',
                'api' => array(
                    'public' => 'https://api.deepcoin.com',
                    'private' => 'https://api.deepcoin.com',
                ),
                'www' => 'https://www.deepcoin.com/',
                'doc' => 'https://www.deepcoin.com/docs',
                'referral' => array(
                    'url' => 'https://s.deepcoin.com/UzkyODgy',
                    'discount' => 0.1,
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'deepcoin/market/books' => 1,
                        'deepcoin/market/candles' => 1,
                        'deepcoin/market/instruments' => 1,
                        'deepcoin/market/tickers' => 1,
                        'deepcoin/market/index-candles' => 1,
                        'deepcoin/market/trades' => 1,
                        'deepcoin/market/mark-price-candles' => 1,
                        'deepcoin/market/step-margin' => 5,
                        'deepcoin/trade/funding-rate' => 5,
                        'deepcoin/trade/fund-rate/current-funding-rate' => 5,
                        'deepcoin/trade/fund-rate/history' => 5,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'deepcoin/account/balances' => 5,
                        'deepcoin/account/bills' => 5,
                        'deepcoin/account/positions' => 5,
                        'deepcoin/trade/fills' => 5,
                        'deepcoin/trade/orderByID' => 5,
                        'deepcoin/trade/finishOrderByID' => 5,
                        'deepcoin/trade/orders-history' => 5,
                        'deepcoin/trade/v2/orders-pending' => 5,
                        'deepcoin/trade/trigger-orders-pending' => 5,
                        'deepcoin/trade/trigger-orders-history' => 5,
                        'deepcoin/copytrading/support-contracts' => 5,
                        'deepcoin/copytrading/leader-position' => 5,
                        'deepcoin/copytrading/estimate-profit' => 5,
                        'deepcoin/copytrading/history-profit' => 5,
                        'deepcoin/copytrading/follower-rank' => 5,
                        'deepcoin/internal-transfer/support' => 5,
                        'deepcoin/internal-transfer/history-order' => 5,
                        'deepcoin/rebate/config' => 5,
                        'deepcoin/agents/users' => 5,
                        'deepcoin/agents/users/rebate-list' => 5,
                        'deepcoin/agents/users/rebates' => 5,
                        'deepcoin/asset/deposit-list' => 5,
                        'deepcoin/asset/withdraw-list' => 5,
                        'deepcoin/asset/recharge-chain-list' => 5,
                        'deepcoin/listenkey/acquire' => 5,
                        'deepcoin/listenkey/extend' => 5,
                    ),
                    'post' => array(
                        'deepcoin/account/set-leverage' => 5,
                        'deepcoin/trade/order' => 5,
                        'deepcoin/trade/replace-order' => 5,
                        'deepcoin/trade/cancel-order' => 5,
                        'deepcoin/trade/batch-cancel-order' => 5,
                        'deepcoin/trade/cancel-trigger-order' => 1 / 6,
                        'deepcoin/trade/swap/cancel-all' => 5,
                        'deepcoin/trade/trigger-order' => 5,
                        'deepcoin/trade/batch-close-position' => 5,
                        'deepcoin/trade/replace-order-sltp' => 5,
                        'deepcoin/trade/close-position-by-ids' => 5,
                        'deepcoin/copytrading/leader-settings' => 5,
                        'deepcoin/copytrading/set-contracts' => 5,
                        'deepcoin/internal-transfer' => 5,
                        'deepcoin/rebate/config' => 5,
                        'deepcoin/asset/transfer' => 5,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'taker' => $this->parse_number('0.0015'),
                    'maker' => $this->parse_number('0.0010'),
                ),
            ),
            'features' => array(
                'spot' => array(
                    'sandbox' => false,
                    'createOrder' => array(
                        'marginMode' => true,
                        'triggerPrice' => true,
                        'triggerPriceType' => array(
                            'last' => true,
                            'mark' => false,
                            'index' => false,
                        ),
                        'triggerDirection' => false,
                        'stopLossPrice' => true,
                        'takeProfitPrice' => true,
                        'attachedStopLossTakeProfit' => array(
                            'triggerPriceType' => array(
                                'last' => false,
                                'mark' => false,
                                'index' => false,
                            ),
                            'price' => true,
                        ),
                        'timeInForce' => array(
                            'IOC' => true,
                            'FOK' => true,
                            'PO' => true,
                            'GTD' => false,
                        ),
                        'hedged' => true,
                        'trailing' => false,
                        'marketBuyRequiresPrice' => false,
                    ),
                    'createOrders' => null,
                    'fetchMyTrades' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => 60,
                        'untilDays' => null,
                        'symbolRequired' => true,
                    ),
                    'fetchOrder' => null,
                    'fetchOpenOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'trigger' => true,
                        'trailing' => false,
                        'symbolRequired' => true,
                    ),
                    'fetchOrders' => null,
                    'fetchClosedOrders' => array(
                        'marginMode' => false,
                        'limit' => 100,
                        'daysBack' => null,
                        'daysBackCanceled' => null,
                        'untilDays' => null,
                        'trigger' => true,
                        'trailing' => false,
                        'symbolRequired' => true,
                    ),
                    'fetchOHLCV' => array(
                        'limit' => 300,
                    ),
                ),
                'swap' => array(
                    'linear' => array(
                        'extends' => 'spot',
                    ),
                    'inverse' => array(
                        'extends' => 'spot',
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'password' => true,
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'recvWindow' => 5000,
                'defaultNetworks' => array(
                    'ETH' => 'ERC20',
                    'USDT' => 'TRC20',
                    'USDC' => 'ERC20',
                ),
                'networks' => array(
                    'ERC20' => 'ERC20',
                    'TRC20' => 'TRC20',
                    'ARB' => 'ARBITRUM',
                    'BSC' => 'BSC(BEP20)',
                    'SOL' => 'SOL',
                    'BTC' => 'Bitcoin',
                    'ADA' => 'Cardano',
                ),
                'networksById' => array(
                ),
                'fetchMarkets' => array(
                    'types' => array( 'spot', 'swap' ), // spot, swap,
                ),
                'timeInForce' => array(
                    'GTC' => 'GTC', // Good Till Cancel
                    'IOC' => 'IOC', // Immediate Or Cancel
                    'PO' => 'PO',   // Post Only
                ),
                'exchangeType' => array(
                    'spot' => 'SPOT',
                    'swap' => 'SWAP',
                    'SPOT' => 'SPOT',
                    'SWAP' => 'SWAP',
                ),
                'accountsByType' => array(
                    'spot' => 1,
                    'fund' => 2,
                    'rebate' => 3,
                    'inverse' => 5,
                    'linear' => 7,
                    'demo' => 10,
                ),
            ),
            'commonCurrencies' => array(),
            'exceptions' => array(
                'exact' => array(
                    '24' => '\\ccxt\\OrderNotFound', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","sCode":"24","sMsg":"OrderNotFound:1"))
                    '31' => '\\ccxt\\InsufficientFunds', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","tag":"","sCode":"31","sMsg":"NotEnoughPositionToClose:Position=0"))
                    '36' => '\\ccxt\\InsufficientFunds', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","tag":"","sCode":"36","sMsg":"InsufficientMoney:-0.000004"))
                    '44' => '\\ccxt\\BadRequest', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","tag":"","sCode":"44","sMsg":"VolumeNotOnTick"))
                    '49' => '\\ccxt\\InvalidOrder', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","tag":"","sCode":"49","sMsg":"PriceOutOfUpperLimit:Price\u003eUpperLimitPrice[0.28422]"))
                    '194' => '\\ccxt\\InvalidOrder', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","tag":"","sCode":"194","sMsg":"LessThanMinVolume"))
                    '195' => '\\ccxt\\InvalidOrder', // array("code":"0","msg":"","data":array("ordId":"","clOrdId":"","tag":"","sCode":"195","sMsg":"PositionLessThanMinVolume"))
                    '199' => '\\ccxt\\BadRequest', // array("code":"0","msg":"","data":array("instId":"","lever":"","mgnMode":"","mrgPosition":"","sCode":"199","sMsg":"LeverageTooHigh:Amount[10000.0]\u003eLeverage[75.1880]"))
                    '100010' => '\\ccxt\\InsufficientFunds', // array("code":"0","msg":"","data":array("retCode":100010,"retMsg":"Balance is insufficient, please deposit first.","retData":array()))
                    'unsupportedAction' => '\\ccxt\\BadRequest',
                    'localIDNotExist' => '\\ccxt\\BadRequest',
                ),
                'broad' => array(
                    'no available' => '\\ccxt\\NotSupported', // orderbook does not exist => ETHUSD_0.1, no available orderbook data
                    'field is required' => '\\ccxt\\ArgumentsRequired', // array("code":"51","msg":"The productGroup field is required","data":null)
                    'not in acceptable range' => '\\ccxt\\BadRequest', // array("code":"51","msg":"The instType value `spot` is not in acceptable range => SPOT,SWAP","data":null)
                    'subscription cluster does not "exist"' => '\\ccxt\\BadRequest',
                    'must be equal or lesser than' => '\\ccxt\\BadRequest', // array("code":"51","msg":"The Size value `100` must be equal or lesser than 50","data":null)
                ),
            ),
        ));
    }

    public function handle_market_type_and_params(string $methodName, ?array $market = null, $params = array (), $defaultValue = null): mixed {
        $instType = $this->safe_string($params, 'instType');
        $params = $this->omit($params, 'instType');
        $type = $this->safe_string($params, 'type');
        if (($type === null) && ($instType !== null)) {
            $params = $this->extend($params, array( 'type' => $instType ));
        }
        return parent::handle_market_type_and_params($methodName, $market, $params, $defaultValue);
    }

    public function convert_to_instrument_type($type) {
        $exchangeTypes = $this->safe_dict($this->options, 'exchangeType', array());
        return $this->safe_string($exchangeTypes, $type, $type);
    }

    public function fetch_markets($params = array ()): array {
        /**
         *
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/getBaseInfo
         *
         * retrieves data on all markets for okcoin
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} an array of objects representing market data
         */
        $types = array( 'spot', 'swap' );
        $fetchMarketsOption = $this->safe_dict($this->options, 'fetchMarkets');
        if ($fetchMarketsOption !== null) {
            $types = $this->safe_list($fetchMarketsOption, 'types', $types);
        } else {
            $types = $this->safe_list($this->options, 'fetchMarkets', $types); // backward-support
        }
        $promises = array();
        $result = array();
        for ($i = 0; $i < count($types); $i++) {
            $promises[] = $this->fetch_markets_by_type($types[$i], $params);
        }
        $promises = $promises;
        for ($i = 0; $i < count($promises); $i++) {
            $result = $this->array_concat($result, $promises[$i]);
        }
        return $result;
    }

    public function fetch_markets_by_type($type, $params = array ()) {
        $request = array(
            'instType' => $this->convert_to_instrument_type($type),
        );
        $response = $this->publicGetDeepcoinMarketInstruments ($this->extend($request, $params));
        //
        // spot
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "instType" => "SPOT",
        //                 "instId" => "A-USDT",
        //                 "uly" => "",
        //                 "baseCcy" => "A",
        //                 "quoteCcy" => "USDT",
        //                 "ctVal" => "1",
        //                 "ctValCcy" => "",
        //                 "listTime" => "0",
        //                 "lever" => "1",
        //                 "tickSz" => "0.0001",
        //                 "lotSz" => "0.001",
        //                 "minSz" => "0.5",
        //                 "ctType" => "",
        //                 "alias" => "",
        //                 "state" => "live",
        //                 "maxLmtSz" => "7692307",
        //                 "maxMktSz" => "7692307"
        //             }
        //         )
        //     }
        //
        $dataResponse = $this->safe_list($response, 'data', array());
        return $this->parse_markets($dataResponse);
    }

    public function parse_market(array $market): array {
        //
        // $spot markets
        //
        //     {
        //         "instType" => "SPOT",
        //         "instId" => "A-USDT",
        //         "uly" => "",
        //         "baseCcy" => "A",
        //         "quoteCcy" => "USDT",
        //         "ctVal" => "1",
        //         "ctValCcy" => "",
        //         "listTime" => "0",
        //         "lever" => "1",
        //         "tickSz" => "0.0001",
        //         "lotSz" => "0.001",
        //         "minSz" => "0.5",
        //         "ctType" => "",
        //         "alias" => "",
        //         "state" => "live",
        //         "maxLmtSz" => "7692307",
        //         "maxMktSz" => "7692307"
        //     }
        //
        // $swap markets
        //
        //     {
        //         "instType" => "SWAP",
        //         "instId" => "ZORA-USDT-SWAP",
        //         "uly" => "",
        //         "baseCcy" => "ZORA",
        //         "quoteCcy" => "USDT",
        //         "ctVal" => "1",
        //         "ctValCcy" => "",
        //         "listTime" => "0",
        //         "lever" => "20",
        //         "tickSz" => "0.00001",
        //         "lotSz" => "1",
        //         "minSz" => "1685",
        //         "ctType" => "",
        //         "alias" => "",
        //         "state" => "live",
        //         "maxLmtSz" => "10000000",
        //         "maxMktSz" => "10000000"
        //     }
        //
        $id = $this->safe_string($market, 'instId');
        $type = $this->safe_string_lower($market, 'instType');
        $spot = ($type === 'spot');
        $swap = ($type === 'swap');
        $baseId = $this->safe_string($market, 'baseCcy');
        $quoteId = $this->safe_string($market, 'quoteCcy', '');
        $settleId = null;
        $settle = null;
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $symbol = $base . '/' . $quote;
        $isLinear = null;
        if ($swap) {
            $isLinear = ($quoteId !== 'USD');
            $settleId = $isLinear ? $quoteId : $baseId;
            $settle = $this->safe_currency_code($settleId);
            $symbol = $symbol . ':' . $settle;
        }
        $fees = $this->safe_dict_2($this->fees, $type, 'trading', array());
        $maxLeverage = $this->safe_string($market, 'lever', '1');
        $maxLeverage = Precise::string_max($maxLeverage, '1');
        $maxMarketSize = $this->safe_string($market, 'maxMktSz');
        $maxLimitSize = $this->safe_string($market, 'maxLmtSz');
        $maxAmount = $this->parse_number(Precise::string_max($maxMarketSize, $maxLimitSize));
        $state = $this->safe_string($market, 'state');
        return $this->extend($fees, array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settleId,
            'type' => $type,
            'spot' => $spot,
            'margin' => $spot && (Precise::string_gt($maxLeverage, '1')),
            'swap' => $swap,
            'future' => false,
            'option' => false,
            'active' => $state === 'live',
            'contract' => $swap,
            'linear' => $isLinear,
            'inverse' => $swap ? (!$isLinear) : null,
            'contractSize' => $swap ? $this->safe_number($market, 'ctVal') : null,
            'expiry' => null,
            'expiryDatetime' => null,
            'strike' => null,
            'optionType' => null,
            'created' => null,
            'precision' => array(
                'amount' => $this->safe_number($market, 'lotSz'),
                'price' => $this->safe_number($market, 'tickSz'),
            ),
            'limits' => array(
                'leverage' => array(
                    'min' => $this->parse_number('1'),
                    'max' => $this->parse_number($maxLeverage),
                ),
                'amount' => array(
                    'min' => $this->safe_number($market, 'minSz'),
                    'max' => $maxAmount,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'info' => $market,
        ));
    }

    public function set_markets($markets, $currencies = null) {
        $markets = parent::set_markets($markets, $currencies);
        $symbols = is_array($markets) ? array_keys($markets) : array();
        for ($i = 0; $i < count($symbols); $i++) {
            $symbol = $symbols[$i];
            $market = $markets[$symbol];
            if ($market['swap']) {
                $additionalId = $market['baseId'] . $market['quoteId'];
                $this->markets_by_id[$additionalId] = array( $market ); // some endpoints return swap $market id+quote
            }
        }
        return $this->markets;
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other $data
         *
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/marketBooks
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int} [$limit] the maximum amount of order book entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} A dictionary of ~@link https://docs.ccxt.com/?id=order-book-structure order book structures~ indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if ($limit === null) {
            $limit = 400;
        }
        $request = array(
            'instId' => $market['id'],
            'sz' => $limit,
        );
        $response = $this->publicGetDeepcoinMarketBooks ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => {
        //             "bids" => [
        //                 ["3732.21", "99.6"],
        //                 ["3732.2", "54.7"]
        //             ],
        //             "asks" => [
        //                 ["3732.22", "85.1"],
        //                 ["3732.23", "49.4"]
        //             ]
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_order_book($data, $symbol, null, 'bids', 'asks', 0, 1);
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches historical candlestick $data containing the open, high, low, and close $price, and the volume of a $market
         *
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/getKlineData
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/getIndexKlineData
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/getMarkKlineData
         *
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV $data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int} [$since] timestamp in ms of the earliest candle to fetch
         * @param {int} [$limit] the maximum amount of candles to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest candle to fetch
         * @param {string} [$params->price] "mark" or "index" for mark $price and index $price candles
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {int[][]} A list of candles ordered, open, high, low, close, volume
         */
        $this->load_markets();
        $maxLimit = 300;
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchOHLCV', 'paginate', false);
        if ($paginate) {
            $params = $this->extend($params, array( 'calculateUntil' => true ));
            return $this->fetch_paginated_call_deterministic('fetchOHLCV', $symbol, $since, $limit, $timeframe, $params, $maxLimit);
        }
        $market = $this->market($symbol);
        $price = $this->safe_string($params, 'price');
        $params = $this->omit($params, 'price');
        $bar = $this->safe_string($this->timeframes, $timeframe, $timeframe);
        $request = array(
            'instId' => $market['id'],
            'bar' => $bar,
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $request['after'] = $until;
            $params = $this->omit($params, 'until');
        }
        $calculateUntil = $this->safe_bool($params, 'calculateUntil', false);
        if ($calculateUntil) {
            $params = $this->omit($params, 'calculateUntil');
            if ($since !== null) {
                // the exchange do not have a $since param for this endpoint
                // we canlculate $until (after) for correct pagination
                $duration = $this->parse_timeframe($timeframe);
                $numberOfCandles = ($limit === null) ? $maxLimit : $limit;
                $endTime = $since . ($duration * $numberOfCandles) * 1000;
                if ($until !== null) {
                    $endTime = min ($endTime, $until);
                }
                $now = $this->milliseconds();
                $request['after'] = min ($endTime, $now);
            }
        }
        $response = null;
        if ($price === 'mark') {
            $response = $this->publicGetDeepcoinMarketMarkPriceCandles ($this->extend($request, $params));
        } elseif ($price === 'index') {
            $response = $this->publicGetDeepcoinMarketIndexCandles ($this->extend($request, $params));
        } else {
            $response = $this->publicGetDeepcoinMarketCandles ($this->extend($request, $params));
        }
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data":array(
        //             array(
        //                 "1760221800000",
        //                 "3739.08",
        //                 "3741.95",
        //                 "3737.75",
        //                 "3740.1",
        //                 "2849",
        //                 "1065583.744"
        //             ),
        //             array(
        //                 "1760221740000",
        //                 "3742.36",
        //                 "3743.01",
        //                 "3736.83",
        //                 "3739.08",
        //                 "2723",
        //                 "1018290.723"
        //             )
        //         )
        //     }
        //
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): array {
        /**
         * fetches price $tickers for multiple markets, statistical information calculated over the past 24 hours for each $market
         *
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/getMarketTickers
         *
         * @param {string[]} [$symbols] unified $symbols of the markets to fetch the ticker for, all $market $tickers are returned if not assigned
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a dictionary of ~@link https://docs.ccxt.com/?id=ticker-structure ticker structures~
         */
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $market = $this->get_market_from_symbols($symbols);
        $marketType = null;
        list($marketType, $params) = $this->handle_market_type_and_params('fetchTickers', $market, $params);
        $request = array(
            'instType' => $this->convert_to_instrument_type($marketType),
        );
        $response = $this->publicGetDeepcoinMarketTickers ($this->extend($request, $params));
        $tickers = $this->safe_list($response, 'data', array());
        return $this->parse_tickers($tickers, $symbols);
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        //
        //     {
        //         "instType" => "SWAP",
        //         "instId" => "BTC-USD-SWAP",
        //         "last" => "114113.3",
        //         "lastSz" => "",
        //         "askPx" => "114113.5",
        //         "askSz" => "56280",
        //         "bidPx" => "114113.2",
        //         "bidSz" => "63220",
        //         "open24h" => "113214.7",
        //         "high24h" => "116039.2",
        //         "low24h" => "113214.7",
        //         "volCcy24h" => "73.31475724",
        //         "vol24h" => "8406739",
        //         "sodUtc0" => "",
        //         "sodUtc8" => "",
        //         "ts" => "1760367816000"
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'ts');
        $marketId = $this->safe_string($ticker, 'instId');
        $market = $this->safe_market($marketId, $market, '-');
        $symbol = $market['symbol'];
        $last = $this->safe_string($ticker, 'last');
        $open = $this->safe_string($ticker, 'open24h');
        $quoteVolume = $this->safe_string($ticker, 'volCcy24h');
        $baseVolume = $this->safe_string($ticker, 'vol24h');
        if ($market['swap'] && $market['inverse']) {
            $temp = $baseVolume;
            $baseVolume = $quoteVolume;
            $quoteVolume = $temp;
        }
        $high = $this->safe_string($ticker, 'high24h');
        $low = $this->safe_string($ticker, 'low24h');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $this->safe_string($ticker, 'bidPx'),
            'bidVolume' => $this->safe_string($ticker, 'bidSz'),
            'ask' => $this->safe_string($ticker, 'askPx'),
            'askVolume' => $this->safe_string($ticker, 'askSz'),
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'markPrice' => null,
            'indexPrice' => null,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * get the list of most recent trades for a particular $symbol
         *
         * @see https://www.deepcoin.com/docs/DeepCoinMarket/getTrades
         *
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int} [$since] timestamp in ms of the earliest trade to fetch
         * @param {int} [$limit] the maximum amount of trades to fetch (default 100, max 500)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/?id=public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 500
        }
        $productGroup = $this->get_product_group_from_market($market);
        $request['productGroup'] = $productGroup;
        $response = $this->publicGetDeepcoinMarketTrades ($this->extend($request, $params));
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function get_product_group_from_market(array $market): string {
        $productGroup = 'Spot';
        if ($market['swap']) {
            if ($market['linear']) {
                $productGroup = 'SwapU';
            } else {
                $productGroup = 'Swap';
            }
        }
        return $productGroup;
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        //
        // public fetchTrades
        //
        //     {
        //         "instId" => "ETH-USDT",
        //         "tradeId" => "1001056388761321",
        //         "px" => "4095.66",
        //         "sz" => "0.01311251",
        //         "side" => "sell",
        //         "ts" => "1760367870000"
        //     }
        //
        // private fetchMyTrades
        //     {
        //         "instType" => "SPOT",
        //         "instId" => "ETH-USDT",
        //         "tradeId" => "1001056429613610",
        //         "ordId" => "1001435238208686",
        //         "clOrdId" => "",
        //         "billId" => "10010564296136101",
        //         "tag" => "",
        //         "fillPx" => "3791.15",
        //         "fillSz" => "0.004",
        //         "side" => "sell",
        //         "posSide" => "",
        //         "execType" => "",
        //         "feeCcy" => "USDT",
        //         "fee" => "0.0151646",
        //         "ts" => "1760704540000"
        //     }
        //
        $marketId = $this->safe_string($trade, 'instId');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($trade, 'ts');
        $side = $this->safe_string($trade, 'side');
        $execType = $this->safe_string($trade, 'execType');
        $fee = null;
        $feeCost = $this->safe_string($trade, 'fee');
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'feeCcy');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'id' => $this->safe_string($trade, 'tradeId'),
            'order' => $this->safe_string($trade, 'ordId'),
            'type' => null,
            'takerOrMaker' => $this->parse_taker_or_maker($execType),
            'side' => $side,
            'price' => $this->safe_string_2($trade, 'fillPx', 'px'),
            'amount' => $this->safe_string_2($trade, 'fillSz', 'sz'),
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function parse_taker_or_maker(?string $execType) {
        $types = array(
            'T' => 'taker',
            'M' => 'maker',
        );
        return $this->safe_string($types, $execType, $execType);
    }

    public function fetch_balance($params = array ()): array {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         *
         * @see https://www.deepcoin.com/docs/DeepCoinAccount/getAccountBalance
         *
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->type] "spot" or "swap", the market type for the balance
         * @return {array} a ~@link https://docs.ccxt.com/?id=balance-structure balance structure~
         */
        $this->load_markets();
        $marketType = 'spot';
        list($marketType, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params, $marketType);
        $request = array(
            'instType' => $this->convert_to_instrument_type($marketType),
        );
        $response = $this->privateGetDeepcoinAccountBalances ($this->extend($request, $params));
        return $this->parse_balance($response);
    }

    public function parse_balance($response): array {
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "ccy" => "USDT",
        //                 "bal" => "74",
        //                 "frozenBal" => "0",
        //                 "availBal" => "74"
        //             }
        //         )
        //     }
        //
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        $balances = $this->safe_list($response, 'data', array());
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $symbol = $this->safe_string($balance, 'ccy');
            $code = $this->safe_currency_code($symbol);
            $account = $this->account();
            $account['total'] = $this->safe_string($balance, 'bal');
            $account['used'] = $this->safe_string($balance, 'frozenBal');
            $account['free'] = $this->safe_string($balance, 'availBal');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_deposits(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all deposits made to an account
         *
         * @see https://www.deepcoin.com/docs/assets/deposit
         *
         * @param {string} $code unified $currency $code
         * @param {int} [$since] the earliest time in ms to fetch deposits for
         * @param {int} [$limit] the maximum number of deposits structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch entries for
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=transaction-structure transaction structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchDeposits', 'paginate', false);
        if ($paginate) {
            return $this->fetch_paginated_call_cursor('fetchDeposits', $code, $since, $limit, $params, 'code', null, 1, 50);
        }
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $request['endTime'] = $until;
            $params = $this->omit($params, 'until');
        }
        $response = $this->privateGetDeepcoinAssetDepositList ($this->extend($request, $params));
        $data = $this->safe_dict($response, 'data', array());
        $items = $this->safe_list($data, 'data', array());
        $transactionParams = array(
            'type' => 'deposit',
        );
        return $this->parse_transactions($items, $currency, $since, $limit, $transactionParams);
    }

    public function fetch_withdrawals(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all withdrawals made from an account
         *
         * @see https://www.deepcoin.com/docs/assets/withdraw
         *
         * @param {string} $code unified $currency $code of the $currency transferred
         * @param {int} [$since] the earliest time in ms to fetch transfers for (default 24 hours ago)
         * @param {int} [$limit] the maximum number of transfer structures to retrieve (default 50, max 200)
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] the latest time in ms to fetch transfers for (default time now)
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=transaction-structure transaction structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchDeposits', 'paginate', false);
        if ($paginate) {
            return $this->fetch_paginated_call_cursor('fetchDeposits', $code, $since, $limit, $params, 'code', null, 1, 50);
        }
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $request['endTime'] = $until;
            $params = $this->omit($params, 'until');
        }
        $response = $this->privateGetDeepcoinAssetWithdrawList ($this->extend($request, $params));
        $data = $this->safe_dict($response, 'data', array());
        $items = $this->safe_list($data, 'data', array());
        $transactionParams = array(
            'type' => 'withdrawal',
        );
        return $this->parse_transactions($items, $currency, $since, $limit, $transactionParams);
    }

    public function parse_transaction(array $transaction, ?array $currency = null): array {
        //
        // fetchDeposits
        //     {
        //         "createTime" => 1760368656,
        //         "txHash" => "03fe3244d89e794586222413c61779380da9e9fe5baaa253c38d01a4199a3499",
        //         "chainName" => "TRC20",
        //         "amount" => "149",
        //         "coin" => "USDT",
        //         "status" => "succeed"
        //     }
        //
        $txid = $this->safe_string($transaction, 'txHash');
        $currencyId = $this->safe_string($transaction, 'coin');
        $code = $this->safe_currency_code($currencyId, $currency);
        $amount = $this->safe_number($transaction, 'amount');
        $timestamp = $this->safe_timestamp($transaction, 'createTime');
        $networkId = $this->safe_string($transaction, 'chainName');
        $network = $this->network_id_to_code($networkId);
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        return array(
            'info' => $transaction,
            'id' => null,
            'currency' => $code,
            'amount' => $amount,
            'network' => $network,
            'addressFrom' => null,
            'addressTo' => null,
            'address' => $this->safe_string($transaction, 'address'),
            'tagFrom' => null,
            'tagTo' => null,
            'tag' => null,
            'status' => $status,
            'type' => null,
            'updated' => null,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'internal' => null,
            'comment' => null,
            'fee' => array(
                'currency' => null,
                'cost' => null,
            ),
        );
    }

    public function parse_transaction_status(?string $status): ?string {
        $statuses = array(
            'confirming' => 'pending',
            'succeed' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_deposit_addresses(?array $codes = null, $params = array ()): array {
        /**
         * fetch deposit addresses for multiple currencies and chain types
         *
         * @see https://www.deepcoin.com/docs/assets/chainlist
         *
         * @param {string[]|null} $codes $list of unified $currency $codes, default is null
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a $list of ~@link https://docs.ccxt.com/?id=address-structure address structures~
         */
        $this->load_markets();
        if ($codes === null) {
            throw new ArgumentsRequired($this->id . ' fetchDepositAddresses requires a $list with one $currency code');
        }
        $length = count($codes);
        if ($length !== 1) {
            throw new NotSupported($this->id . ' fetchDepositAddresses requires a $list with one $currency code');
        }
        $code = $codes[0];
        $currency = $this->currency($code);
        $request = array(
            'currency_id' => $currency['id'],
            'lang' => 'en',
        );
        $response = $this->privateGetDeepcoinAssetRechargeChainList ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => {
        //             "list" => array(
        //                 {
        //                     "chain" => "TRC20",
        //                     "state" => 1,
        //                     "remind" => "Only support deposits and withdrawals via TRC20 network. If you send it via other address by mistake, it will not be credited and will result in the permanent loss of your deposit.",
        //                     "inNotice" => "",
        //                     "actLogo" => "",
        //                     "address" => "TNJYDW9Bk87VwfA6s7FtxURLEMHesQbYgF",
        //                     "hasMemo" => false,
        //                     "memo" => "",
        //                     "estimatedTime" => 1,
        //                     "fastConfig" => {
        //                         "fastLimitNum" => 0,
        //                         "fastBlock" => 10,
        //                         "realBlock" => 1
        //                     }
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $list = $this->safe_list($data, 'list', array());
        $additionalParams = array(
            'currency' => $code,
        );
        return $this->parse_deposit_addresses($list, $codes, false, $additionalParams);
    }

    public function fetch_deposit_address(string $code, $params = array ()): array {
        /**
         * fetch the deposit $address for a currency associated with this account
         *
         * @see https://www.deepcoin.com/docs/assets/chainlist
         *
         * @param {string} $code unified currency $code
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->network] unified $network $code for deposit chain
         * @return {array} an ~@link https://docs.ccxt.com/?id=$address-structure $address structure~
         */
        $this->load_markets();
        $network = $this->safe_string($params, 'network');
        $defaultNetworks = $this->safe_dict($this->options, 'defaultNetworks', array());
        $defaultNetwork = $this->safe_string($defaultNetworks, $code);
        $network = $network ? $network : $defaultNetwork;
        if ($network !== null) {
            $params = $this->omit($params, 'network');
        }
        $addressess = $this->fetch_deposit_addresses(array( $code ), $params);
        $length = count($addressess);
        $address = $this->safe_dict($addressess, 0, array());
        if (($network !== null) && ($length > 1)) {
            for ($i = 0; $i < $length; $i++) {
                $entry = $addressess[$i];
                if ($entry['network'] === $network) {
                    $address = $entry;
                }
            }
        }
        return $address;
    }

    public function parse_deposit_address($response, ?array $currency = null): array {
        //
        //     {
        //         "chain" => "TRC20",
        //         "state" => 1,
        //         "remind" => "Only support deposits and withdrawals via TRC20 network. If you send it via other $address by mistake, it will not be credited and will result in the permanent loss of your deposit.",
        //         "inNotice" => "",
        //         "actLogo" => "",
        //         "address" => "TNJYDW9Bk87VwfA6s7FtxURLEMHesQbYgF",
        //         "hasMemo" => false,
        //         "memo" => "",
        //         "estimatedTime" => 1,
        //         "fastConfig" => {
        //             "fastLimitNum" => 0,
        //             "fastBlock" => 10,
        //             "realBlock" => 1
        //         }
        //     }
        //
        $chain = $this->safe_string($response, 'chain');
        $address = $this->safe_string($response, 'address');
        $this->check_address($address);
        return array(
            'info' => $response,
            'currency' => null,
            'network' => $this->network_id_to_code($chain),
            'address' => $address,
            'tag' => $this->safe_string($response, 'memo'),
        );
    }

    public function fetch_ledger(?string $code = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch the history of changes, actions done by the user or operations that altered the balance of the user
         *
         * @see https://www.deepcoin.com/docs/DeepCoinAccount/getAccountBills
         *
         * @param {string} [$code] unified $currency $code
         * @param {int} [$since] timestamp in ms of the earliest ledger entry
         * @param {int} [$limit] max number of ledger entries to return
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest ledger entry
         * @param {string} [$params->type] 'spot' or 'swap', the market type for the ledger (default 'spot')
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=ledger-entry-structure ledger structures~
         */
        $this->load_markets();
        $marketType = 'spot';
        list($marketType, $params) = $this->handle_market_type_and_params('fetchLedger', null, $params, $marketType);
        $request = array(
            'instType' => $this->convert_to_instrument_type($marketType),
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['ccy'] = $currency['id'];
        }
        if ($since !== null) {
            $request['after'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $request['before'] = $until;
            $params = $this->omit($params, 'until');
        }
        $response = $this->privateGetDeepcoinAccountBills ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             array(
        //                 "billId" => "1001044652247714",
        //                 "ccy" => "USDT",
        //                 "clientId" => "",
        //                 "balChg" => "-0.03543537",
        //                 "bal" => "72.41881427",
        //                 "type" => "5",
        //                 "ts" => "1761047448000"
        //             ),
        //             {
        //                 "billId" => "1001044652258368",
        //                 "ccy" => "DOGE",
        //                 "clientId" => "",
        //                 "balChg" => "76",
        //                 "bal" => "76",
        //                 "type" => "2",
        //                 "ts" => "1761051006000"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_ledger($data, $currency, $since, $limit);
    }

    public function parse_ledger_entry(array $item, ?array $currency = null): array {
        //
        //     {
        //         "billId" => "1001044652247714",
        //         "ccy" => "USDT",
        //         "clientId" => "",
        //         "balChg" => "-0.03543537",
        //         "bal" => "72.41881427",
        //         "type" => "5",
        //         "ts" => "1761047448000"
        //     }
        //
        $timestamp = $this->safe_integer($item, 'ts');
        $change = $this->safe_string($item, 'balChg');
        $amount = Precise::string_abs($change);
        $direction = Precise::string_lt($change, '0') ? 'out' : 'in';
        $currencyId = $this->safe_string($item, 'ccy');
        $currency = $this->safe_currency($currencyId, $currency);
        $type = $this->safe_string($item, 'type');
        return $this->safe_ledger_entry(array(
            'info' => $item,
            'id' => $this->safe_string($item, 'billId'),
            'direction' => $direction,
            'account' => null,
            'referenceAccount' => null,
            'referenceId' => null,
            'type' => $this->parse_ledger_entry_type($type),
            'currency' => $currency['code'],
            'amount' => $amount,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'before' => null,
            'after' => $this->safe_string($item, 'bal'),
            'status' => null,
            'fee' => null,
        ), $currency);
    }

    public function parse_ledger_entry_type($type) {
        $ledgerType = array(
            '1' => 'trade',
            '2' => 'trade',
            '3' => 'transfer',
            '4' => 'transfer',
            '5' => 'fee',
        );
        return $this->safe_string($ledgerType, $type, $type);
    }

    public function transfer(string $code, float $amount, string $fromAccount, string $toAccount, $params = array ()): array {
        /**
         * $transfer $currency internally between wallets on the same account
         *
         * @see https://www.deepcoin.com/docs/assets/transfer
         *
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to $transfer
         * @param {string} $fromAccount account to $transfer from ('spot', 'inverse', 'linear', 'fund', 'rebate' or 'demo')
         * @param {string} $toAccount account to $transfer to ('spot', 'inverse', 'linear', 'fund', 'rebate' or 'demo')
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->userId] user id
         * @return {array} a ~@link https://docs.ccxt.com/?id=$transfer-structure $transfer structure~
         */
        $userId = null;
        list($userId, $params) = $this->handle_option_and_params($params, 'transfer', 'userId');
        $userId = $userId ? $userId : $this->safe_string($params, 'uid');
        if ($userId === null) {
            throw new ArgumentsRequired($this->id . ' $transfer() requires a $userId parameter');
        }
        $this->load_markets();
        $currency = $this->currency($code);
        $accountsByType = $this->safe_dict($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
        $request = array(
            'currency_id' => $currency['id'],
            'amount' => $this->currency_to_precision($code, $amount),
            'from_id' => $fromId,
            'to_id' => $toId,
            'uid' => $userId,
        );
        $response = $this->privatePostDeepcoinAssetTransfer ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => {
        //             "retCode" => 0,
        //             "retMsg" => "",
        //             "retData" => array()
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $transfer = $this->parse_transfer($data, $currency);
        $transferOptions = $this->safe_dict($this->options, 'transfer', array());
        $fillResponseFromRequest = $this->safe_bool($transferOptions, 'fillResponseFromRequest', true);
        if ($fillResponseFromRequest) {
            $transfer['fromAccount'] = $fromAccount;
            $transfer['toAccount'] = $toAccount;
            $transfer['amount'] = $amount;
        }
        return $transfer;
    }

    public function parse_transfer(array $transfer, ?array $currency = null): array {
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "",
        //         "retData" => array()
        //     }
        //
        $status = $this->safe_string($transfer, 'retCode');
        $currencyCode = $this->safe_currency_code(null, $currency);
        return array(
            'info' => $transfer,
            'id' => null,
            'timestamp' => null,
            'datetime' => null,
            'currency' => $currencyCode,
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => $this->parse_transfer_status($status),
        );
    }

    public function parse_transfer_status(?string $status): ?string {
        if ($status === '0') {
            return 'ok';
        }
        return 'failed';
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * create a trade order
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/order
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrder
         *
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->clientOrderId] a unique id for the order
         * @param {string} [$params->timeInForce] *non trigger orders only* 'GTC' (Good Till Cancel), 'IOC' (Immediate Or Cancel) or 'PO' (Post Only)
         * @param {bool} [$params->postOnly] *non trigger orders only* true to place a post only order
         * @param {bool} [$params->reduceOnly] *non trigger orders only* a mark to reduce the position size for margin, swap and future orders
         * @param {float} [$params->triggerPrice] the $price a trigger order is triggered at
         * @param {float} [$params->stopLoss.triggerPrice] the $price that a stop loss order is triggered at
         * @param {float} [$params->takeProfit.triggerPrice] the $price that a take profit order is triggered at
         * @param {string} [$params->positionSide] if position mode is one-way => set to 'net', if position mode is hedge-mode => set to 'long' or 'short'
         * @param {bool} [$params->hedged] *swap only* true for hedged mode, false for one way mode
         * @param {string} [$params->marginMode] *swap only*'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
         * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $triggerPrice = $this->safe_string($params, 'triggerPrice');
        $request = $this->create_order_request($symbol, $type, $side, $amount, $price, $params);
        $response = null;
        if ($triggerPrice !== null) {
            // trigger orders
            $response = $this->privatePostDeepcoinTradeTriggerOrder ($request);
        } else {
            // regular orders
            //
            //     {
            //         "code" => "0",
            //         "msg" => "",
            //         "data" => {
            //             "ordId" => "1001434570213727",
            //             "clOrdId" => "",
            //             "tag" => "",
            //             "sCode" => "0",
            //             "sMsg" => ""
            //         }
            //     }
            //
            $response = $this->privatePostDeepcoinTradeOrder ($request);
        }
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_order($data, $market);
    }

    public function create_order_request(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * @ignore
         * helper function to build request
         */
        $market = $this->market($symbol);
        $triggerPrice = $this->safe_string($params, 'triggerPrice');
        // $isTriggerOrder = ($triggerPrice !== null) || $this->safe_string_2($params, 'stopLossPrice', 'takeProfitPrice') !== null;
        $isTriggerOrder = ($triggerPrice !== null);
        $cost = $this->safe_string($params, 'cost');
        if ($cost !== null) {
            if (!$market['spot'] || ($triggerPrice !== null)) {
                throw new BadRequest($this->id . ' createOrder() accepts a $cost parameter for spot non-trigger $market orders only');
            }
        }
        if ($isTriggerOrder) {
            return $this->create_trigger_order_request($symbol, $type, $side, $amount, $price, $params);
        } else {
            return $this->create_regular_order_request($symbol, $type, $side, $amount, $price, $params);
        }
    }

    public function create_regular_order_request(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * @ignore
         * helper function to build $request
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much you want to trade in units of the base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {float} [$params->cost] *spot only* the $cost of the order in units of the quote currency, for $market orders only
         * @param {string} [$params->clientOrderId] a unique id for the order
         * @param {string} [$params->timeInForce] 'GTC' (Good Till Cancel), 'IOC' (Immediate Or Cancel) or 'PO' (Post Only)
         * @param {bool} [$params->postOnly] true to place a post only order
         * @param {bool} [$params->reduceOnly] a mark to reduce the position size for margin and swap orders
         * @param {float} [$params->stopLossPrice] the $price that a stop loss order is triggered at
         * @param {float} [$params->takeProfitPrice] the $price that a take profit order is triggered at
         * @param {string} [$params->marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
         * @param {string} [$params->mrgPosition] *swap only* 'merge' or 'split', the default is 'merge'
         */
        $market = $this->market($symbol);
        $orderType = $type;
        list($orderType, $params) = $this->handle_type_post_only_and_time_in_force($type, $params);
        $request = array(
            'instId' => $market['id'],
            // 'tdMode' => 'cash', // 'cash' for spot, 'cross' or 'isolated' for swap
            // 'ccy' => currency['id'], // only applicable to cross MARGIN orders in single-currency margin
            // 'clOrdId' => $clientOrderId,
            'side' => $side,
            'ordType' => $orderType,
            // 'sz' => $amount or $cost
            // 'px' => $price, // limit orders only
            // 'reduceOnly' => false, // a mark to reduce the position size for margin and swap orders
            // 'tgtCcy' => 'base_ccy', // spot only 'base_ccy' or 'quote_ccy', the default is 'base_ccy' for spot orders
            // 'tpTriggerPx' => $takeProfitPrice, // take profit trigger $price
            // 'slTriggerPx' => $stopLossPrice, // stop loss trigger $price
            // 'posSide' => 'long', // swap only 'long' or 'short'
            // 'mrgPosition' => 'merge', // swap only 'merge' or 'split'
            // 'closePosId' => 'id', // swap only position ID to close, required in split mode
        );
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['clOrdId'] = $clientOrderId;
            $params = $this->omit($params, 'clientOrderId');
        }
        $stopLoss = $this->safe_dict($params, 'stopLoss', array());
        $stopLossPrice = $this->safe_string($stopLoss, 'triggerPrice');
        if ($stopLossPrice !== null) {
            $params = $this->omit($params, array( 'stopLoss' ));
            $request['slTriggerPx'] = $this->price_to_precision($symbol, $stopLossPrice);
        }
        $takeProfit = $this->safe_dict($params, 'takeProfit', array());
        $takeProfitPrice = $this->safe_string($takeProfit, 'triggerPrice');
        if ($takeProfitPrice !== null) {
            $params = $this->omit($params, array( 'takeProfit' ));
            $request['tpTriggerPx'] = $this->price_to_precision($symbol, $takeProfitPrice);
        }
        $isMarketOrder = ($type === 'market');
        if ($price !== null) {
            if ($isMarketOrder) {
                throw new BadRequest($this->id . ' createOrder() does not require a $price argument for $market orders');
            }
            $request['px'] = $this->price_to_precision($symbol, $price);
        } elseif (!$isMarketOrder) {
            throw new BadRequest($this->id . ' createOrder() requires a $price argument for limit orders');
        }
        if ($market['spot']) {
            $cost = $this->safe_string($params, 'cost');
            if ($cost !== null) {
                if (!$isMarketOrder) {
                    throw new BadRequest($this->id . ' createOrder() accepts a $cost parameter for spot $market orders only');
                }
                $params = $this->omit($params, 'cost');
                $request['sz'] = $this->cost_to_precision($symbol, $cost);
                $request['tgtCcy'] = 'quote_ccy';
            } else {
                $request['sz'] = $this->amount_to_precision($symbol, $amount);
                $request['tgtCcy'] = 'base_ccy';
            }
            $request['side'] = $side;
            $request['tdMode'] = 'cash';
        } else {
            $request['sz'] = $this->amount_to_precision($symbol, $amount);
            $marginMode = 'cross';
            list($marginMode, $params) = $this->handle_margin_mode_and_params('createOrder', $params, $marginMode);
            $request['tdMode'] = $marginMode;
            $mrgPosition = 'merge';
            list($mrgPosition, $params) = $this->handle_option_and_params($params, 'createOrder', 'mrgPosition', $mrgPosition);
            $request['mrgPosition'] = $mrgPosition;
            $posSide = null;
            $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
            if ($reduceOnly) {
                if ($side === 'buy') {
                    $posSide = 'short';
                } elseif ($side === 'sell') {
                    $posSide = 'long';
                }
            } else {
                if ($side === 'buy') {
                    $posSide = 'long';
                } elseif ($side === 'sell') {
                    $posSide = 'short';
                }
            }
            $request['posSide'] = $posSide;
        }
        return $this->extend($request, $params);
    }

    public function create_trigger_order_request(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()) {
        /**
         * @ignore
         * helper function to build $request
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much you want to trade in units of the base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {bool} [$params->reduceOnly] a mark to reduce the position size for margin orders
         * @param {string} [$params->marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
         */
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            'productGroup' => $this->capitalize($market['type']),
            'sz' => $this->amount_to_precision($symbol, $amount),
            'side' => $side,
            // 'posSide' => 'long', // 'long' or 'short' - required when product $type is SWAP
            // 'price' => $price,
            // 'isCrossMargin' => 1, // 1 for cross margin, 0 for isolated margin
            'orderType' => $type,
            // 'triggerPrice' => $triggerPrice,
            // 'mrgPosition' => 'merge', // 'merge' or 'split', the default is 'merge' - required when product $type is SWAP
            // 'tdMode' => 'cash', // 'cash' for spot, 'cross' or 'isolated' for swap
        );
        $triggerPrice = $this->safe_string($params, 'triggerPrice');
        // $takeProfitPrice = $this->safe_string($params, 'takeProfitPrice');
        // $stopLossPrice = $this->safe_string($params, 'stopLossPrice');
        // $isTpOrSlOrder = ($takeProfitPrice !== null) || ($stopLossPrice !== null);
        // if ($isTpOrSlOrder) {
        //     if ($takeProfitPrice !== null) {
        //         $request['triggerPrice'] = $this->price_to_precision($symbol, $takeProfitPrice);
        //     } else {
        //         $request['triggerPrice'] = $this->price_to_precision($symbol, $stopLossPrice);
        //     }
        // } else {
        $request['triggerPrice'] = $this->price_to_precision($symbol, $triggerPrice);
        // }
        if ($price !== null) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        } elseif ($type === 'limit') {
            throw new ArgumentsRequired($this->id . ' createOrder() requires a $price argument for limit trigger orders');
        }
        $marginMode = 'cross';
        list($marginMode, $params) = $this->handle_margin_mode_and_params('createOrder', $params, $marginMode);
        $isCrossMargin = 1;
        if ($marginMode === 'isolated') {
            $isCrossMargin = 0;
        }
        $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
        $params = $this->omit($params, 'reduceOnly');
        $request['isCrossMargin'] = $isCrossMargin;
        $request['tdMode'] = $marginMode;
        if ($market['swap']) {
            if ($reduceOnly) {
                if ($side === 'buy') {
                    $request['posSide'] = 'short';
                } elseif ($side === 'sell') {
                    $request['posSide'] = 'long';
                }
            } else {
                if ($side === 'buy') {
                    $request['posSide'] = 'long';
                } elseif ($side === 'sell') {
                    $request['posSide'] = 'short';
                }
            }
        }
        $mrgPosition = 'merge';
        list($mrgPosition, $params) = $this->handle_option_and_params($params, 'createOrder', 'mrgPosition', $mrgPosition);
        $request['mrgPosition'] = $mrgPosition;
        return $this->extend($request, $params);
    }

    public function handle_type_post_only_and_time_in_force(string $type, $params) {
        $postOnly = false;
        list($postOnly, $params) = $this->handle_post_only($type === 'market', $type === 'post_only', $params);
        if ($postOnly) {
            $type = 'post_only';
        }
        $timeInForce = $this->handle_time_in_force($params);
        $params = $this->omit($params, 'timeInForce');
        if (($timeInForce !== null) && ($timeInForce === 'IOC')) {
            $type = 'ioc';
        }
        return array( $type, $params );
    }

    public function create_market_order_with_cost(string $symbol, string $side, float $cost, $params = array ()) {
        /**
         * create a market order by providing the $symbol, $side and $cost
         * @param {string} $symbol unified $symbol of the market to create an order in
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $cost how much you want to trade in units of the quote currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
         */
        $params = $this->extend($params, array( 'cost' => $cost ));
        return $this->create_order($symbol, 'market', $side, 0, null, $params);
    }

    public function create_market_buy_order_with_cost(string $symbol, float $cost, $params = array ()): array {
        /**
         * create a market buy order by providing the $symbol and $cost
         * @param {string} $symbol unified $symbol of the market to create an order in
         * @param {float} $cost how much you want to trade in units of the quote currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
         */
        $params = $this->extend($params, array( 'cost' => $cost ));
        return $this->create_order($symbol, 'market', 'buy', 0, null, $params);
    }

    public function create_market_sell_order_with_cost(string $symbol, float $cost, $params = array ()): array {
        /**
         * create a market sell order by providing the $symbol and $cost
         * @param {string} $symbol unified $symbol of the market to create an order in
         * @param {float} $cost how much you want to trade in units of the quote currency
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
         */
        $params = $this->extend($params, array( 'cost' => $cost ));
        return $this->create_order($symbol, 'market', 'sell', 0, null, $params);
    }

    public function fetch_closed_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetches information on a closed order made by the user
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/finishOrderByID
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchClosedOrder() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            'ordId' => $id,
        );
        $response = $this->privateGetDeepcoinTradeFinishOrderByID ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "instType" => "SPOT",
        //                 "instId" => "ETH-USDT",
        //                 "tgtCcy" => "",
        //                 "ccy" => "",
        //                 "ordId" => "1001434573319675",
        //                 "clOrdId" => "",
        //                 "tag" => "",
        //                 "px" => "4056.620000000000",
        //                 "sz" => "0.004000",
        //                 "pnl" => "0.000000",
        //                 "ordType" => "market",
        //                 "side" => "buy",
        //                 "posSide" => "",
        //                 "tdMode" => "cash",
        //                 "accFillSz" => "0.004000",
        //                 "fillPx" => "",
        //                 "tradeId" => "",
        //                 "fillSz" => "0.004000",
        //                 "fillTime" => "1760619119000",
        //                 "avgPx" => "",
        //                 "state" => "filled",
        //                 "lever" => "1.000000",
        //                 "tpTriggerPx" => "",
        //                 "tpTriggerPxType" => "",
        //                 "tpOrdPx" => "",
        //                 "slTriggerPx" => "",
        //                 "slTriggerPxType" => "",
        //                 "slOrdPx" => "",
        //                 "feeCcy" => "USDT",
        //                 "fee" => "0.000004",
        //                 "rebateCcy" => "",
        //                 "source" => "",
        //                 "rebate" => "",
        //                 "category" => "normal",
        //                 "uTime" => "1760619119000",
        //                 "cTime" => "1760619119000"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_list($response, 'data', array());
        $entry = $this->safe_dict($data, 0, array());
        return $this->parse_order($entry, $market);
    }

    public function fetch_open_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * fetch an open order by it's $id
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/orderByID
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $market $symbol, default is null
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchClosedOrder() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            'ordId' => $id,
        );
        $response = $this->privateGetDeepcoinTradeOrderByID ($this->extend($request, $params));
        $data = $this->safe_list($response, 'data', array());
        $length = count($data);
        if ($length === 0) {
            return null;
        }
        $entry = $this->safe_dict($data, 0, array());
        return $this->parse_order($entry, $market);
    }

    public function fetch_canceled_and_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrdersHistory
         *
         * fetches information on multiple canceled and closed orders made by the user
         * @param {string} [$symbol] unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {bool} [$params->trigger] whether to fetch trigger/algo orders (default false)
         * @param {string} [$params->type] *non $trigger orders only* 'spot' or 'swap', the $market type for the orders
         * @param {string} [$params->state] *non $trigger orders only* 'canceled' or 'filled', the order state to filter by
         * @param {string} [$params->OrderType] *$trigger orders only* 'limit' or 'market'
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchCanceledAndClosedOrders', 'paginate');
        if ($paginate) {
            return $this->fetch_paginated_call_dynamic('fetchCanceledAndClosedOrders', $symbol, $since, $limit, $params);
        }
        $trigger = $this->safe_bool($params, 'trigger', false);
        $methodName = 'fetchCanceledAndClosedOrders';
        list($methodName, $params) = $this->handle_param_string($params, 'methodName', $methodName);
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['instId'] = $market['id'];
        }
        $marketType = 'spot';
        list($marketType, $params) = $this->handle_market_type_and_params($methodName, $market, $params, $marketType);
        $request['instType'] = $this->convert_to_instrument_type($marketType);
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100
        }
        $response = null;
        if ($trigger) {
            if ($methodName !== 'fetchCanceledAndClosedOrders') {
                throw new BadRequest($this->id . ' ' . $methodName . '() does not support $trigger orders');
            }
            if ($market === null) {
                throw new ArgumentsRequired($this->id . ' fetchCanceledAndClosedOrders() requires a $symbol argument for $trigger orders');
            }
            $params = $this->omit($params, 'trigger');
            //
            //     {
            //         "code" => "0",
            //         "msg" => "",
            //         "data" => array(
            //             {
            //                 "instType" => "SWAP",
            //                 "instId" => "DOGE-USDT-SWAP",
            //                 "ordId" => "1001110510915416",
            //                 "px" => "0",
            //                 "sz" => "76",
            //                 "triggerPx" => "0",
            //                 "triggerPxType" => "last",
            //                 "ordType" => "TPSL",
            //                 "side" => "sell",
            //                 "posSide" => "long",
            //                 "tdMode" => "cross",
            //                 "lever" => "2",
            //                 "triggerTime" => "0",
            //                 "uTime" => "1761059366000",
            //                 "cTime" => "1761059218",
            //                 "errorCode" => "0",
            //                 "errorMsg" => ""
            //             }
            //         )
            //     }
            //
            $response = $this->privateGetDeepcoinTradeTriggerOrdersHistory ($this->extend($request, $params));
        } else {
            //
            //     {
            //         "code" => "0",
            //         "msg" => "",
            //         "data" => array(
            //             {
            //                 "instType" => "SPOT",
            //                 "instId" => "ETH-USDT",
            //                 "tgtCcy" => "",
            //                 "ccy" => "",
            //                 "ordId" => "1001434573319675",
            //                 "clOrdId" => "",
            //                 "tag" => "",
            //                 "px" => "4056.620000000000",
            //                 "sz" => "0.004000",
            //                 "pnl" => "0.000000",
            //                 "ordType" => "market",
            //                 "side" => "buy",
            //                 "posSide" => "",
            //                 "tdMode" => "cash",
            //                 "accFillSz" => "0.004000",
            //                 "fillPx" => "",
            //                 "tradeId" => "",
            //                 "fillSz" => "0.004000",
            //                 "fillTime" => "1760619119000",
            //                 "avgPx" => "",
            //                 "state" => "filled",
            //                 "lever" => "1.000000",
            //                 "tpTriggerPx" => "",
            //                 "tpTriggerPxType" => "",
            //                 "tpOrdPx" => "",
            //                 "slTriggerPx" => "",
            //                 "slTriggerPxType" => "",
            //                 "slOrdPx" => "",
            //                 "feeCcy" => "USDT",
            //                 "fee" => "0.000004",
            //                 "rebateCcy" => "",
            //                 "source" => "",
            //                 "rebate" => "",
            //                 "category" => "normal",
            //                 "uTime" => "1760619119000",
            //                 "cTime" => "1760619119000"
            //             }
            //         )
            //     }
            //
            $response = $this->privateGetDeepcoinTradeOrdersHistory ($this->extend($request, $params));
        }
        // todo handle with $since, until and pagination
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_canceled_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple canceled orders made by the user
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
         *
         * @param {string} $symbol unified market $symbol of the market the orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->type] 'spot' or 'swap', the market type for the orders
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $methodName = 'fetchCanceledOrders';
        $params = $this->extend($params, array( 'methodName' => $methodName ));
        $params = $this->extend($params, array( 'state' => 'canceled' ));
        return $this->fetch_canceled_and_closed_orders($symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetches information on multiple closed orders made by the user
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
         *
         * @param {string} $symbol unified market $symbol of the market the orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->type] 'spot' or 'swap', the market type for the orders
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $methodName = 'fetchClosedOrders';
        $params = $this->extend($params, array( 'methodName' => $methodName ));
        $params = $this->extend($params, array( 'state' => 'filled' ));
        return $this->fetch_canceled_and_closed_orders($symbol, $since, $limit, $params);
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): array {
        /**
         * fetch all unfilled currently open orders
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersPendingV2
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrdersPending
         *
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int} [$since] the earliest time in ms to fetch orders for
         * @param {int} [$limit] the maximum number of order structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {bool} [$params->trigger] whether to fetch trigger/algo orders (default false)
         * @param {int} [$params->index] *non $trigger orders only* pagination $index, default is 1
         * @param {string} [$params->orderType] *$trigger orders only* 'limit' or 'market'
         * @return {Order[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $index = $this->safe_integer($params, 'index', 1); // todo add pagination handling
        $request = array(
            'instId' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $trigger = $this->safe_bool($params, 'trigger', false);
        $response = null;
        if ($trigger) {
            $params = $this->omit($params, 'trigger');
            $request['instType'] = $this->convert_to_instrument_type($market['type']);
            //
            //     {
            //         "code" => "0",
            //         "msg" => "",
            //         "data" => array(
            //             {
            //                 "instType" => "SPOT",
            //                 "instId" => "DOGE-USDT",
            //                 "ordId" => "1001442305797142",
            //                 "triggerPx" => "0.01",
            //                 "ordPx" => "0.01",
            //                 "sz" => "20",
            //                 "ordType" => "",
            //                 "side" => "buy",
            //                 "posSide" => "",
            //                 "tdMode" => "cash",
            //                 "triggerOrderType" => "Conditional",
            //                 "triggerPxType" => "last",
            //                 "lever" => "",
            //                 "slPrice" => "",
            //                 "slTriggerPrice" => "",
            //                 "tpPrice" => "",
            //                 "tpTriggerPrice" => "",
            //                 "closeSLTriggerPrice" => "",
            //                 "closeTPTriggerPrice" => "",
            //                 "cTime" => "1761814167000",
            //                 "uTime" => "1761814167000"
            //             }
            //         )
            //     }
            //
            $response = $this->privateGetDeepcoinTradeTriggerOrdersPending ($this->extend($request, $params));
        } else {
            $request['index'] = $index;
            //
            //     {
            //         "code" => "0",
            //         "msg" => "",
            //         "data" => array(
            //             {
            //                 "instType" => "SPOT",
            //                 "instId" => "ETH-USDT",
            //                 "tgtCcy" => "",
            //                 "ccy" => "",
            //                 "ordId" => "1001435158096314",
            //                 "clOrdId" => "",
            //                 "tag" => "",
            //                 "px" => "1000.000000000000",
            //                 "sz" => "0.004000",
            //                 "pnl" => "0.000000",
            //                 "ordType" => "limit",
            //                 "side" => "buy",
            //                 "posSide" => "",
            //                 "tdMode" => "cash",
            //                 "accFillSz" => "0.000000",
            //                 "fillPx" => "",
            //                 "tradeId" => "",
            //                 "fillSz" => "0.000000",
            //                 "fillTime" => "1760695267000",
            //                 "avgPx" => "",
            //                 "state" => "live",
            //                 "lever" => "1",
            //                 "tpTriggerPx" => "",
            //                 "tpTriggerPxType" => "",
            //                 "tpOrdPx" => "",
            //                 "slTriggerPx" => "",
            //                 "slTriggerPxType" => "",
            //                 "slOrdPx" => "",
            //                 "feeCcy" => "USDT",
            //                 "fee" => "0.000000",
            //                 "rebateCcy" => "",
            //                 "source" => "",
            //                 "rebate" => "",
            //                 "category" => "normal",
            //                 "uTime" => "1760695267000",
            //                 "cTime" => "1760695267000"
            //             }
            //         )
            //     }
            //
            $response = $this->privateGetDeepcoinTradeV2OrdersPending ($this->extend($request, $params));
        }
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit, array( 'status' => 'open' ));
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): array {
        /**
         * cancels an open order
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/cancelOrder
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {bool} [$params->trigger] whether the order is a trigger/algo order (default false)
         * @return {array} An ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            'ordId' => $id,
        );
        $response = null;
        $trigger = $this->safe_bool($params, 'trigger', false);
        if ($trigger) {
            $params = $this->omit($params, 'trigger');
            $response = $this->privatePostDeepcoinTradeCancelTriggerOrder ($this->extend($request, $params));
        } else {
            $response = $this->privatePostDeepcoinTradeCancelOrder ($this->extend($request, $params));
        }
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_order($data, $market);
    }

    public function cancel_all_orders(?string $symbol = null, $params = array ()): array {
        /**
         * cancel all open orders in a $market
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/cancelAllOrder
         *
         * @param {string} $symbol unified $market $symbol of the $market to cancel orders in
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
         * @param {bool} [$params->merged] *swap only* true for $merged positions, false for split positions (default true)
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
        }
        $market = $this->market($symbol);
        if ($market['spot']) {
            throw new NotSupported($this->id . ' cancelAllOrders() is not supported for spot markets');
        }
        $productGroup = $this->get_product_group_from_market($market);
        $marginMode = $this->safe_string($params, 'marginMode');
        $encodedMarginMode = 1;
        if ($marginMode !== null) {
            $params = $this->omit($params, 'marginMode');
            if ($marginMode === 'isolated') {
                $encodedMarginMode = 0;
            }
        }
        $merged = true;
        list($merged, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'merged', $merged);
        $request = array(
            'InstrumentID' => $market['id'],
            'ProductGroup' => $productGroup,
            'IsCrossMargin' => $encodedMarginMode,
            'IsMergeMode' => $merged ? 1 : 0,
        );
        $response = $this->privatePostDeepcoinTradeSwapCancelAll ($this->extend($request, $params));
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_orders($data, $market);
    }

    public function edit_order(string $id, string $symbol, string $type, string $side, ?float $amount = null, ?float $price = null, $params = array ()) {
        /**
         * edit a trade order
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/replaceOrder
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/replaceTPSL
         *
         * @param {string} $id cancel order $id
         * @param {string} [$symbol] unified $symbol of the $market to create an order in (not used in deepcoin editOrder)
         * @param {string} [$type] 'market' or 'limit' (not used in deepcoin editOrder)
         * @param {string} [$side] 'buy' or 'sell' (not used in deepcoin editOrder)
         * @param {float} [$amount] how much of currency you want to trade in units of base currency
         * @param {float} [$price] the $price at which the order is to be fulfilled, in units of the quote currency, ignored in $market orders
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {float} [$params->stopLossPrice] the $price that a stop loss order is triggered at
         * @param {float} [$params->takeProfitPrice] the $price that a take profit order is triggered at
         * @return {array} an ~@link https://docs.ccxt.com/?$id=order-structure order structure~
         */
        $this->load_markets();
        $request = array(
            'OrderSysID' => $id,
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            if ($market['spot']) {
                throw new NotSupported($this->id . ' editOrder() is not supported for spot markets');
            }
            $symbol = $market['symbol'];
        }
        $stopLossPrice = $this->safe_number($params, 'stopLossPrice');
        $takeProfitPrice = $this->safe_number($params, 'takeProfitPrice');
        $isTPSL = ($stopLossPrice !== null) || ($takeProfitPrice !== null);
        $response = null;
        if ($isTPSL) {
            if (($price !== null) || ($amount !== null)) {
                throw new BadRequest($this->id . ' editOrder() with $stopLossPrice or $takeProfitPrice cannot have $price or $amount-> Either use stopLossPrice/takeProfitPrice or price/amount to edit order.');
            }
            if ($stopLossPrice !== null) {
                $request['slTriggerPx'] = $symbol ? $this->price_to_precision($symbol, $stopLossPrice) : $this->number_to_string($stopLossPrice);
            }
            if ($takeProfitPrice !== null) {
                $request['tpTriggerPx'] = $symbol ? $this->price_to_precision($symbol, $takeProfitPrice) : $this->number_to_string($takeProfitPrice);
            }
            $params = $this->omit($params, array( 'stopLossPrice', 'takeProfitPrice' ));
            $response = $this->privatePostDeepcoinTradeReplaceOrderSltp ($this->extend($request, $params));
        } else {
            if ($price !== null) {
                if ($symbol !== null) {
                    $request['price'] = $this->price_to_precision($symbol, $price);
                } else {
                    $request['price'] = $this->number_to_string($price);
                }
            }
            if ($amount !== null) {
                if ($symbol !== null) {
                    $request['volume'] = $this->amount_to_precision($symbol, $amount);
                } else {
                    $request['volume'] = $this->number_to_string($amount);
                }
            }
            $response = $this->privatePostDeepcoinTradeReplaceOrder ($this->extend($request, $params));
        }
        $data = $this->safe_dict($response, 'data', array());
        return $this->parse_order($data);
    }

    public function cancel_orders(array $ids, ?string $symbol = null, $params = array ()): array {
        /**
         * cancel multiple orders
         * @param {string[]} $ids order $ids
         * @param {string} [$symbol] unified $market $symbol, default is null
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} an list of ~@link https://docs.ccxt.com/?id=order-structure order structures~
         */
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            if ($market['spot']) {
                throw new NotSupported($this->id . ' cancelOrders() is not supported for spot markets');
            }
        }
        $request = array(
            'OrderSysIDs' => $ids,
        );
        $response = $this->privatePostDeepcoinTradeBatchCancelOrder ($this->extend($request, $params));
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_orders($data, $market);
    }

    public function parse_order(array $order, ?array $market = null): array {
        //
        // regular $order
        //     {
        //         "instType" => "SPOT",
        //         "instId" => "ETH-USDT",
        //         "tgtCcy" => "",
        //         "ccy" => "",
        //         "ordId" => "1001434573319675",
        //         "clOrdId" => "",
        //         "tag" => "",
        //         "px" => "4056.620000000000",
        //         "sz" => "0.004000",
        //         "pnl" => "0.000000",
        //         "ordType" => "market",
        //         "side" => "buy",
        //         "posSide" => "",
        //         "tdMode" => "cash",
        //         "accFillSz" => "0.004000",
        //         "fillPx" => "",
        //         "tradeId" => "",
        //         "fillSz" => "0.004000",
        //         "fillTime" => "1760619119000",
        //         "avgPx" => "",
        //         "state" => "filled",
        //         "lever" => "1.000000",
        //         "tpTriggerPx" => "",
        //         "tpTriggerPxType" => "",
        //         "tpOrdPx" => "",
        //         "slTriggerPx" => "",
        //         "slTriggerPxType" => "",
        //         "slOrdPx" => "",
        //         "feeCcy" => "USDT",
        //         "fee" => "0.000004",
        //         "rebateCcy" => "",
        //         "source" => "",
        //         "rebate" => "",
        //         "category" => "normal",
        //         "uTime" => "1760619119000",
        //         "cTime" => "1760619119000"
        //     }
        //
        // trigger $order
        //     {
        //         "instType" => "SPOT",
        //         "instId" => "DOGE-USDT",
        //         "ordId" => "1001442305797142",
        //         "triggerPx" => "0.01",
        //         "ordPx" => "0.01",
        //         "sz" => "20",
        //         "ordType" => "",
        //         "side" => "buy",
        //         "posSide" => "",
        //         "tdMode" => "cash",
        //         "triggerOrderType" => "Conditional",
        //         "triggerPxType" => "last",
        //         "lever" => "",
        //         "slPrice" => "",
        //         "slTriggerPrice" => "",
        //         "tpPrice" => "",
        //         "tpTriggerPrice" => "",
        //         "closeSLTriggerPrice" => "",
        //         "closeTPTriggerPrice" => "",
        //         "cTime" => "1761814167000",
        //         "uTime" => "1761814167000"
        //     }
        //
        $marketId = $this->safe_string($order, 'instId');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($order, 'cTime');
        $timestampString = $this->safe_string($order, 'cTime', '');
        if (strlen($timestampString) < 13) {
            $timestamp = $this->safe_timestamp($order, 'cTime');
        }
        $state = $this->safe_string($order, 'state');
        $orderType = $this->safe_string($order, 'ordType');
        $average = $this->safe_string($order, 'avgPx');
        if ($average === '') {
            $average = null;
        }
        $feeCurrencyId = $this->safe_string($order, 'feeCcy');
        $fee = null;
        if ($feeCurrencyId !== null) {
            $feeCost = $this->safe_string($order, 'fee');
            $fee = array(
                'cost' => $this->parse_number($feeCost),
                'currency' => $this->safe_currency_code($feeCurrencyId),
            );
        }
        return $this->safe_order(array(
            'id' => $this->safe_string($order, 'ordId'),
            'clientOrderId' => $this->safe_string($order, 'clOrdId'),
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => null,
            'lastUpdateTimestamp' => $this->safe_integer($order, 'uTime'),
            'status' => $this->parse_order_status($state),
            'symbol' => $market['symbol'],
            'type' => $this->parse_order_type($orderType),
            'timeInForce' => $this->parse_order_time_in_force($orderType),
            'side' => $this->safe_string($order, 'side'),
            'price' => $this->safe_string_2($order, 'px', 'ordPx'),
            'average' => $average,
            'amount' => $this->safe_string($order, 'sz'),
            'filled' => $this->safe_string($order, 'accFillSz'),
            'remaining' => null,
            'triggerPrice' => $this->omit_zero($this->safe_string($order, 'triggerPx')),
            'takeProfitPrice' => $this->safe_string_2($order, 'tpTriggerPx', 'tpTriggerPrice'),
            'stopLossPrice' => $this->safe_string_2($order, 'slTriggerPx', 'slTriggerPrice'),
            'cost' => null,
            'trades' => null,
            'fee' => $fee,
            'reduceOnly' => null,
            'postOnly' => $orderType ? ($orderType === 'post_only') : null,
            'info' => $order,
        ), $market);
    }

    public function parse_order_status(?string $status): ?string {
        $statuses = array(
            'live' => 'open',
            'filled' => 'closed',
            'canceled' => 'canceled',
            'partially_filled' => 'open',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_type(?string $type): ?string {
        $types = array(
            'limit' => 'limit',
            'market' => 'market',
            'post_only' => 'limit',
            'ioc' => 'market',
            'TPSL' => 'market',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_order_time_in_force(?string $type): ?string {
        $timeInForces = array(
            'post_only' => 'PO',
            'ioc' => 'IOC',
            'limit' => 'GTC',
            'market' => 'GTC',
        );
        return $this->safe_string($timeInForces, $type, $type);
    }

    public function fetch_positions_for_symbol(string $symbol, $params = array ()): array {
        /**
         * fetch open positions for a single $market
         *
         * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountPositions
         *
         * fetch all open positions for specific $symbol
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=position-structure position structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $instrumentType = $this->convert_to_instrument_type($market['type']);
        $request = array(
            'instType' => $instrumentType,
            'instId' => $market['id'],
        );
        $response = $this->privateGetDeepcoinAccountPositions ($this->extend($request, $params));
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_positions($data, [ $market['symbol'] ]);
    }

    public function fetch_positions(?array $symbols = null, $params = array ()): array {
        /**
         * fetch all open positions
         *
         * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountPositions
         *
         * @param {string[]} [$symbols] list of unified $market $symbols
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=position-structure position structure~
         */
        $this->load_markets();
        $symbols = $this->market_symbols($symbols, null, true, true);
        $marketType = 'swap';
        $market = null;
        if ($symbols !== null) {
            $firstSymbol = $this->safe_string($symbols, 0);
            $market = $this->market($firstSymbol);
        }
        list($marketType, $params) = $this->handle_market_type_and_params('fetchPositions', $market, $params, $marketType);
        $instrumentType = $this->convert_to_instrument_type($marketType);
        $request = array(
            'instType' => $instrumentType,
        );
        $response = $this->privateGetDeepcoinAccountPositions ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "instType" => "SWAP",
        //                 "mgnMode" => "cross",
        //                 "instId" => "DOGE-USDT-SWAP",
        //                 "posId" => "1001110099878275",
        //                 "posSide" => "long",
        //                 "pos" => "20",
        //                 "avgPx" => "0.18408",
        //                 "lever" => "75",
        //                 "liqPx" => "0.00001",
        //                 "useMargin" => "0.049088",
        //                 "mrgPosition" => "merge",
        //                 "ccy" => "USDT",
        //                 "uTime" => "1760709419000",
        //                 "cTime" => "1760709419000"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_positions($data, $symbols);
    }

    public function parse_position(array $position, ?array $market = null): array {
        //
        //     {
        //         "instType" => "SWAP",
        //         "mgnMode" => "cross",
        //         "instId" => "DOGE-USDT-SWAP",
        //         "posId" => "1001110099878275",
        //         "posSide" => "long",
        //         "pos" => "20",
        //         "avgPx" => "0.18408",
        //         "lever" => "75",
        //         "liqPx" => "0.00001",
        //         "useMargin" => "0.049088",
        //         "mrgPosition" => "merge",
        //         "ccy" => "USDT",
        //         "uTime" => "1760709419000",
        //         "cTime" => "1760709419000"
        //     }
        //
        $marketId = $this->safe_string($position, 'instId');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($position, 'cTime');
        return $this->safe_position(array(
            'symbol' => $market['symbol'],
            'id' => $this->safe_string($position, 'posId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'contracts' => $this->safe_string($position, 'pos'),
            'contractSize' => null,
            'side' => $this->safe_string($position, 'posSide'),
            'notional' => null,
            'leverage' => $this->omit_zero($this->safe_string($position, 'lever')),
            'unrealizedPnl' => null,
            'realizedPnl' => null,
            'collateral' => null,
            'entryPrice' => $this->safe_string($position, 'avgPx'),
            'markPrice' => null,
            'liquidationPrice' => $this->safe_string($position, 'liqPx'),
            'marginMode' => $this->safe_string($position, 'mgnMode'),
            'hedged' => true,
            'maintenanceMargin' => $this->safe_string($position, 'useMargin'),
            'maintenanceMarginPercentage' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'marginRatio' => null,
            'lastUpdateTimestamp' => $this->safe_integer($position, 'uTime'),
            'lastPrice' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
            'percentage' => null,
            'info' => $position,
        ));
    }

    public function set_leverage(int $leverage, ?string $symbol = null, $params = array ()) {
        /**
         * set the level of $leverage for a $market
         *
         * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountSetLeverage
         *
         * @param {float} $leverage the rate of $leverage
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->marginMode] 'cross' or 'isolated' (default is cross)
         * @param {string} [$params->mrgPosition] 'merge' or 'split', default is merge
         * @return {array} $response from the exchange
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        // WARNING => THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if ($leverage < 1) {
            throw new BadRequest($this->id . ' setLeverage() $leverage should be minimum 1');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $marginMode = 'cross';
        list($marginMode, $params) = $this->handle_margin_mode_and_params('setLeverage', $params, $marginMode);
        if (($marginMode !== 'cross') && ($marginMode !== 'isolated')) {
            throw new BadRequest($this->id . ' setLeverage() requires a $marginMode parameter that must be either cross or isolated');
        }
        $mrgPosition = 'merge';
        list($mrgPosition, $params) = $this->handle_option_and_params($params, 'setLeverage', 'mrgPosition', $mrgPosition);
        if ($mrgPosition !== 'merge' && $mrgPosition !== 'split') {
            throw new BadRequest($this->id . ' setLeverage() $mrgPosition parameter must be either merge or split');
        }
        $request = array(
            'lever' => $leverage,
            'mgnMode' => $marginMode,
            'instId' => $market['id'],
            'mrgPosition' => $mrgPosition,
        );
        $response = $this->privatePostDeepcoinAccountSetLeverage ($this->extend($request, $params));
        //
        //     {
        //         code => '0',
        //         msg => '',
        //         data => {
        //             instId => 'ETH-USDT-SWAP',
        //             lever => '2',
        //             mgnMode => 'cross',
        //             $mrgPosition => 'merge',
        //             sCode => '0',
        //             sMsg => ''
        //         }
        //     }
        //
        return $response;
    }

    public function fetch_funding_rates(?array $symbols = null, $params = array ()): array {
        /**
         * fetch the funding rate for multiple markets
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/currentFundRate
         *
         * @param {string[]|null} $symbols list of unified market $symbols
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->subType] "linear" or "inverse"
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=funding-$rates-structure funding rate structures~, indexed by market $symbols
         */
        $this->load_markets();
        $symbols = $this->market_symbols($symbols, 'swap', true, true, true);
        $subType = 'linear';
        $firstMarket = null;
        if ($symbols !== null) {
            $firstSymbol = $this->safe_string($symbols, 0);
            $firstMarket = $this->market($firstSymbol);
        }
        list($subType, $params) = $this->handle_sub_type_and_params('fetchFundingRates', $firstMarket, $params, $subType);
        $instType = 'SwapU';
        if ($subType === 'inverse') {
            $instType = 'Swap';
        } elseif ($subType !== 'linear') {
            throw new BadRequest($this->id . ' fetchFundingRates() $subType parameter must be either linear or inverse');
        }
        $request = array(
            'instType' => $instType,
        );
        $response = $this->publicGetDeepcoinTradeFundRateCurrentFundingRate ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => {
        //             "current_fund_rates" => array(
        //                 array(
        //                     "instrumentId" => "SPKUSDT",
        //                     "fundingRate" => 0.00005
        //                 ),
        //                 {
        //                     "instrumentId" => "LAUNCHCOINUSDT",
        //                     "fundingRate" => 0.00005
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $rates = $this->safe_list($data, 'current_fund_rates', array());
        return $this->parse_funding_rates($rates, $symbols);
    }

    public function fetch_funding_rate(string $symbol, $params = array ()): array {
        /**
         * fetch the current funding rate
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/currentFundRate
         *
         * @param {string} $symbol unified $market $symbol
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @return {array} a ~@link https://docs.ccxt.com/?id=funding-rate-structure funding rate structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new ExchangeError($this->id . ' fetchFundingRate() is only valid for swap markets');
        }
        $request = array(
            'instId' => $market['id'],
            'instType' => $this->get_product_group_from_market($market),
        );
        $response = $this->publicGetDeepcoinTradeFundRateCurrentFundingRate ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => {
        //             "current_fund_rates" => array(
        //                 {
        //                     "instrumentId" => "ETHUSDT",
        //                     "fundingRate" => 0.0000402356250176
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $rates = $this->safe_list($data, 'current_fund_rates', array());
        $entry = $this->safe_dict($rates, 0, array());
        return $this->parse_funding_rate($entry, $market);
    }

    public function parse_funding_rate($contract, ?array $market = null): array {
        //
        //     {
        //         "instrumentId" => "ETHUSDT",
        //         "fundingRate" => 0.0000402356250176
        //     }
        //
        $marketId = $this->safe_string_2($contract, 'instrumentId', 'instrumentID');
        $symbol = $this->safe_symbol($marketId, $market);
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $this->safe_number($contract, 'fundingRate'),
            'fundingTimestamp' => null,
            'fundingDatetime' => null,
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
            'interval' => null,
        );
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetches historical funding rate prices
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/fundingRateHistory
         *
         * @param {string} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int} [$since] timestamp in ms of the earliest funding rate to fetch
         * @param {int} [$limit] the maximum amount of ~@link https://docs.ccxt.com/?id=funding-rate-history-structure funding rate structures~ to fetch
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->page] pagination page number
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?id=funding-rate-history-structure funding rate structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
        );
        if ($limit !== null) {
            $request['size'] = $limit; // default 20, max 100
        }
        $response = $this->publicGetDeepcoinTradeFundRateHistory ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => {
        //             "rows" => array(
        //                 array(
        //                     "instrumentID" => "ETHUSD",
        //                     "rate" => "0.00046493",
        //                     "CreateTime" => 1760860800,
        //                     "ratePeriodSec" => 0
        //                 ),
        //                 {
        //                     "instrumentID" => "ETHUSD",
        //                     "rate" => "0.00047949",
        //                     "CreateTime" => 1760832000,
        //                     "ratePeriodSec" => 0
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_dict($response, 'data', array());
        $rows = $this->safe_list($data, 'rows', array());
        return $this->parse_funding_rate_histories($rows, $market, $since, $limit);
    }

    public function parse_funding_rate_history($info, ?array $market = null) {
        //
        //     {
        //         "instrumentID" => "ETHUSD",
        //         "rate" => "0.00047949",
        //         "CreateTime" => 1760832000,
        //         "ratePeriodSec" => 0
        //     }
        //
        $timestamp = $this->safe_timestamp($info, 'CreateTime');
        $instrumentID = $this->safe_string_2($info, 'instrumentID', 'instrumentId');
        $market = $this->safe_market($instrumentID, $market, null, 'swap');
        return array(
            'info' => $info,
            'symbol' => $market['symbol'],
            'fundingRate' => $this->safe_number($info, 'rate'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all trades made by the user
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/tradeFills
         *
         * @param {string} $symbol unified $market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades structures to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {int} [$params->until] timestamp in ms of the latest trade to fetch
         * @param {string} [$params->type] 'spot' or 'swap', the $market type for the trades (default is 'spot')
         * @param {boolean} [$params->paginate] default false, when true will automatically $paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-$params)
         * @return {Trade[]} a list of ~@link https://docs.ccxt.com/?id=trade-structure trade structures~
         */
        $this->load_markets();
        $paginate = false;
        list($paginate, $params) = $this->handle_option_and_params($params, 'fetchMyTrades', 'paginate');
        if ($paginate) {
            return $this->fetch_paginated_call_dynamic('fetchMyTrades', $symbol, $since, $limit, $params);
        }
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $marketType = 'spot';
        list($marketType, $params) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params, $marketType);
        $request = array(
            'instType' => $this->convert_to_instrument_type($marketType),
        );
        if ($market !== null) {
            $request['instId'] = $market['id'];
        }
        if ($since !== null) {
            $request['begin'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $until = $this->safe_integer($params, 'until');
        if ($until !== null) {
            $params = $this->omit($params, 'until');
            $request['end'] = $until;
        }
        $response = $this->privateGetDeepcoinTradeFills ($this->extend($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "instType" => "SPOT",
        //                 "instId" => "ETH-USDT",
        //                 "tradeId" => "1001056429613610",
        //                 "ordId" => "1001435238208686",
        //                 "clOrdId" => "",
        //                 "billId" => "10010564296136101",
        //                 "tag" => "",
        //                 "fillPx" => "3791.15",
        //                 "fillSz" => "0.004",
        //                 "side" => "sell",
        //                 "posSide" => "",
        //                 "execType" => "",
        //                 "feeCcy" => "USDT",
        //                 "fee" => "0.0151646",
        //                 "ts" => "1760704540000"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function fetch_order_trades(string $id, ?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()) {
        /**
         * fetch all the trades made from a single order
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/tradeFills
         *
         * @param {string} $id order $id
         * @param {string} $symbol unified market $symbol
         * @param {int} [$since] the earliest time in ms to fetch trades for
         * @param {int} [$limit] the maximum number of trades to retrieve
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string} [$params->type] 'spot' or 'swap', the market type for the trades
         * @return {array[]} a list of ~@link https://docs.ccxt.com/?$id=trade-structure trade structures~
         */
        $this->load_markets();
        $marketType = $this->safe_string($params, 'type');
        if ($symbol === null && $marketType === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrderTrades requires a $symbol argument or a market type in the params');
        }
        $params = $this->extend(array( 'ordId' => $id ), $params);
        return $this->fetch_my_trades($symbol, $since, $limit, $params);
    }

    public function close_position(string $symbol, ?string $side = null, $params = array ()): array {
        /**
         * closes open positions for a $market
         *
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/batchClosePosition
         * @see https://www.deepcoin.com/docs/DeepCoinTrade/closePositionByIds
         *
         * @param {string} $symbol Unified CCXT $market $symbol
         * @param {string} [$side] not used by deepcoin
         * @param {array} [$params] extra parameters specific to the exchange API endpoint
         * @param {string|null} [$params->positionId] the id of the position you would like to close
         * @param {string[]|null} [$params->positionIds] list of position ids to close (for batch closing)
         * @return {array} an ~@link https://docs.ccxt.com/?id=order-structure order structure~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $productGroup = $this->get_product_group_from_market($market);
        $positionId = $this->safe_string($params, 'positionId');
        $positionIds = $this->safe_list($params, 'positionIds');
        $request = array(
            'instId' => $market['id'],
            'productGroup' => $productGroup,
        );
        $response = null;
        if ($positionId === null && $positionIds === null) {
            $response = $this->privatePostDeepcoinTradeBatchClosePosition ($this->extend($request, $params));
        } else {
            if ($positionId !== null) {
                $params = $this->omit($params, 'positionId');
                $request['positionIds'] = array( $positionId );
            }
            $response = $this->privatePostDeepcoinTradeClosePositionByIds ($this->extend($request, $params));
        }
        $data = $this->safe_list($response, 'data', array());
        return $this->parse_order($data, $market);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $requestPath = $path;
        if ($method === 'GET') {
            $query = $this->urlencode($params);
            if (strlen($query)) {
                $requestPath .= '?' . $query;
            }
        }
        $url = $this->urls['api'][$api] . '/' . $requestPath;
        if ($api === 'private') {
            $this->check_required_credentials();
            $timestamp = $this->milliseconds();
            $dateTime = $this->iso8601($timestamp);
            $payload = $dateTime . $method . '/' . $requestPath;
            $headers = array(
                'DC-ACCESS-KEY' => $this->apiKey,
                'DC-ACCESS-TIMESTAMP' => $dateTime,
                'DC-ACCESS-PASSPHRASE' => $this->password,
                'appid' => '200103',
            );
            if ($method !== 'GET') {
                $body = $this->json($params);
                $headers['Content-Type'] = 'application/json';
                $payload .= $body;
            }
            $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'base64');
            $headers['DC-ACCESS-SIGN'] = $signature;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors(int $code, string $reason, string $url, string $method, array $headers, string $body, $response, $requestHeaders, $requestBody) {
        $data = $this->safe_dict($response, 'data', array());
        $msg = $this->safe_string($response, 'msg');
        $messageCode = $this->safe_string($response, 'code');
        $sCode = $this->safe_string($data, 'sCode');
        $sMsg = $this->safe_string($data, 'sMsg');
        $errorCode = $this->safe_string($data, 'errorCode');
        if (($msg !== null) && ($msg === '') && ($sMsg !== null)) {
            $msg = $sMsg;
        }
        $errorList = $this->safe_list($data, 'errorList');
        if ($errorList !== null) {
            for ($i = 0; $i < count($errorList); $i++) {
                $entry = $this->safe_dict($errorList, $i, array());
                $errorCode = $this->safe_string($entry, 'errorCode');
            }
        }
        $feedback = $this->id . ' ' . $body;
        if (($sCode === null) && ($errorCode !== null)) {
            $sCode = $errorCode;
        }
        $retCode = $this->safe_string($data, 'retCode');
        if (($sCode === null) && ($retCode !== null)) {
            $sCode = $retCode;
        }
        if (($code !== 200) || ($messageCode !== '0') || ($sCode !== null && $sCode !== '0')) {
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $messageCode, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $sCode, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $msg, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $msg, $feedback);
            throw new ExchangeError($feedback);
        } else {
            $list = $this->safe_list($data, 'list', array());
            if ((is_array($data) && array_key_exists('list', $data)) && ($list === null)) {
                throw new NullResponse($feedback);
            }
        }
        return null;
    }
}
