<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class bitfinex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bitfinex',
            'name' => 'Bitfinex',
            'countries' => array( 'VG' ),
            'version' => 'v1',
            // cheapest is 90 requests a minute = 1.5 requests per second on average => ( 1000ms / 1.5) = 666.666 ms between requests on average
            'rateLimit' => 666.666,
            'pro' => true,
            // new metainfo interface
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null, // has but unimplemented
                'swap' => null, // has but unimplemented
                'future' => null,
                'option' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createDepositAddress' => true,
                'createOrder' => true,
                'editOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => null,
                'fetchIndexOHLCV' => false,
                'fetchLeverageTiers' => false,
                'fetchMarginMode' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchPositionMode' => false,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => true,
                'fetchTransactionFees' => true,
                'fetchTransactions' => true,
                'fetchWithdrawals' => null,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '3h' => '3h',
                '4h' => '4h',
                '6h' => '6h',
                '12h' => '12h',
                '1d' => '1D',
                '1w' => '7D',
                '2w' => '14D',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                'api' => array(
                    'v2' => 'https://api-pub.bitfinex.com', // https://github.com/ccxt/ccxt/issues/5109
                    'public' => 'https://api.bitfinex.com',
                    'private' => 'https://api.bitfinex.com',
                ),
                'www' => 'https://www.bitfinex.com',
                'referral' => 'https://www.bitfinex.com/?refcode=P61eYxFL',
                'doc' => array(
                    'https://docs.bitfinex.com/v1/docs',
                    'https://github.com/bitfinexcom/bitfinex-api-node',
                ),
            ),
            'api' => array(
                // v2 symbol ids require a 't' prefix
                // just the public part of it (use bitfinex2 for everything else)
                'v2' => array(
                    'get' => array(
                        'platform/status' => 3, // 30 requests per minute
                        'tickers' => 1, // 90 requests a minute
                        'ticker/{symbol}' => 1,
                        'tickers/hist' => 1,
                        'trades/{symbol}/hist' => 1,
                        'book/{symbol}/{precision}' => 0.375, // 240 requests per minute = 4 requests per second (1000ms / rateLimit) / 4  = 0.37500375
                        'book/{symbol}/P0' => 0.375,
                        'book/{symbol}/P1' => 0.375,
                        'book/{symbol}/P2' => 0.375,
                        'book/{symbol}/P3' => 0.375,
                        'book/{symbol}/R0' => 0.375,
                        'stats1/{key}:{size}:{symbol}:{side}/{section}' => 1, // 90 requests a minute
                        'stats1/{key}:{size}:{symbol}/{section}' => 1,
                        'stats1/{key}:{size}:{symbol}:long/last' => 1,
                        'stats1/{key}:{size}:{symbol}:long/hist' => 1,
                        'stats1/{key}:{size}:{symbol}:short/last' => 1,
                        'stats1/{key}:{size}:{symbol}:short/hist' => 1,
                        'candles/trade:{timeframe}:{symbol}/{section}' => 1, // 90 requests a minute
                        'candles/trade:{timeframe}:{symbol}/last' => 1,
                        'candles/trade:{timeframe}:{symbol}/hist' => 1,
                    ),
                ),
                'public' => array(
                    'get' => array(
                        'book/{symbol}' => 1, // 90 requests a minute
                        // 'candles/{symbol}':0,
                        'lendbook/{currency}' => 6, // 15 requests a minute
                        'lends/{currency}' => 3, // 30 requests a minute
                        'pubticker/{symbol}' => 3, // 30 requests a minute = 0.5 requests per second => (1000ms / rateLimit) / 0.5 = 3.00003
                        'stats/{symbol}' => 6, // 15 requests a minute = 0.25 requests per second => (1000ms / rateLimit ) /0.25 = 6.00006 (endpoint returns red html... or 'unknown symbol')
                        'symbols' => 18, // 5 requests a minute = 0.08333 requests per second => (1000ms / rateLimit) / 0.08333 = 18.0009
                        'symbols_details' => 18, // 5 requests a minute
                        'tickers' => 1, // endpoint not mentioned in v1 docs... but still responds
                        'trades/{symbol}' => 3, // 60 requests a minute = 1 request per second => (1000ms / rateLimit) / 1 = 1.5 ... but only works if set to 3
                    ),
                ),
                'private' => array(
                    'post' => array(
                        'account_fees' => 18,
                        'account_infos' => 6,
                        'balances' => 9.036, // 10 requests a minute = 0.166 requests per second => (1000ms / rateLimit) / 0.166 = 9.036
                        'basket_manage' => 6,
                        'credits' => 6,
                        'deposit/new' => 18,
                        'funding/close' => 6,
                        'history' => 6, // 15 requests a minute
                        'history/movements' => 6,
                        'key_info' => 6,
                        'margin_infos' => 3, // 30 requests a minute
                        'mytrades' => 3,
                        'mytrades_funding' => 6,
                        'offer/cancel' => 6,
                        'offer/new' => 6,
                        'offer/status' => 6,
                        'offers' => 6,
                        'offers/hist' => 90.03, // one request per minute
                        'order/cancel' => 0.2,
                        'order/cancel/all' => 0.2,
                        'order/cancel/multi' => 0.2,
                        'order/cancel/replace' => 0.2,
                        'order/new' => 0.2, // 450 requests a minute = 7.5 request a second => (1000ms / rateLimit) / 7.5 = 0.2000002
                        'order/new/multi' => 0.2,
                        'order/status' => 0.2,
                        'orders' => 0.2,
                        'orders/hist' => 90.03, // one request per minute = 0.1666 => (1000ms /  rateLimit) / 0.01666 = 90.03
                        'position/claim' => 18,
                        'position/close' => 18,
                        'positions' => 18,
                        'summary' => 18,
                        'taken_funds' => 6,
                        'total_taken_funds' => 6,
                        'transfer' => 18,
                        'unused_taken_funds' => 6,
                        'withdraw' => 18,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => true,
                    'percentage' => true,
                    'maker' => $this->parse_number('0.001'),
                    'taker' => $this->parse_number('0.002'),
                    'tiers' => array(
                        'taker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.002') ),
                            array( $this->parse_number('500000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('2500000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('7500000'), $this->parse_number('0.002') ),
                            array( $this->parse_number('10000000'), $this->parse_number('0.0018') ),
                            array( $this->parse_number('15000000'), $this->parse_number('0.0016') ),
                            array( $this->parse_number('20000000'), $this->parse_number('0.0014') ),
                            array( $this->parse_number('25000000'), $this->parse_number('0.0012') ),
                            array( $this->parse_number('30000000'), $this->parse_number('0.001') ),
                        ),
                        'maker' => array(
                            array( $this->parse_number('0'), $this->parse_number('0.001') ),
                            array( $this->parse_number('500000'), $this->parse_number('0.0008') ),
                            array( $this->parse_number('1000000'), $this->parse_number('0.0006') ),
                            array( $this->parse_number('2500000'), $this->parse_number('0.0004') ),
                            array( $this->parse_number('5000000'), $this->parse_number('0.0002') ),
                            array( $this->parse_number('7500000'), $this->parse_number('0') ),
                            array( $this->parse_number('10000000'), $this->parse_number('0') ),
                            array( $this->parse_number('15000000'), $this->parse_number('0') ),
                            array( $this->parse_number('20000000'), $this->parse_number('0') ),
                            array( $this->parse_number('25000000'), $this->parse_number('0') ),
                            array( $this->parse_number('30000000'), $this->parse_number('0') ),
                        ),
                    ),
                ),
                'funding' => array(
                    'tierBased' => false, // true for tier-based/progressive
                    'percentage' => false, // fixed commission
                    // Actually deposit fees are free for larger deposits (> $1000 USD equivalent)
                    // these values below are deprecated, we should not hardcode fees and limits anymore
                    // to be reimplemented with bitfinex funding fees from their API or web endpoints
                    'deposit' => array(),
                    'withdraw' => array(),
                ),
            ),
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            'commonCurrencies' => array(
                'ALG' => 'ALGO', // https://github.com/ccxt/ccxt/issues/6034
                'AMP' => 'AMPL',
                'ATO' => 'ATOM', // https://github.com/ccxt/ccxt/issues/5118
                'BCHABC' => 'XEC',
                'BCHN' => 'BCH',
                'DAT' => 'DATA',
                'DOG' => 'MDOGE',
                'DSH' => 'DASH',
                // https://github.com/ccxt/ccxt/issues/7399
                // https://coinmarketcap.com/currencies/pnetwork/
                // https://en.cryptonomist.ch/blog/eidoo/the-edo-to-pnt-upgrade-what-you-need-to-know-updated/
                'EDO' => 'PNT',
                'EUS' => 'EURS',
                'EUT' => 'EURT',
                'IDX' => 'ID',
                'IOT' => 'IOTA',
                'IQX' => 'IQ',
                'LUNA' => 'LUNC',
                'LUNA2' => 'LUNA',
                'MNA' => 'MANA',
                'ORS' => 'ORS Group', // conflict with Origin Sport #3230
                'PAS' => 'PASS',
                'QSH' => 'QASH',
                'QTM' => 'QTUM',
                'RBT' => 'RBTC',
                'SNG' => 'SNGLS',
                'STJ' => 'STORJ',
                'TERRAUST' => 'USTC',
                'TSD' => 'TUSD',
                'YGG' => 'YEED', // conflict with Yield Guild Games
                'YYW' => 'YOYOW',
                'UDC' => 'USDC',
                'UST' => 'USDT',
                'VSY' => 'VSYS',
                'WAX' => 'WAXP',
                'XCH' => 'XCHF',
                'ZBT' => 'ZB',
            ),
            'exceptions' => array(
                'exact' => array(
                    'temporarily_unavailable' => '\\ccxt\\ExchangeNotAvailable', // Sorry, the service is temporarily unavailable. See https://www.bitfinex.com/ for more info.
                    'Order could not be cancelled.' => '\\ccxt\\OrderNotFound', // non-existent order
                    'No such order found.' => '\\ccxt\\OrderNotFound', // ?
                    'Order price must be positive.' => '\\ccxt\\InvalidOrder', // on price <= 0
                    'Could not find a key matching the given X-BFX-APIKEY.' => '\\ccxt\\AuthenticationError',
                    'Key price should be a decimal number, e.g. "123.456"' => '\\ccxt\\InvalidOrder', // on isNaN (price)
                    'Key amount should be a decimal number, e.g. "123.456"' => '\\ccxt\\InvalidOrder', // on isNaN (amount)
                    'ERR_RATE_LIMIT' => '\\ccxt\\RateLimitExceeded',
                    'Ratelimit' => '\\ccxt\\RateLimitExceeded',
                    'Nonce is too small.' => '\\ccxt\\InvalidNonce',
                    'No summary found.' => '\\ccxt\\ExchangeError', // fetchTradingFees (summary) endpoint can give this vague error message
                    'Cannot evaluate your available balance, please try again' => '\\ccxt\\ExchangeNotAvailable',
                    'Unknown symbol' => '\\ccxt\\BadSymbol',
                    'Cannot complete transfer. Exchange balance insufficient.' => '\\ccxt\\InsufficientFunds',
                    'Momentary balance check. Please wait few seconds and try the transfer again.' => '\\ccxt\\ExchangeError',
                ),
                'broad' => array(
                    'Invalid X-BFX-SIGNATURE' => '\\ccxt\\AuthenticationError',
                    'This API key does not have permission' => '\\ccxt\\PermissionDenied', // authenticated but not authorized
                    'not enough exchange balance for ' => '\\ccxt\\InsufficientFunds', // when buying cost is greater than the available quote currency
                    'minimum size for ' => '\\ccxt\\InvalidOrder', // when amount below limits.amount.min
                    'Invalid order' => '\\ccxt\\InvalidOrder', // ?
                    'The available balance is only' => '\\ccxt\\InsufficientFunds', // array("status":"error","message":"Cannot withdraw 1.0027 ETH from your exchange wallet. The available balance is only 0.0 ETH. If you have limit orders, open positions, unused or active margin funding, this will decrease your available balance. To increase it, you can cancel limit orders or reduce/close your positions.","withdrawal_id":0,"fees":"0.0027")
                ),
            ),
            'precisionMode' => SIGNIFICANT_DIGITS,
            'options' => array(
                'currencyNames' => array(
                    'AGI' => 'agi',
                    'AID' => 'aid',
                    'AIO' => 'aio',
                    'ANT' => 'ant',
                    'AVT' => 'aventus', // #1811
                    'BAT' => 'bat',
                    // https://github.com/ccxt/ccxt/issues/5833
                    'BCH' => 'bab', // undocumented
                    // 'BCH' => 'bcash', // undocumented
                    'BCI' => 'bci',
                    'BFT' => 'bft',
                    'BSV' => 'bsv',
                    'BTC' => 'bitcoin',
                    'BTG' => 'bgold',
                    'CFI' => 'cfi',
                    'COMP' => 'comp',
                    'DAI' => 'dai',
                    'DADI' => 'dad',
                    'DASH' => 'dash',
                    'DATA' => 'datacoin',
                    'DTH' => 'dth',
                    'EDO' => 'eidoo', // #1811
                    'ELF' => 'elf',
                    'EOS' => 'eos',
                    'ETC' => 'ethereumc',
                    'ETH' => 'ethereum',
                    'ETP' => 'metaverse',
                    'FUN' => 'fun',
                    'GNT' => 'golem',
                    'IOST' => 'ios',
                    'IOTA' => 'iota',
                    // https://github.com/ccxt/ccxt/issues/5833
                    'LEO' => 'let', // ETH chain
                    // 'LEO' => 'les', // EOS chain
                    'LINK' => 'link',
                    'LRC' => 'lrc',
                    'LTC' => 'litecoin',
                    'LYM' => 'lym',
                    'MANA' => 'mna',
                    'MIT' => 'mit',
                    'MKR' => 'mkr',
                    'MTN' => 'mtn',
                    'NEO' => 'neo',
                    'ODE' => 'ode',
                    'OMG' => 'omisego',
                    'OMNI' => 'mastercoin',
                    'QASH' => 'qash',
                    'QTUM' => 'qtum', // #1811
                    'RCN' => 'rcn',
                    'RDN' => 'rdn',
                    'REP' => 'rep',
                    'REQ' => 'req',
                    'RLC' => 'rlc',
                    'SAN' => 'santiment',
                    'SNGLS' => 'sng',
                    'SNT' => 'status',
                    'SPANK' => 'spk',
                    'STORJ' => 'stj',
                    'TNB' => 'tnb',
                    'TRX' => 'trx',
                    'TUSD' => 'tsd',
                    'USD' => 'wire',
                    'USDC' => 'udc', // https://github.com/ccxt/ccxt/issues/5833
                    'UTK' => 'utk',
                    'USDT' => 'tetheruso', // Tether on Omni
                    // 'USDT' => 'tetheruse', // Tether on ERC20
                    // 'USDT' => 'tetherusl', // Tether on Liquid
                    // 'USDT' => 'tetherusx', // Tether on Tron
                    // 'USDT' => 'tetheruss', // Tether on EOS
                    'VEE' => 'vee',
                    'WAX' => 'wax',
                    'XLM' => 'xlm',
                    'XMR' => 'monero',
                    'XRP' => 'ripple',
                    'XVG' => 'xvg',
                    'YOYOW' => 'yoyow',
                    'ZEC' => 'zcash',
                    'ZRX' => 'zrx',
                    'XTZ' => 'xtz',
                ),
                'orderTypes' => array(
                    'limit' => 'exchange limit',
                    'market' => 'exchange market',
                ),
                'fiat' => array(
                    'USD' => 'USD',
                    'EUR' => 'EUR',
                    'JPY' => 'JPY',
                    'GBP' => 'GBP',
                    'CNH' => 'CNH',
                ),
                'accountsByType' => array(
                    'spot' => 'exchange',
                    'margin' => 'trading',
                    'funding' => 'deposit',
                    'swap' => 'trading',
                ),
            ),
        ));
    }

    public function fetch_transaction_fees($codes = null, $params = array ()) {
        /**
         * fetch transaction $fees
         * @see https://docs.bitfinex.com/v1/reference/rest-auth-$fees
         * @param {[string]|null} $codes list of unified currency $codes
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure $fees structures}
         */
        $this->load_markets();
        $result = array();
        $response = $this->privatePostAccountFees ($params);
        //
        // {
        //     'withdraw' => {
        //         'BTC' => '0.0004',
        //     }
        // }
        //
        $fees = $this->safe_value($response, 'withdraw');
        $ids = is_array($fees) ? array_keys($fees) : array();
        for ($i = 0; $i < count($ids); $i++) {
            $id = $ids[$i];
            $code = $this->safe_currency_code($id);
            if (($codes !== null) && !$this->in_array($code, $codes)) {
                continue;
            }
            $result[$code] = array(
                'withdraw' => $this->safe_number($fees, $id),
                'deposit' => array(),
                'info' => $this->safe_number($fees, $id),
            );
        }
        return $result;
    }

    public function fetch_trading_fees($params = array ()) {
        /**
         * fetch the trading fees for multiple markets
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#$fee-structure $fee structures} indexed by $market symbols
         */
        $this->load_markets();
        $response = $this->privatePostSummary ($params);
        //
        //     {
        //          time => '2022-02-23T16:05:47.659000Z',
        //          status => array( resid_hint => null, login_last => '2022-02-23T16:05:48Z' ),
        //          is_locked => false,
        //          leo_lev => '0',
        //          leo_amount_avg => '0.0',
        //          trade_vol_30d => array(
        //          {
        //              curr => 'Total (USD)',
        //              vol => '0.0',
        //              vol_safe => '0.0',
        //              vol_maker => '0.0',
        //              vol_BFX => '0.0',
        //              vol_BFX_safe => '0.0',
        //              vol_BFX_maker => '0.0'
        //          }
        //          ),
        //          fees_funding_30d => array(),
        //          fees_funding_total_30d => '0',
        //          fees_trading_30d => array(),
        //          fees_trading_total_30d => '0',
        //          rebates_trading_30d => array(),
        //          rebates_trading_total_30d => '0',
        //          maker_fee => '0.001',
        //          taker_fee => '0.002',
        //          maker_fee_2crypto => '0.001',
        //          maker_fee_2stablecoin => '0.001',
        //          maker_fee_2fiat => '0.001',
        //          maker_fee_2deriv => '0.0002',
        //          taker_fee_2crypto => '0.002',
        //          taker_fee_2stablecoin => '0.002',
        //          taker_fee_2fiat => '0.002',
        //          taker_fee_2deriv => '0.00065',
        //          deriv_maker_rebate => '0.0002',
        //          deriv_taker_fee => '0.00065',
        //          trade_last => null
        //     }
        //
        $result = array();
        $fiat = $this->safe_value($this->options, 'fiat', array());
        $makerFee = $this->safe_number($response, 'maker_fee');
        $takerFee = $this->safe_number($response, 'taker_fee');
        $makerFee2Fiat = $this->safe_number($response, 'maker_fee_2fiat');
        $takerFee2Fiat = $this->safe_number($response, 'taker_fee_2fiat');
        $makerFee2Deriv = $this->safe_number($response, 'maker_fee_2deriv');
        $takerFee2Deriv = $this->safe_number($response, 'taker_fee_2deriv');
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $market = $this->market($symbol);
            $fee = array(
                'info' => $response,
                'symbol' => $symbol,
                'percentage' => true,
                'tierBased' => true,
            );
            if (is_array($fiat) && array_key_exists($market['quote'], $fiat)) {
                $fee['maker'] = $makerFee2Fiat;
                $fee['taker'] = $takerFee2Fiat;
            } elseif ($market['contract']) {
                $fee['maker'] = $makerFee2Deriv;
                $fee['taker'] = $takerFee2Deriv;
            } else {
                $fee['maker'] = $makerFee;
                $fee['taker'] = $takerFee;
            }
            $result[$symbol] = $fee;
        }
        return $result;
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all markets for bitfinex
         * @param {array} $params extra parameters specific to the exchange api endpoint
         * @return {[array]} an array of objects representing $market data
         */
        $ids = $this->publicGetSymbols ();
        //
        //     array( "btcusd", "ltcusd", "ltcbtc" )
        //
        $details = $this->publicGetSymbolsDetails ();
        //
        //     array(
        //         array(
        //             "pair":"btcusd",
        //             "price_precision":5,
        //             "initial_margin":"10.0",
        //             "minimum_margin":"5.0",
        //             "maximum_order_size":"2000.0",
        //             "minimum_order_size":"0.0002",
        //             "expiration":"NA",
        //             "margin":true
        //         ),
        //     )
        //
        $result = array();
        for ($i = 0; $i < count($details); $i++) {
            $market = $details[$i];
            $id = $this->safe_string($market, 'pair');
            if (!$this->in_array($id, $ids)) {
                continue;
            }
            $id = strtoupper($id);
            $baseId = null;
            $quoteId = null;
            if (mb_strpos($id, ':') !== false) {
                $parts = explode(':', $id);
                $baseId = $parts[0];
                $quoteId = $parts[1];
            } else {
                $baseId = mb_substr($id, 0, 3 - 0);
                $quoteId = mb_substr($id, 3, 6 - 3);
            }
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $result[] = array(
                'id' => $id,
                'symbol' => $base . '/' . $quote,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => $this->safe_value($market, 'margin'),
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => true,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    // https://docs.bitfinex.com/docs/introduction#amount-precision
                    // The amount field allows up to 8 decimals.
                    // Anything exceeding this will be rounded to the 8th decimal.
                    'amount' => intval('8'),
                    'price' => $this->safe_integer($market, 'price_precision'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minimum_order_size'),
                        'max' => $this->safe_number($market, 'maximum_order_size'),
                    ),
                    'price' => array(
                        'min' => $this->parse_number('1e-8'),
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function amount_to_precision($symbol, $amount) {
        // https://docs.bitfinex.com/docs/introduction#$amount-precision
        // The $amount field allows up to 8 decimals.
        // Anything exceeding this will be rounded to the 8th decimal.
        return $this->decimal_to_precision($amount, TRUNCATE, $this->markets[$symbol]['precision']['amount'], DECIMAL_PLACES);
    }

    public function price_to_precision($symbol, $price) {
        $price = $this->decimal_to_precision($price, ROUND, $this->markets[$symbol]['precision']['price'], $this->precisionMode);
        // https://docs.bitfinex.com/docs/introduction#$price-precision
        // The precision level of all trading prices is based on significant figures.
        // All pairs on Bitfinex use up to 5 significant digits and up to 8 decimals (e.g. 1.2345, 123.45, 1234.5, 0.00012345).
        // Prices submit with a precision larger than 5 will be cut by the API.
        return $this->decimal_to_precision($price, TRUNCATE, 8, DECIMAL_PLACES);
    }

    public function fetch_balance($params = array ()) {
        /**
         * $query for $balance and get the amount of funds available for trading or funds locked in orders
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#$balance-structure $balance structure~
         */
        $this->load_markets();
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $requestedType = $this->safe_string($params, 'type', 'exchange');
        $accountType = $this->safe_string($accountsByType, $requestedType, $requestedType);
        if ($accountType === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' fetchBalance() $type parameter must be one of ' . implode(', ', $keys));
        }
        $query = $this->omit($params, 'type');
        $response = $this->privatePostBalances ($query);
        //    array( array( $type => 'deposit',
        //        currency => 'btc',
        //        amount => '0.00116721',
        //        available => '0.00116721' ),
        //      array( $type => 'exchange',
        //        currency => 'ust',
        //        amount => '0.0000002',
        //        available => '0.0000002' ),
        //      { $type => 'trading',
        //        currency => 'btc',
        //        amount => '0.0005',
        //        available => '0.0005' } ),
        $result = array( 'info' => $response );
        $isDerivative = $requestedType === 'derivatives';
        for ($i = 0; $i < count($response); $i++) {
            $balance = $response[$i];
            $type = $this->safe_string($balance, 'type');
            $currencyId = $this->safe_string_lower($balance, 'currency', '');
            $start = strlen($currencyId) - 2;
            $isDerivativeCode = mb_substr($currencyId, $start) === 'f0';
            // this will only filter the derivative codes if the $requestedType is 'derivatives'
            $derivativeCondition = (!$isDerivative || $isDerivativeCode);
            if (($accountType === $type) && $derivativeCondition) {
                $code = $this->safe_currency_code($currencyId);
                // bitfinex had BCH previously, now it's BAB, but the old
                // BCH symbol is kept for backward-compatibility
                // we need a workaround here so that the old BCH $balance
                // would not override the new BAB $balance (BAB is unified to BCH)
                // https://github.com/ccxt/ccxt/issues/4989
                if (!(is_array($result) && array_key_exists($code, $result))) {
                    $account = $this->account();
                    $account['free'] = $this->safe_string($balance, 'available');
                    $account['total'] = $this->safe_string($balance, 'amount');
                    $result[$code] = $account;
                }
            }
        }
        return $this->safe_balance($result);
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        /**
         * transfer $currency internally between wallets on the same account
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to transfer
         * @param {string} $fromAccount account to transfer from
         * @param {string} $toAccount account to transfer to
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transfer-structure transfer structure}
         */
        // transferring between derivatives wallet and regular wallet is not documented in their API
        // however we support it in CCXT (from just looking at web inspector)
        $this->load_markets();
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
        $currency = $this->currency($code);
        $fromCurrencyId = $this->convert_derivatives_id($currency['id'], $fromAccount);
        $toCurrencyId = $this->convert_derivatives_id($currency['id'], $toAccount);
        $requestedAmount = $this->currency_to_precision($code, $amount);
        $request = array(
            'amount' => $requestedAmount,
            'currency' => $fromCurrencyId,
            'currency_to' => $toCurrencyId,
            'walletfrom' => $fromId,
            'walletto' => $toId,
        );
        $response = $this->privatePostTransfer (array_merge($request, $params));
        //
        //     array(
        //         {
        //             status => 'success',
        //             $message => '0.0001 Bitcoin transfered from Margin to Exchange'
        //         }
        //     )
        //
        $result = $this->safe_value($response, 0);
        $message = $this->safe_string($result, 'message');
        if ($message === null) {
            throw new ExchangeError($this->id . ' transfer failed');
        }
        return array_merge($this->parse_transfer($result, $currency), array(
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'amount' => $this->parse_number($requestedAmount),
        ));
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        //     {
        //         status => 'success',
        //         message => '0.0001 Bitcoin transfered from Margin to Exchange'
        //     }
        //
        $timestamp = $this->milliseconds();
        return array(
            'info' => $transfer,
            'id' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $this->safe_currency_code(null, $currency),
            'amount' => null,
            'fromAccount' => null,
            'toAccount' => null,
            'status' => $this->parse_transfer_status($this->safe_string($transfer, 'status')),
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function convert_derivatives_id($currencyId, $type) {
        $start = strlen($currencyId) - 2;
        $isDerivativeCode = mb_substr($currencyId, $start) === 'F0';
        if (($type !== 'derivatives' && $type !== 'trading' && $type !== 'margin') && $isDerivativeCode) {
            $currencyId = mb_substr($currencyId, 0, $start - 0);
        } elseif ($type === 'derivatives' && !$isDerivativeCode) {
            $currencyId = $currencyId . 'F0';
        }
        return $currencyId;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit_bids'] = $limit;
            $request['limit_asks'] = $limit;
        }
        $response = $this->publicGetBookSymbol (array_merge($request, $params));
        return $this->parse_order_book($response, $market['symbol'], null, 'bids', 'asks', 'price', 'amount');
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        /**
         * fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
         * @param {[string]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all market tickers are returned if not assigned
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} an array of {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structures}
         */
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $response = $this->publicGetTickers ($params);
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $ticker = $this->parse_ticker($response[$i]);
            $symbol = $ticker['symbol'];
            $result[$symbol] = $ticker;
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $ticker = $this->publicGetPubtickerSymbol (array_merge($request, $params));
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        $timestamp = $this->safe_timestamp($ticker, 'timestamp');
        $symbol = null;
        if ($market !== null) {
            $symbol = $market['symbol'];
        } elseif (is_array($ticker) && array_key_exists('pair', $ticker)) {
            $marketId = $this->safe_string($ticker, 'pair');
            if ($marketId !== null) {
                if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                    $market = $this->markets_by_id[$marketId];
                    $symbol = $market['symbol'];
                } else {
                    $baseId = mb_substr($marketId, 0, 3 - 0);
                    $quoteId = mb_substr($marketId, 3, 6 - 3);
                    $base = $this->safe_currency_code($baseId);
                    $quote = $this->safe_currency_code($quoteId);
                    $symbol = $base . '/' . $quote;
                }
            }
        }
        $last = $this->safe_string($ticker, 'last_price');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string($ticker, 'bid'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => $this->safe_string($ticker, 'mid'),
            'baseVolume' => $this->safe_string($ticker, 'volume'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market);
    }

    public function parse_trade($trade, $market = null) {
        //
        // fetchTrades (public) v1
        //
        //     {
        //          "timestamp":1637258380,
        //          "tid":894452833,
        //          "price":"0.99941",
        //          "amount":"261.38",
        //          "exchange":"bitfinex",
        //          "type":"sell"
        //     }
        //
        //     {    "timestamp":1637258238,
        //          "tid":894452800,
        //          "price":"0.99958",
        //          "amount":"261.90514",
        //          "exchange":"bitfinex",
        //          "type":"buy"
        //     }
        //
        // fetchMyTrades (private) v1
        //
        //     {
        //          "price":"0.99941",
        //          "amount":"261.38",
        //          "timestamp":"1637258380.0",
        //          "type":"Sell",
        //          "fee_currency":"UST",
        //          "fee_amount":"-0.52245157",
        //          "tid":894452833,
        //          "order_id":78819731373
        //     }
        //
        //     {
        //         "price":"0.99958",
        //         "amount":"261.90514",
        //         "timestamp":"1637258238.0",
        //         "type":"Buy",
        //         "fee_currency":"UDC",
        //         "fee_amount":"-0.52381028",
        //         "tid":894452800,
        //         "order_id":78819504838
        //     }
        //
        $id = $this->safe_string($trade, 'tid');
        $timestamp = $this->safe_timestamp($trade, 'timestamp');
        $type = null;
        $side = $this->safe_string_lower($trade, 'type');
        $orderId = $this->safe_string($trade, 'order_id');
        $priceString = $this->safe_string($trade, 'price');
        $amountString = $this->safe_string($trade, 'amount');
        $fee = null;
        if (is_array($trade) && array_key_exists('fee_amount', $trade)) {
            $feeCostString = Precise::string_neg($this->safe_string($trade, 'fee_amount'));
            $feeCurrencyId = $this->safe_string($trade, 'fee_currency');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => $type,
            'order' => $orderId,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = 50, $params = array ()) {
        /**
         * get the list of most recent trades for a particular $symbol
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of trades to fetch
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'limit_trades' => $limit,
        );
        if ($since !== null) {
            $request['timestamp'] = intval($since / 1000);
        }
        $response = $this->publicGetTradesSymbol (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all trades made by the user
         * @param {string} $symbol unified $market $symbol
         * @param {int|null} $since the earliest time in ms to fetch trades for
         * @param {int|null} $limit the maximum number of trades structures to retrieve
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades() requires a `$symbol` argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit_trades'] = $limit;
        }
        if ($since !== null) {
            $request['timestamp'] = intval($since / 1000);
        }
        $response = $this->privatePostMytrades (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        /**
         * create a trade order
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $postOnly = $this->safe_value($params, 'postOnly', false);
        $params = $this->omit($params, array( 'postOnly' ));
        $request = array(
            'symbol' => $market['id'],
            'side' => $side,
            'amount' => $this->amount_to_precision($symbol, $amount),
            'type' => $this->safe_string($this->options['orderTypes'], $type, $type),
            'ocoorder' => false,
            'buy_price_oco' => 0,
            'sell_price_oco' => 0,
        );
        if ($type === 'market') {
            $request['price'] = (string) $this->nonce();
        } else {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        if ($postOnly) {
            $request['is_postonly'] = true;
        }
        $response = $this->privatePostOrderNew (array_merge($request, $params));
        return $this->parse_order($response, $market);
    }

    public function edit_order($id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        $this->load_markets();
        $order = array(
            'order_id' => intval($id),
        );
        if ($price !== null) {
            $order['price'] = $this->price_to_precision($symbol, $price);
        }
        if ($amount !== null) {
            $order['amount'] = $this->number_to_string($amount);
        }
        if ($symbol !== null) {
            $order['symbol'] = $this->market_id($symbol);
        }
        if ($side !== null) {
            $order['side'] = $side;
        }
        if ($type !== null) {
            $order['type'] = $this->safe_string($this->options['orderTypes'], $type, $type);
        }
        $response = $this->privatePostOrderCancelReplace (array_merge($order, $params));
        return $this->parse_order($response);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         * @param {string} $id order $id
         * @param {string|null} $symbol not used by bitfinex cancelOrder ()
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
         */
        $this->load_markets();
        $request = array(
            'order_id' => intval($id),
        );
        return $this->privatePostOrderCancel (array_merge($request, $params));
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        /**
         * cancel all open orders
         * @param {string|null} $symbol unified market $symbol, only orders in the market of this $symbol are cancelled when $symbol is not null
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} response from exchange
         */
        return $this->privatePostOrderCancelAll ($params);
    }

    public function parse_order($order, $market = null) {
        //
        //     {
        //           $id => 57334010955,
        //           cid => 1611584840966,
        //           cid_date => null,
        //           gid => null,
        //           $symbol => 'ltcbtc',
        //           $exchange => null,
        //           price => '0.0042125',
        //           avg_execution_price => '0.0042097',
        //           $side => 'sell',
        //           type => 'exchange market',
        //           $timestamp => '1611584841.0',
        //           is_live => false,
        //           is_cancelled => false,
        //           is_hidden => 0,
        //           oco_order => 0,
        //           was_forced => false,
        //           original_amount => '0.205176',
        //           remaining_amount => '0.0',
        //           executed_amount => '0.205176',
        //           src => 'web'
        //     }
        //
        $side = $this->safe_string($order, 'side');
        $open = $this->safe_value($order, 'is_live');
        $canceled = $this->safe_value($order, 'is_cancelled');
        $status = null;
        if ($open) {
            $status = 'open';
        } elseif ($canceled) {
            $status = 'canceled';
        } else {
            $status = 'closed';
        }
        $marketId = $this->safe_string_upper($order, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $orderType = $this->safe_string($order, 'type', '');
        $exchange = mb_strpos($orderType, 'exchange ') !== false;
        if ($exchange) {
            $parts = explode(' ', $order['type']);
            $orderType = $parts[1];
        }
        $timestamp = $this->safe_timestamp($order, 'timestamp');
        $id = $this->safe_string($order, 'id');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $this->safe_string($order, 'price'),
            'stopPrice' => null,
            'average' => $this->safe_string($order, 'avg_execution_price'),
            'amount' => $this->safe_string($order, 'original_amount'),
            'remaining' => $this->safe_string($order, 'remaining_amount'),
            'filled' => $this->safe_string($order, 'executed_amount'),
            'status' => $status,
            'fee' => null,
            'cost' => null,
            'trades' => null,
        ), $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all unfilled currently open $orders
         * @param {string|null} $symbol unified market $symbol
         * @param {int|null} $since the earliest time in ms to fetch open $orders for
         * @param {int|null} $limit the maximum number of  open $orders structures to retrieve
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
         */
        $this->load_markets();
        if ($symbol !== null) {
            if (!(is_array($this->markets) && array_key_exists($symbol, $this->markets))) {
                throw new ExchangeError($this->id . ' has no $symbol ' . $symbol);
            }
        }
        $response = $this->privatePostOrders ($params);
        $orders = $this->parse_orders($response, null, $since, $limit);
        if ($symbol !== null) {
            $orders = $this->filter_by($orders, 'symbol', $symbol);
        }
        return $orders;
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches information on multiple closed $orders made by the user
         * @param {string|null} $symbol unified market $symbol of the market $orders were made in
         * @param {int|null} $since the earliest time in ms to fetch $orders for
         * @param {int|null} $limit the maximum number of  orde structures to retrieve
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
         */
        $this->load_markets();
        $symbol = $this->symbol($symbol);
        $request = array();
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privatePostOrdersHist (array_merge($request, $params));
        $orders = $this->parse_orders($response, null, $since, $limit);
        if ($symbol !== null) {
            $orders = $this->filter_by($orders, 'symbol', $symbol);
        }
        $orders = $this->filter_by_array($orders, 'status', array( 'closed', 'canceled' ), false);
        return $orders;
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         * @param {string|null} $symbol not used by bitfinex fetchOrder
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
         */
        $this->load_markets();
        $request = array(
            'order_id' => intval($id),
        );
        $response = $this->privatePostOrderStatus (array_merge($request, $params));
        return $this->parse_order($response);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     array(
        //         1457539800000,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.02594,
        //         0.1
        //     )
        //
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        $this->load_markets();
        if ($limit === null) {
            $limit = 100;
        }
        $market = $this->market($symbol);
        $v2id = 't' . $market['id'];
        $request = array(
            'symbol' => $v2id,
            'timeframe' => $this->timeframes[$timeframe],
            'sort' => 1,
            'limit' => $limit,
        );
        if ($since !== null) {
            $request['start'] = $since;
        }
        $response = $this->v2GetCandlesTradeTimeframeSymbolHist (array_merge($request, $params));
        //
        //     [
        //         [1457539800000,0.02594,0.02594,0.02594,0.02594,0.1],
        //         [1457547300000,0.02577,0.02577,0.02577,0.02577,0.01],
        //         [1457550240000,0.0255,0.0253,0.0255,0.0252,3.2640000000000002],
        //     ]
        //
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function get_currency_name($code) {
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        if (is_array($this->options['currencyNames']) && array_key_exists($code, $this->options['currencyNames'])) {
            return $this->options['currencyNames'][$code];
        }
        throw new NotSupported($this->id . ' ' . $code . ' not supported for withdrawal');
    }

    public function create_deposit_address($code, $params = array ()) {
        /**
         * create a currency deposit address
         * @param {string} $code unified currency $code of the currency for the deposit address
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#address-structure address structure}
         */
        $this->load_markets();
        $request = array(
            'renew' => 1,
        );
        return $this->fetch_deposit_address($code, array_merge($request, $params));
    }

    public function fetch_deposit_address($code, $params = array ()) {
        /**
         * fetch the deposit $address for a currency associated with this account
         * @param {string} $code unified currency $code
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#$address-structure $address structure}
         */
        $this->load_markets();
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        $name = $this->get_currency_name($code);
        $request = array(
            'method' => $name,
            'wallet_name' => 'exchange',
            'renew' => 0, // a value of 1 will generate a new $address
        );
        $response = $this->privatePostDepositNew (array_merge($request, $params));
        $address = $this->safe_value($response, 'address');
        $tag = null;
        if (is_array($response) && array_key_exists('address_pool', $response)) {
            $tag = $address;
            $address = $response['address_pool'];
        }
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => null,
            'info' => $response,
        );
    }

    public function fetch_transactions($code = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch history of deposits and withdrawals
         * @param {string|null} $code unified $currency $code for the $currency of the transactions, default is null
         * @param {int|null} $since timestamp in ms of the earliest transaction, default is null
         * @param {int|null} $limit max number of transactions to return, default is null
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structure}
         */
        $this->load_markets();
        $currencyId = $this->safe_string($params, 'currency');
        $query = $this->omit($params, 'currency');
        $currency = null;
        if ($currencyId === null) {
            if ($code === null) {
                throw new ArgumentsRequired($this->id . ' fetchTransactions() requires a $currency `$code` argument or a `$currency` parameter');
            } else {
                $currency = $this->currency($code);
                $currencyId = $currency['id'];
            }
        }
        $query['currency'] = $currencyId;
        if ($since !== null) {
            $query['since'] = intval($since / 1000);
        }
        $response = $this->privatePostHistoryMovements (array_merge($query, $params));
        //
        //     array(
        //         {
        //             "id" => 581183,
        //             "txid" =>  123456,
        //             "currency" => "BTC",
        //             "method" => "BITCOIN",
        //             "type" => "WITHDRAWAL",
        //             "amount" => ".01",
        //             "description" => "3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ, offchain transfer ",
        //             "address" => "3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ",
        //             "status" => "COMPLETED",
        //             "timestamp" => "1443833327.0",
        //             "timestamp_created" =>  "1443833327.1",
        //             "fee" =>  0.1,
        //         }
        //     )
        //
        return $this->parse_transactions($response, $currency, $since, $limit);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // crypto
        //
        //     {
        //         "id" => 12042490,
        //         "fee" => "-0.02",
        //         "txid" => "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
        //         "type" => "DEPOSIT",
        //         "amount" => "2099.849999",
        //         "method" => "RIPPLE",
        //         "status" => "COMPLETED",
        //         "address" => "2505189261",
        //         "currency" => "XRP",
        //         "timestamp" => "1551730524.0",
        //         "description" => "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
        //         "timestamp_created" => "1551730523.0"
        //     }
        //
        // fiat
        //
        //     {
        //         "id" => 12725095,
        //         "fee" => "-60.0",
        //         "txid" => null,
        //         "type" => "WITHDRAWAL",
        //         "amount" => "9943.0",
        //         "method" => "WIRE",
        //         "status" => "SENDING",
        //         "address" => null,
        //         "currency" => "EUR",
        //         "timestamp" => "1561802484.0",
        //         "description" => "Name => bob, AccountAddress => some address, Account => someaccountno, Bank => bank address, SWIFT => foo, Country => UK, Details of Payment => withdrawal name, Intermediary Bank Name => , Intermediary Bank Address => , Intermediary Bank City => , Intermediary Bank Country => , Intermediary Bank Account => , Intermediary Bank SWIFT => , Fee => -60.0",
        //         "timestamp_created" => "1561716066.0"
        //     }
        //
        // withdraw
        //
        //     {
        //         "status" => "success",
        //         "message" => "Your withdrawal request has been successfully submitted.",
        //         "withdrawal_id" => 586829
        //     }
        //
        $timestamp = $this->safe_timestamp($transaction, 'timestamp_created');
        $updated = $this->safe_timestamp($transaction, 'timestamp');
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        $type = $this->safe_string_lower($transaction, 'type'); // DEPOSIT or WITHDRAWAL
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        $feeCost = $this->safe_string($transaction, 'fee');
        if ($feeCost !== null) {
            $feeCost = Precise::string_abs($feeCost);
        }
        $tag = $this->safe_string($transaction, 'description');
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'withdrawal_id'),
            'txid' => $this->safe_string($transaction, 'txid'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'address' => $this->safe_string($transaction, 'address'), // todo => this is actually the $tag for XRP transfers (the address is missing)
            'addressTo' => null,
            'addressFrom' => null,
            'tag' => $tag,
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => array(
                'currency' => $code,
                'cost' => $this->parse_number($feeCost),
                'rate' => null,
            ),
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'SENDING' => 'pending',
            'CANCELED' => 'canceled',
            'ZEROCONFIRMED' => 'failed', // ZEROCONFIRMED happens e.g. in a double spend attempt (I had one in my movements!)
            'COMPLETED' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        /**
         * make a withdrawal
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string|null} $tag
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structure}
         */
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->check_address($address);
        $this->load_markets();
        // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
        $name = $this->get_currency_name($code);
        $currency = $this->currency($code);
        $request = array(
            'withdraw_type' => $name,
            'walletselected' => 'exchange',
            'amount' => $this->number_to_string($amount),
            'address' => $address,
        );
        if ($tag !== null) {
            $request['payment_id'] = $tag;
        }
        $responses = $this->privatePostWithdraw (array_merge($request, $params));
        //
        //     array(
        //         {
        //             "status":"success",
        //             "message":"Your withdrawal $request has been successfully submitted.",
        //             "withdrawal_id":586829
        //         }
        //     )
        //
        $response = $this->safe_value($responses, 0, array());
        $id = $this->safe_number($response, 'withdrawal_id');
        $message = $this->safe_string($response, 'message');
        $errorMessage = $this->find_broadly_matched_key($this->exceptions['broad'], $message);
        if ($id === 0) {
            if ($errorMessage !== null) {
                $ExceptionClass = $this->exceptions['broad'][$errorMessage];
                throw new $ExceptionClass($this->id . ' ' . $message);
            }
            throw new ExchangeError($this->id . ' withdraw returned an $id of zero => ' . $this->json($response));
        }
        return $this->parse_transaction($response, $currency);
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        /**
         * fetch all open positions
         * @param {[string]|null} $symbols list of unified market $symbols
         * @param {array} $params extra parameters specific to the bitfinex api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
         */
        $this->load_markets();
        $response = $this->privatePostPositions ($params);
        //
        //     array(
        //         {
        //             "id":943715,
        //             "symbol":"btcusd",
        //             "status":"ACTIVE",
        //             "base":"246.94",
        //             "amount":"1.0",
        //             "timestamp":"1444141857.0",
        //             "swap":"0.0",
        //             "pl":"-2.22042"
        //         }
        //     )
        //
        // todo unify parsePosition/parsePositions
        return $response;
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $request = '/' . $this->implode_params($path, $params);
        if ($api === 'v2') {
            $request = '/' . $api . $request;
        } else {
            $request = '/' . $this->version . $request;
        }
        $query = $this->omit($params, $this->extract_params($path));
        $url = $this->urls['api'][$api] . $request;
        if (($api === 'public') || (mb_strpos($path, '/hist') !== false)) {
            if ($query) {
                $suffix = '?' . $this->urlencode($query);
                $url .= $suffix;
                $request .= $suffix;
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $nonce = $this->nonce();
            $query = array_merge(array(
                'nonce' => (string) $nonce,
                'request' => $request,
            ), $query);
            $body = $this->json($query);
            $payload = base64_encode($body);
            $secret = $this->encode($this->secret);
            $signature = $this->hmac($payload, $secret, 'sha384');
            $headers = array(
                'X-BFX-APIKEY' => $this->apiKey,
                'X-BFX-PAYLOAD' => $this->decode($payload),
                'X-BFX-SIGNATURE' => $signature,
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        $throwError = false;
        if ($code >= 400) {
            $firstChar = $this->safe_string($body, 0);
            if ($firstChar === '{') {
                $throwError = true;
            }
        } else {
            // json $response with error, i.e:
            // [array("status":"error","message":"Momentary balance check. Please wait few seconds and try the transfer again.")]
            $responseObject = $this->safe_value($response, 0, array());
            $status = $this->safe_string($responseObject, 'status', '');
            if ($status === 'error') {
                $throwError = true;
            }
        }
        if ($throwError) {
            $feedback = $this->id . ' ' . $body;
            $message = $this->safe_string_2($response, 'message', 'error');
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
