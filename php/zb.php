<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\BadSymbol;
use \ccxt\InvalidOrder;
use \ccxt\OrderNotFound;
use \ccxt\NotSupported;
use \ccxt\ExchangeNotAvailable;

class zb extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'zb',
            'name' => 'ZB',
            'countries' => array( 'CN' ),
            'rateLimit' => 100,
            'version' => 'v1',
            'certified' => true,
            'pro' => true,
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null, // has but unimplemented
                'swap' => null, // has but unimplemented
                'future' => null,
                'option' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketOrder' => null,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => true,
                'fetchDeposits' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchMarkets' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchWithdrawals' => true,
                'setLeverage' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1min',
                '3m' => '3min',
                '5m' => '5min',
                '15m' => '15min',
                '30m' => '30min',
                '1h' => '1hour',
                '2h' => '2hour',
                '4h' => '4hour',
                '6h' => '6hour',
                '12h' => '12hour',
                '1d' => '1day',
                '3d' => '3day',
                '1w' => '1week',
            ),
            'exceptions' => array(
                'ws' => array(
                    //  '1000' => '\\ccxt\\ExchangeError', // The call is successful.
                    '1001' => '\\ccxt\\ExchangeError', // General error prompt
                    '1002' => '\\ccxt\\ExchangeError', // Internal Error
                    '1003' => '\\ccxt\\AuthenticationError', // Fail to verify
                    '1004' => '\\ccxt\\AuthenticationError', // The transaction password is locked
                    '1005' => '\\ccxt\\AuthenticationError', // Wrong transaction password, please check it and re-enter。
                    '1006' => '\\ccxt\\PermissionDenied', // Real-name authentication is pending approval or unapproved
                    '1007' => '\\ccxt\\ExchangeError', // Channel does not exist
                    '1009' => '\\ccxt\\OnMaintenance', // This interface is under maintenance
                    '1010' => '\\ccxt\\ExchangeNotAvailable', // Not available now
                    '1012' => '\\ccxt\\PermissionDenied', // Insufficient permissions
                    '1013' => '\\ccxt\\ExchangeError', // Cannot trade, please contact email => support@zb.cn for support.
                    '1014' => '\\ccxt\\ExchangeError', // Cannot sell during the pre-sale period
                    '2001' => '\\ccxt\\InsufficientFunds', // Insufficient CNY account balance
                    '2002' => '\\ccxt\\InsufficientFunds', // Insufficient BTC account balance
                    '2003' => '\\ccxt\\InsufficientFunds', // Insufficient LTC account balance
                    '2005' => '\\ccxt\\InsufficientFunds', // Insufficient ETH account balance
                    '2006' => '\\ccxt\\InsufficientFunds', // ETCInsufficient account balance
                    '2007' => '\\ccxt\\InsufficientFunds', // BTSInsufficient account balance
                    '2008' => '\\ccxt\\InsufficientFunds', // EOSInsufficient account balance
                    '2009' => '\\ccxt\\InsufficientFunds', // BCCInsufficient account balance
                    '3001' => '\\ccxt\\OrderNotFound', // Order not found or is completed
                    '3002' => '\\ccxt\\InvalidOrder', // Invalid amount
                    '3003' => '\\ccxt\\InvalidOrder', // Invalid quantity
                    '3004' => '\\ccxt\\AuthenticationError', // User does not exist
                    '3005' => '\\ccxt\\BadRequest', // Invalid parameter
                    '3006' => '\\ccxt\\PermissionDenied', // Invalid IP or not consistent with the bound IP
                    '3007' => '\\ccxt\\RequestTimeout', // The request time has expired
                    '3008' => '\\ccxt\\ExchangeError', // Transaction not found
                    '3009' => '\\ccxt\\InvalidOrder', // The price exceeds the limit
                    '3010' => '\\ccxt\\PermissionDenied', // It fails to place an order, due to you have set up to prohibit trading of this market.
                    '3011' => '\\ccxt\\InvalidOrder', // The entrusted price is abnormal, please modify it and place order again
                    '3012' => '\\ccxt\\InvalidOrder', // Duplicate custom customerOrderId
                    '4001' => '\\ccxt\\AccountSuspended', // APIThe interface is locked for one hour
                    '4002' => '\\ccxt\\RateLimitExceeded', // Request too frequently
                ),
                'exact' => array(
                    // '1000' => 'Successful operation',
                    '1001' => '\\ccxt\\ExchangeError', // 'General error message',
                    '1002' => '\\ccxt\\ExchangeError', // 'Internal error',
                    '1003' => '\\ccxt\\AuthenticationError', // 'Verification does not pass',
                    '1004' => '\\ccxt\\AuthenticationError', // 'Funding security password lock',
                    '1005' => '\\ccxt\\AuthenticationError', // 'Funds security password is incorrect, please confirm and re-enter.',
                    '1006' => '\\ccxt\\AuthenticationError', // 'Real-name certification pending approval or audit does not pass',
                    '1009' => '\\ccxt\\ExchangeNotAvailable', // 'This interface is under maintenance',
                    '1010' => '\\ccxt\\ExchangeNotAvailable', // Not available now
                    '1012' => '\\ccxt\\PermissionDenied', // Insufficient permissions
                    '1013' => '\\ccxt\\ExchangeError', // Cannot trade, please contact email => support@zb.cn for support.
                    '1014' => '\\ccxt\\ExchangeError', // Cannot sell during the pre-sale period
                    '2001' => '\\ccxt\\InsufficientFunds', // 'Insufficient CNY Balance',
                    '2002' => '\\ccxt\\InsufficientFunds', // 'Insufficient BTC Balance',
                    '2003' => '\\ccxt\\InsufficientFunds', // 'Insufficient LTC Balance',
                    '2005' => '\\ccxt\\InsufficientFunds', // 'Insufficient ETH Balance',
                    '2006' => '\\ccxt\\InsufficientFunds', // 'Insufficient ETC Balance',
                    '2007' => '\\ccxt\\InsufficientFunds', // 'Insufficient BTS Balance',
                    '2008' => '\\ccxt\\InsufficientFunds', // EOSInsufficient account balance
                    '2009' => '\\ccxt\\InsufficientFunds', // 'Account balance is not enough',
                    '3001' => '\\ccxt\\OrderNotFound', // 'Pending orders not found',
                    '3002' => '\\ccxt\\InvalidOrder', // 'Invalid price',
                    '3003' => '\\ccxt\\InvalidOrder', // 'Invalid amount',
                    '3004' => '\\ccxt\\AuthenticationError', // 'User does not exist',
                    '3005' => '\\ccxt\\BadRequest', // 'Invalid parameter',
                    '3006' => '\\ccxt\\AuthenticationError', // 'Invalid IP or inconsistent with the bound IP',
                    '3007' => '\\ccxt\\AuthenticationError', // 'The request time has expired',
                    '3008' => '\\ccxt\\OrderNotFound', // 'Transaction records not found',
                    '3009' => '\\ccxt\\InvalidOrder', // 'The price exceeds the limit',
                    '3010' => '\\ccxt\\PermissionDenied', // It fails to place an order, due to you have set up to prohibit trading of this market.
                    '3011' => '\\ccxt\\InvalidOrder', // 'The entrusted price is abnormal, please modify it and place order again',
                    '3012' => '\\ccxt\\InvalidOrder', // Duplicate custom customerOrderId
                    '4001' => '\\ccxt\\ExchangeNotAvailable', // 'API interface is locked or not enabled',
                    '4002' => '\\ccxt\\RateLimitExceeded', // 'Request too often',
                    '10017' => '\\ccxt\\PermissionDenied', // array("code":10017,"desc":"没有权限") when contract trading is not enabled on the api key
                ),
                'broad' => array(
                    '提币地址有误，请先添加提币地址。' => '\\ccxt\\InvalidAddress', // array("code":1001,"message":"提币地址有误，请先添加提币地址。")
                    '资金不足,无法划账' => '\\ccxt\\InsufficientFunds', // array("code":1001,"message":"资金不足,无法划账")
                    '响应超时' => '\\ccxt\\RequestTimeout', // array("code":1001,"message":"响应超时")
                ),
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg',
                'api' => array(
                    'spot' => array(
                        'v1' => array(
                            'public' => 'https://api.zb.work/data',
                            'private' => 'https://trade.zb.work/api',
                        ),
                    ),
                    'contract' => array(
                        'v1' => array(
                            'public' => 'https://fapi.zb.com/api/public',
                        ),
                        'v2' => array(
                            'public' => 'https://fapi.zb.com/Server/api',
                            'private' => 'https://fapi.zb.com/Server/api',
                        ),
                    ),
                ),
                'www' => 'https://www.zb.com',
                'doc' => 'https://www.zb.com/i/developer',
                'fees' => 'https://www.zb.com/i/rate',
                'referral' => array(
                    'url' => 'https://www.zbex.club/en/register?ref=4301lera',
                    'discount' => 0.16,
                ),
            ),
            'api' => array(
                'spot' => array(
                    'v1' => array(
                        'public' => array(
                            'get' => array(
                                'markets',
                                'ticker',
                                'allTicker',
                                'depth',
                                'trades',
                                'kline',
                                'getGroupMarkets',
                                'getFeeInfo',
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                // spot API
                                'order',
                                'orderMoreV2',
                                'cancelOrder',
                                'getOrder',
                                'getOrders',
                                'getOrdersNew',
                                'getOrdersIgnoreTradeType',
                                'getUnfinishedOrdersIgnoreTradeType',
                                'getFinishedAndPartialOrders',
                                'getAccountInfo',
                                'getUserAddress',
                                'getPayinAddress',
                                'getWithdrawAddress',
                                'getWithdrawRecord',
                                'getChargeRecord',
                                'getCnyWithdrawRecord',
                                'getCnyChargeRecord',
                                'withdraw',
                                // sub accounts
                                'addSubUser',
                                'getSubUserList',
                                'doTransferFunds',
                                'createSubUserKey', // removed on 2021-03-16 according to the update log in the API doc
                                // leverage API
                                'getLeverAssetsInfo',
                                'getLeverBills',
                                'transferInLever',
                                'transferOutLever',
                                'loan',
                                'cancelLoan',
                                'getLoans',
                                'getLoanRecords',
                                'borrow',
                                'autoBorrow',
                                'repay',
                                'doAllRepay',
                                'getRepayments',
                                'getFinanceRecords',
                                'changeInvestMark',
                                'changeLoop',
                                // cross API
                                'getCrossAssets',
                                'getCrossBills',
                                'transferInCross',
                                'transferOutCross',
                                'doCrossLoan',
                                'doCrossRepay',
                                'getCrossRepayRecords',
                            ),
                        ),
                    ),
                ),
                'contract' => array(
                    'v1' => array(
                        'public' => array(
                            'get' => array(
                                'depth',
                                'fundingRate',
                                'indexKline',
                                'indexPrice',
                                'kCline',
                                'markKline',
                                'markPrice',
                                'ticker',
                                'trade',
                            ),
                        ),
                    ),
                    'v2' => array(
                        'public' => array(
                            'get' => array(
                                'allForceOrders',
                                'config/marketList',
                                'topLongShortAccountRatio',
                                'topLongShortPositionRatio',
                                'fundingRate',
                                'premiumIndex',
                            ),
                        ),
                        'private' => array(
                            'get' => array(
                                'Fund/balance',
                                'Fund/getAccount',
                                'Fund/getBill',
                                'Fund/getBillTypeList',
                                'Fund/marginHistory',
                                'Positions/getPositions',
                                'Positions/getNominalValue',
                                'Positions/marginInfo',
                                'setting/get',
                                'trade/getAllOrders',
                                'trade/getOrder',
                                'trade/getOrderAlgos',
                                'trade/getTradeList',
                                'trade/getUndoneOrders',
                                'trade/tradeHistory',
                            ),
                            'post' => array(
                                'activity/buyTicket',
                                'Fund/transferFund',
                                'Positions/setMarginCoins',
                                'Positions/updateAppendUSDValue',
                                'Positions/updateMargin',
                                'setting/setLeverage',
                                'trade/batchOrder',
                                'trade/batchCancelOrder',
                                'trade/cancelAlgos',
                                'trade/cancelAllOrders',
                                'trade/cancelOrder',
                                'trade/order',
                                'trade/orderAlgo',
                                'trade/updateOrderAlgo',
                            ),
                        ),
                    ),
                ),
            ),
            'fees' => array(
                'funding' => array(
                    'withdraw' => array(),
                ),
                'trading' => array(
                    'maker' => 0.2 / 100,
                    'taker' => 0.2 / 100,
                ),
            ),
            'commonCurrencies' => array(
                'ANG' => 'Anagram',
                'ENT' => 'ENTCash',
                'BCHABC' => 'BCHABC', // conflict with BCH / BCHA
                'BCHSV' => 'BCHSV', // conflict with BCH / BSV
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        $markets = $this->spotV1PublicGetMarkets ($params);
        //
        //     {
        //         "zb_qc":array(
        //             "amountScale":2,
        //             "minAmount":0.01,
        //             "minSize":5,
        //             "priceScale":4,
        //         ),
        //     }
        //
        $contracts = $this->contractV2PublicGetConfigMarketList ($params);
        //
        //     {
        //         BTC_USDT => array(
        //             $symbol => 'BTC_USDT',
        //             buyerCurrencyId => '6',
        //             contractType => '1',
        //             defaultMarginMode => '1',
        //             marketType => '2',
        //             historyDBName => 'trade_history_readonly.dbc',
        //             defaultLeverage => '20',
        //             $id => '100',
        //             canCancelOrder => true,
        //             area => '1',
        //             mixMarginCoinName => 'usdt',
        //             fundingRateRatio => '0.25',
        //             marginCurrencyName => 'usdt',
        //             minTradeMoney => '0.0001',
        //             enableTime => '1638954000000',
        //             maxTradeMoney => '10000000',
        //             canTrade => true,
        //             maxLeverage => '125',
        //             defaultPositionsMode => '2',
        //             onlyWhitelistVisible => false,
        //             riskWarnRatio => '0.8',
        //             marginDecimal => '8',
        //             $spot => false,
        //             $status => '1',
        //             amountDecimal => '3',
        //             leverage => false,
        //             minAmount => '0.001',
        //             canOrder => true,
        //             duration => '1',
        //             feeDecimal => '8',
        //             sellerCurrencyId => '1',
        //             maxAmount => '1000',
        //             canOpenPosition => true,
        //             isSupportMixMargin => false,
        //             markPriceLimitRate => '0.05',
        //             marginCurrencyId => '6',
        //             stopFundingFee => false,
        //             priceDecimal => '2',
        //             lightenUpFeeRate => '0',
        //             futures => true,
        //             sellerCurrencyName => 'btc',
        //             marketPriceLimitRate => '0.05',
        //             canRebate => true,
        //             marketName => 'BTC_USDT',
        //             depth => array( 0.01, 0.1, 1 ),
        //             createTime => '1607590430094',
        //             mixMarginCoinIds => array( 6 ),
        //             buyerCurrencyName => 'usdt',
        //             stopService => false
        //         ),
        //     }
        //
        $contractsData = $this->safe_value($contracts, 'data', array());
        $contractsById = $this->index_by($contractsData, 'marketName');
        $dataById = $this->deep_extend($contractsById, $markets);
        $keys = is_array($dataById) ? array_keys($dataById) : array();
        $result = array();
        for ($i = 0; $i < count($keys); $i++) {
            $id = $keys[$i];
            $market = $dataById[$id];
            list($baseId, $quoteId) = explode('_', $id);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settleId = $this->safe_value($market, 'marginCurrencyName');
            $settle = $this->safe_currency_code($settleId);
            $spot = $settle === null;
            $swap = $this->safe_value($market, 'futures', false);
            $linear = $swap ? true : null;
            $active = true;
            $symbol = $base . '/' . $quote;
            $amountPrecisionString = $this->safe_string_2($market, 'amountScale', 'amountDecimal');
            $pricePrecisionString = $this->safe_string_2($market, 'priceScale', 'priceDecimal');
            if ($swap) {
                $status = $this->safe_string($market, 'status');
                $active = ($status === '1');
                $symbol = $base . '/' . $quote . ':' . $settle;
            }
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => $swap ? 'swap' : 'spot',
                'spot' => $spot,
                'margin' => false,
                'swap' => $swap,
                'future' => false,
                'option' => false,
                'active' => $active,
                'contract' => $swap,
                'linear' => $linear,
                'inverse' => $swap ? !$linear : null,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => intval($amountPrecisionString),
                    'price' => intval($pricePrecisionString),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => $this->safe_number($market, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minAmount'),
                        'max' => $this->safe_number($market, 'maxAmount'),
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number_2($market, 'minSize', 'minTradeMoney'),
                        'max' => $this->safe_number($market, 'maxTradeMoney'),
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        $response = $this->spotV1PublicGetGetFeeInfo ($params);
        //
        //     {
        //         "code":1000,
        //         "message":"success",
        //         "result":{
        //             "USDT":array(
        //                 array(
        //                     "chainName":"TRC20",
        //                     "canWithdraw":true,
        //                     "fee":1.0,
        //                     "mainChainName":"TRX",
        //                     "canDeposit":true
        //                 ),
        //                 array(
        //                     "chainName":"OMNI",
        //                     "canWithdraw":true,
        //                     "fee":5.0,
        //                     "mainChainName":"BTC",
        //                     "canDeposit":true
        //                 ),
        //                 {
        //                     "chainName":"ERC20",
        //                     "canWithdraw":true,
        //                     "fee":15.0,
        //                     "mainChainName":"ETH",
        //                     "canDeposit":true
        //                 }
        //             ),
        //         }
        //     }
        //
        $currencies = $this->safe_value($response, 'result', array());
        $ids = is_array($currencies) ? array_keys($currencies) : array();
        $result = array();
        for ($i = 0; $i < count($ids); $i++) {
            $id = $ids[$i];
            $currency = $currencies[$id];
            $code = $this->safe_currency_code($id);
            $precision = null;
            $isWithdrawEnabled = true;
            $isDepositEnabled = true;
            $fees = array();
            for ($j = 0; $j < count($currency); $j++) {
                $networkItem = $currency[$j];
                $network = $this->safe_string($networkItem, 'chainName');
                // $name = $this->safe_string($networkItem, 'name');
                $withdrawFee = $this->safe_number($networkItem, 'fee');
                $depositEnable = $this->safe_value($networkItem, 'canDeposit');
                $withdrawEnable = $this->safe_value($networkItem, 'canWithdraw');
                $isDepositEnabled = $isDepositEnabled || $depositEnable;
                $isWithdrawEnabled = $isWithdrawEnabled || $withdrawEnable;
                $fees[$network] = $withdrawFee;
            }
            $active = ($isWithdrawEnabled && $isDepositEnabled);
            $result[$code] = array(
                'id' => $id,
                'name' => null,
                'code' => $code,
                'precision' => $precision,
                'info' => $currency,
                'active' => $active,
                'deposit' => $isDepositEnabled,
                'withdraw' => $isWithdrawEnabled,
                'fee' => null,
                'fees' => $fees,
                'limits' => $this->limits,
            );
        }
        return $result;
    }

    public function parse_balance($response) {
        $balances = $this->safe_value($response['result'], 'coins');
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            //     {        enName => "BTC",
            //               freez => "0.00000000",
            //         unitDecimal =>  8, // always 8
            //              cnName => "BTC",
            //       isCanRecharge =>  true, // TODO => should use this
            //             unitTag => "฿",
            //       isCanWithdraw =>  true,  // TODO => should use this
            //           available => "0.00000000",
            //                 key => "btc"         }
            $account = $this->account();
            $currencyId = $this->safe_string($balance, 'key');
            $code = $this->safe_currency_code($currencyId);
            $account['free'] = $this->safe_string($balance, 'available');
            $account['used'] = $this->safe_string($balance, 'freez');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function fetch_balance($params = array ()) {
        $this->load_markets();
        $response = $this->spotV1PrivateGetGetAccountInfo ($params);
        // todo => use this somehow
        // $permissions = $response['result']['base'];
        return $this->parse_balance($response);
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        // fetchDepositAddress
        //
        //     {
        //         "key" => "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //     }
        //
        // fetchDepositAddresses
        //
        //     {
        //         "blockChain" => "btc",
        //         "isUseMemo" => false,
        //         "address" => "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //         "canWithdraw" => true,
        //         "canDeposit" => true
        //     }
        //     {
        //         "blockChain" => "bts",
        //         "isUseMemo" => true,
        //         "account" => "btstest",
        //         "memo" => "123",
        //         "canWithdraw" => true,
        //         "canDeposit" => true
        //     }
        //
        $address = $this->safe_string_2($depositAddress, 'key', 'address');
        $tag = null;
        $memo = $this->safe_string($depositAddress, 'memo');
        if ($memo !== null) {
            $tag = $memo;
        } else if (mb_strpos($address, '_') !== false) {
            $parts = explode('_', $address);
            $address = $parts[0];  // WARNING => MAY BE tag_address INSTEAD OF address_tag FOR SOME CURRENCIES!!
            $tag = $parts[1];
        }
        $currencyId = $this->safe_string($depositAddress, 'blockChain');
        $code = $this->safe_currency_code($currencyId, $currency);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => null,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses($codes = null, $params = array ()) {
        $this->load_markets();
        $response = $this->spotV1PrivateGetGetPayinAddress ($params);
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => array(
        //                 array(
        //                     "blockChain" => "btc",
        //                     "isUseMemo" => false,
        //                     "address" => "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        //                     "canWithdraw" => true,
        //                     "canDeposit" => true
        //                 ),
        //                 array(
        //                     "blockChain" => "bts",
        //                     "isUseMemo" => true,
        //                     "account" => "btstest",
        //                     "memo" => "123",
        //                     "canWithdraw" => true,
        //                     "canDeposit" => true
        //                 ),
        //             )
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        return $this->parse_deposit_addresses($datas, $codes);
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = $this->spotV1PrivateGetGetUserAddress (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => {
        //                 "key" => "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        //             }
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        return $this->parse_deposit_address($datas, $currency);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'market' => $market['id'], // only applicable to SPOT
            // 'symbol' => $market['id'], // only applicable to SWAP
            // 'size' => $limit, // 1-50 applicable to SPOT and SWAP
            // 'merge' => 5.0, // float default depth only applicable to SPOT
            // 'scale' => 5, // int accuracy, only applicable to SWAP
        );
        $marketIdField = $market['swap'] ? 'symbol' : 'market';
        $request[$marketIdField] = $market['id'];
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PublicGetDepth',
            'swap' => 'contractV1PublicGetDepth',
        ));
        if ($limit !== null) {
            $request['size'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "asks":[
        //             [35000.0,0.2741],
        //             [34949.0,0.0173],
        //             [34900.0,0.5004],
        //         ],
        //         "bids":[
        //             [34119.32,0.0030],
        //             [34107.83,0.1500],
        //             [34104.42,0.1500],
        //         ],
        //         "timestamp":1624536510
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "asks" => [
        //                 [43416.6,0.02],
        //                 [43418.25,0.04],
        //                 [43425.82,0.02]
        //             ],
        //             "bids" => [
        //                 [43414.61,0.1],
        //                 [43414.18,0.04],
        //                 [43413.03,0.05]
        //             ],
        //             "time" => 1645087743071
        //         }
        //     }
        //
        $result = null;
        $timestamp = null;
        if ($market['type'] === 'swap') {
            $result = $this->safe_value($response, 'data');
            $timestamp = $this->safe_integer($result, 'time');
        } else {
            $result = $response;
            $timestamp = $this->safe_timestamp($response, 'timestamp');
        }
        return $this->parse_order_book($result, $symbol, $timestamp);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->spotV1PublicGetAllTicker ($params);
        $result = array();
        $marketsByIdWithoutUnderscore = array();
        $marketIds = is_array($this->markets_by_id) ? array_keys($this->markets_by_id) : array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $tickerId = str_replace('_', '', $marketIds[$i]);
            $marketsByIdWithoutUnderscore[$tickerId] = $this->markets_by_id[$marketIds[$i]];
        }
        $ids = is_array($response) ? array_keys($response) : array();
        for ($i = 0; $i < count($ids); $i++) {
            $market = $marketsByIdWithoutUnderscore[$ids[$i]];
            $result[$market['symbol']] = $this->parse_ticker($response[$ids[$i]], $market);
        }
        return $this->filter_by_array($result, 'symbol', $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'market' => $market['id'], // only applicable to SPOT
            // 'symbol' => $market['id'], // only applicable to SWAP
        );
        $marketIdField = $market['swap'] ? 'symbol' : 'market';
        $request[$marketIdField] = $market['id'];
        $method = $this->get_supported_mapping($market['type'], array(
            'spot' => 'spotV1PublicGetTicker',
            'swap' => 'contractV1PublicGetTicker',
        ));
        $response = $this->$method (array_merge($request, $params));
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587",
        //         "ticker":{
        //             "high":"33298.38",
        //             "vol":"56152.9012",
        //             "last":"32578.55",
        //             "low":"28808.19",
        //             "buy":"32572.68",
        //             "sell":"32615.37",
        //             "turnover":"1764201303.6100",
        //             "open":"31664.85",
        //             "riseRate":"2.89"
        //         }
        //     }
        //
        // Swap
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "BTC_USDT" => [44053.47,44357.77,42911.54,43297.79,53471.264,-1.72,1645093002,302201.255084]
        //         }
        //     }
        //
        $ticker = null;
        if ($market['type'] === 'swap') {
            $ticker = array();
            $data = $this->safe_value($response, 'data');
            $values = $this->safe_value($data, $market['id']);
            for ($i = 0; $i < count($values); $i++) {
                $ticker['open'] = $this->safe_value($values, 0);
                $ticker['high'] = $this->safe_value($values, 1);
                $ticker['low'] = $this->safe_value($values, 2);
                $ticker['last'] = $this->safe_value($values, 3);
                $ticker['vol'] = $this->safe_value($values, 4);
                $ticker['riseRate'] = $this->safe_value($values, 5);
            }
        } else {
            $ticker = $this->safe_value($response, 'ticker', array());
            $ticker['date'] = $this->safe_value($response, 'date');
        }
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // Spot
        //
        //     {
        //         "date":"1624399623587", // injected from outside
        //         "high":"33298.38",
        //         "vol":"56152.9012",
        //         "last":"32578.55",
        //         "low":"28808.19",
        //         "buy":"32572.68",
        //         "sell":"32615.37",
        //         "turnover":"1764201303.6100",
        //         "open":"31664.85",
        //         "riseRate":"2.89"
        //     }
        //
        // Swap
        //
        //     {
        //         open => 44083.82,
        //         high => 44357.77,
        //         low => 42911.54,
        //         $last => 43097.87,
        //         vol => 53451.641,
        //         riseRate => -2.24
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'date', $this->milliseconds());
        $last = $this->safe_string($ticker, 'last');
        return $this->safe_ticker(array(
            'symbol' => $this->safe_symbol(null, $market),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'high'),
            'low' => $this->safe_string($ticker, 'low'),
            'bid' => $this->safe_string($ticker, 'buy'),
            'bidVolume' => null,
            'ask' => $this->safe_string($ticker, 'sell'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'open'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'vol'),
            'quoteVolume' => null,
            'info' => $ticker,
        ), $market, false);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if ($limit === null) {
            $limit = 1000;
        }
        $request = array(
            'market' => $market['id'],
            'type' => $this->timeframes[$timeframe],
            'limit' => $limit,
        );
        if ($since !== null) {
            $request['since'] = $since;
        }
        $response = $this->spotV1PublicGetKline (array_merge($request, $params));
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        //     {
        //         "date":1624537391,
        //         "amount":"0.0142",
        //         "price":"33936.42",
        //         "trade_type":"ask",
        //         "type":"sell",
        //         "tid":1718869018
        //     }
        //
        $timestamp = $this->safe_timestamp($trade, 'date');
        $side = $this->safe_string($trade, 'trade_type');
        $side = ($side === 'bid') ? 'buy' : 'sell';
        $id = $this->safe_string($trade, 'tid');
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'amount');
        $market = $this->safe_market(null, $market);
        return $this->safe_trade(array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'type' => null,
            'side' => $side,
            'order' => null,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => null,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'market' => $market['id'],
        );
        $response = $this->spotV1PublicGetTrades (array_merge($request, $params));
        //
        //     array(
        //         array("date":1624537391,"amount":"0.0142","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869018),
        //         array("date":1624537391,"amount":"0.0010","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869020),
        //         array("date":1624537391,"amount":"0.0133","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869021),
        //     )
        //
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        if ($type !== 'limit') {
            throw new InvalidOrder($this->id . ' allows limit orders only');
        }
        $this->load_markets();
        $request = array(
            'price' => $this->price_to_precision($symbol, $price),
            'amount' => $this->amount_to_precision($symbol, $amount),
            'tradeType' => ($side === 'buy') ? '1' : '0',
            'currency' => $this->market_id($symbol),
        );
        $response = $this->spotV1PrivateGetOrder (array_merge($request, $params));
        return array(
            'info' => $response,
            'id' => $response['id'],
        );
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'id' => (string) $id,
            'currency' => $this->market_id($symbol),
        );
        return $this->spotV1PrivateGetCancelOrder (array_merge($request, $params));
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            throw new NotSupported($this->id . ' cancelAllOrders() is not supported on ' . $market['type'] . ' markets');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        return $this->contractV2PrivatePostTradeCancelAllOrders (array_merge($request, $params));
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $request = array(
            'id' => (string) $id,
            'currency' => $this->market_id($symbol),
        );
        $response = $this->spotV1PrivateGetGetOrder (array_merge($request, $params));
        //
        //     {
        //         'total_amount' => 0.01,
        //         'id' => '20180910244276459',
        //         'price' => 180.0,
        //         'trade_date' => 1536576744960,
        //         'status' => 2,
        //         'trade_money' => '1.96742',
        //         'trade_amount' => 0.01,
        //         'type' => 0,
        //         'currency' => 'eth_usdt'
        //     }
        //
        return $this->parse_order($response, null);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = 50, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . 'fetchOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency' => $market['id'],
            'pageIndex' => 1, // default pageIndex is 1
            'pageSize' => $limit, // default pageSize is 50
        );
        $method = 'spotV1PrivateGetGetOrdersIgnoreTradeType';
        // tradeType 交易类型1/0[buy/sell]
        if (is_array($params) && array_key_exists('tradeType', $params)) {
            $method = 'spotV1PrivateGetGetOrdersNew';
        }
        $response = null;
        try {
            $response = $this->$method (array_merge($request, $params));
        } catch (Exception $e) {
            if ($e instanceof OrderNotFound) {
                return array();
            }
            throw $e;
        }
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = 10, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . 'fetchClosedOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency' => $market['id'],
            'pageIndex' => 1, // default pageIndex is 1
            'pageSize' => $limit, // default pageSize is 10, doesn't work with other values now
        );
        $response = $this->spotV1PrivateGetGetFinishedAndPartialOrders (array_merge($request, $params));
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = 10, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . 'fetchOpenOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency' => $market['id'],
            'pageIndex' => 1, // default pageIndex is 1
            'pageSize' => $limit, // default pageSize is 10
        );
        $method = 'spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType';
        // tradeType 交易类型1/0[buy/sell]
        if (is_array($params) && array_key_exists('tradeType', $params)) {
            $method = 'spotV1PrivateGetGetOrdersNew';
        }
        $response = null;
        try {
            $response = $this->$method (array_merge($request, $params));
        } catch (Exception $e) {
            if ($e instanceof OrderNotFound) {
                return array();
            }
            throw $e;
        }
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function parse_order($order, $market = null) {
        //
        //     array(
        //         acctType => 0,
        //         currency => 'btc_usdt',
        //         fees => 3.6e-7,
        //         $id => '202102282829772463',
        //         $price => 45177.5,
        //         $status => 2,
        //         total_amount => 0.0002,
        //         trade_amount => 0.0002,
        //         trade_date => 1614515104998,
        //         trade_money => 8.983712,
        //         $type => 1,
        //         useZbFee => false
        //     ),
        //
        $side = $this->safe_integer($order, 'type');
        $side = ($side === 1) ? 'buy' : 'sell';
        $type = 'limit'; // $market $order is not availalbe in ZB
        $timestamp = $this->safe_integer($order, 'trade_date');
        $marketId = $this->safe_string($order, 'currency');
        $market = $this->safe_market($marketId, $market, '_');
        $price = $this->safe_string($order, 'price');
        $filled = $this->safe_string($order, 'trade_amount');
        $amount = $this->safe_string($order, 'total_amount');
        $cost = $this->safe_string($order, 'trade_money');
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $id = $this->safe_string($order, 'id');
        $feeCost = $this->safe_number($order, 'fees');
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrency = null;
            $zbFees = $this->safe_value($order, 'useZbFee');
            if ($zbFees === true) {
                $feeCurrency = 'ZB';
            } else {
                $feeCurrency = ($side === 'sell') ? $market['quote'] : $market['base'];
            }
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => null,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => null,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            '0' => 'open',
            '1' => 'canceled',
            '2' => 'closed',
            '3' => 'open', // partial
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            '0' => 'pending', // submitted, pending confirmation
            '1' => 'failed',
            '2' => 'ok',
            '3' => 'canceled',
            '5' => 'ok', // confirmed
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // withdraw
        //
        //     {
        //         "code" => 1000,
        //         "message" => "success",
        //         "id" => "withdrawalId"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amount" => 0.01,
        //         "fees" => 0.001,
        //         "id" => 2016042556231,
        //         "manageTime" => 1461579340000,
        //         "status" => 3,
        //         "submitTime" => 1461579288000,
        //         "toAddress" => "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "address" => "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //         "amount" => "1.00000000",
        //         "confirmTimes" => 1,
        //         "currency" => "BTC",
        //         "description" => "Successfully Confirm",
        //         "hash" => "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //         "id" => 558,
        //         "itransfer" => 1,
        //         "status" => 2,
        //         "submit_time" => "2016-12-07 18:51:57",
        //     }
        //
        $id = $this->safe_string($transaction, 'id');
        $txid = $this->safe_string($transaction, 'hash');
        $amount = $this->safe_number($transaction, 'amount');
        $timestamp = $this->parse8601($this->safe_string($transaction, 'submit_time'));
        $timestamp = $this->safe_integer($transaction, 'submitTime', $timestamp);
        $address = $this->safe_string_2($transaction, 'toAddress', 'address');
        $tag = null;
        if ($address !== null) {
            $parts = explode('_', $address);
            $address = $this->safe_string($parts, 0);
            $tag = $this->safe_string($parts, 1);
        }
        $confirmTimes = $this->safe_integer($transaction, 'confirmTimes');
        $updated = $this->safe_integer($transaction, 'manageTime');
        $type = null;
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId, $currency);
        if ($address !== null) {
            $type = ($confirmTimes === null) ? 'withdrawal' : 'deposit';
        }
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        $fee = null;
        $feeCost = $this->safe_number($transaction, 'fees');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => null,
            'addressFrom' => null,
            'address' => $address,
            'addressTo' => $address,
            'tagFrom' => null,
            'tag' => $tag,
            'tagTo' => $tag,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => $fee,
        );
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        if (($leverage < 1) || ($leverage > 125)) {
            throw new BadRequest($this->id . ' $leverage should be between 1 and 125');
        }
        $market = $this->market($symbol);
        $accountType = null;
        if (!$market['swap']) {
            throw new BadSymbol($this->id . ' setLeverage() supports swap contracts only');
        } else {
            $accountType = 1;
        }
        $request = array(
            'symbol' => $market['id'],
            'leverage' => $leverage,
            'futuresAccountType' => $accountType, // 1 => USDT perpetual swaps
        );
        return $this->contractV2PrivatePostSettingSetLeverage (array_merge($request, $params));
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'symbol' => $market['id'],
            // 'startTime' => $since,
            // 'endTime' => $endTime, // current time by default
            // 'limit' => $limit, // default 100, max 1000
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $till = $this->safe_integer($params, 'till');
        $endTime = $this->safe_string($params, 'endTime');
        $params = $this->omit($params, array( 'endTime', 'till' ));
        if ($till !== null) {
            $request['endTime'] = $till;
        } else if ($endTime !== null) {
            $request['endTime'] = $endTime;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->contractV2PublicGetFundingRate (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "data" => array(
        //             array(
        //                 "symbol" => "BTC_USDT",
        //                 "fundingRate" => "0.0001",
        //                 "fundingTime" => "1645171200000"
        //             ),
        //         ),
        //         "desc" => "操作成功"
        //     }
        //
        $data = $this->safe_value($response, 'data');
        $rates = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $marketId = $this->safe_string($entry, 'symbol');
            $symbol = $this->safe_symbol($marketId);
            $timestamp = $this->safe_string($entry, 'fundingTime');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new BadSymbol($this->id . ' fetchFundingRate() does not supports contracts only');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->contractV1PublicGetFundingRate (array_merge($request, $params));
        //
        //     {
        //         "code" => 10000,
        //         "desc" => "操作成功",
        //         "data" => {
        //             "fundingRate" => "0.0001",
        //             "nextCalculateTime" => "2022-02-19 00:00:00"
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_funding_rate($data, $market);
    }

    public function parse_funding_rate($contract, $market = null) {
        //
        //     {
        //         "fundingRate" => "0.0001",
        //         "nextCalculateTime" => "2022-02-19 00:00:00"
        //     }
        //
        $marketId = $this->safe_string($contract, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $fundingRate = $this->safe_number($contract, 'fundingRate');
        $nextFundingDatetime = $this->safe_string($contract, 'nextCalculateTime');
        return array(
            'info' => $contract,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => null,
            'fundingDatetime' => null,
            'nextFundingRate' => null,
            'nextFundingTimestamp' => $this->parse8601($nextFundingDatetime),
            'nextFundingDatetime' => $nextFundingDatetime,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $password = $this->safe_string($params, 'safePwd', $this->password);
        if ($password === null) {
            throw new ArgumentsRequired($this->id . ' withdraw() requires exchange.password or a safePwd parameter');
        }
        $fees = $this->safe_number($params, 'fees');
        if ($fees === null) {
            throw new ArgumentsRequired($this->id . ' withdraw() requires a $fees parameter');
        }
        $this->check_address($address);
        $this->load_markets();
        $currency = $this->currency($code);
        if ($tag !== null) {
            $address .= '_' . $tag;
        }
        $request = array(
            'amount' => $this->currency_to_precision($code, $amount),
            'currency' => $currency['id'],
            'fees' => $this->currency_to_precision($code, $fees),
            // 'itransfer' => 0, // agree for an internal transfer, 0 disagree, 1 agree, the default is to disagree
            'method' => 'withdraw',
            'receiveAddr' => $address,
            'safePwd' => $password,
        );
        $response = $this->spotV1PrivateGetWithdraw (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => "success",
        //         "id" => "withdrawalId"
        //     }
        //
        $transaction = $this->parse_transaction($response, $currency);
        return array_merge($transaction, array(
            'type' => 'withdrawal',
            'address' => $address,
            'addressTo' => $address,
            'amount' => $amount,
        ));
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'],
            // 'pageIndex' => 1,
            // 'pageSize' => $limit,
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        $response = $this->spotV1PrivateGetGetWithdrawRecord (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => {
        //                 "list" => array(
        //                     array(
        //                         "amount" => 0.01,
        //                         "fees" => 0.001,
        //                         "id" => 2016042556231,
        //                         "manageTime" => 1461579340000,
        //                         "status" => 3,
        //                         "submitTime" => 1461579288000,
        //                         "toAddress" => "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        //                     ),
        //                 ),
        //                 "pageIndex" => 1,
        //                 "pageSize" => 10,
        //                 "totalCount" => 4,
        //                 "totalPage" => 1
        //             }
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        $withdrawals = $this->safe_value($datas, 'list', array());
        return $this->parse_transactions($withdrawals, $currency, $since, $limit);
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'],
            // 'pageIndex' => 1,
            // 'pageSize' => $limit,
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['pageSize'] = $limit;
        }
        $response = $this->spotV1PrivateGetGetChargeRecord (array_merge($request, $params));
        //
        //     {
        //         "code" => 1000,
        //         "message" => {
        //             "des" => "success",
        //             "isSuc" => true,
        //             "datas" => {
        //                 "list" => array(
        //                     array(
        //                         "address" => "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        //                         "amount" => "1.00000000",
        //                         "confirmTimes" => 1,
        //                         "currency" => "BTC",
        //                         "description" => "Successfully Confirm",
        //                         "hash" => "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        //                         "id" => 558,
        //                         "itransfer" => 1,
        //                         "status" => 2,
        //                         "submit_time" => "2016-12-07 18:51:57",
        //                     ),
        //                 ),
        //                 "pageIndex" => 1,
        //                 "pageSize" => 10,
        //                 "total" => 8
        //             }
        //         }
        //     }
        //
        $message = $this->safe_value($response, 'message', array());
        $datas = $this->safe_value($message, 'datas', array());
        $deposits = $this->safe_value($datas, 'list', array());
        return $this->parse_transactions($deposits, $currency, $since, $limit);
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($section, $version, $access) = $api;
        $url = $this->urls['api'][$section][$version][$access];
        if ($access === 'public') {
            if ($path === 'getFeeInfo') {
                $url = $this->urls['api'][$section][$version]['private'] . '/' . $path;
            } else {
                $url .= '/' . $version . '/' . $path;
            }
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else if ($section === 'contract') {
            $timestamp = $this->milliseconds();
            $iso8601 = $this->iso8601($timestamp);
            $signedString = $iso8601 . $method . '/Server/api/' . $version . '/' . $path;
            $params = $this->keysort($params);
            $headers = array(
                'ZB-APIKEY' => $this->apiKey,
                'ZB-TIMESTAMP' => $iso8601,
                // 'ZB-LAN' => 'cn', // cn, en, kr
            );
            $url .= '/' . $version . '/' . $path;
            if ($method === 'POST') {
                $headers['Content-Type'] = 'application/json';
                $body = $this->json($params);
                $signedString .= $this->urlencode($params);
            } else {
                if ($params) {
                    $query = $this->urlencode($params);
                    $url .= '?' . $query;
                    $signedString .= $query;
                }
            }
            $secret = $this->hash($this->encode($this->secret), 'sha1');
            $signature = $this->hmac($this->encode($signedString), $this->encode($secret), 'sha256', 'base64');
            $headers['ZB-SIGN'] = $signature;
        } else {
            $query = $this->keysort(array_merge(array(
                'method' => $path,
                'accesskey' => $this->apiKey,
            ), $params));
            $nonce = $this->nonce();
            $query = $this->keysort($query);
            $auth = $this->rawencode($query);
            $secret = $this->hash($this->encode($this->secret), 'sha1');
            $signature = $this->hmac($this->encode($auth), $this->encode($secret), 'md5');
            $suffix = 'sign=' . $signature . '&reqTime=' . (string) $nonce;
            $url .= '/' . $path . '?' . $auth . '&' . $suffix;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // fallback to default error handler
        }
        if ($body[0] === '{') {
            $feedback = $this->id . ' ' . $body;
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            if (is_array($response) && array_key_exists('code', $response)) {
                $code = $this->safe_string($response, 'code');
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
                if (($code !== '1000') && ($code !== '10000')) {
                    throw new ExchangeError($feedback);
                }
            }
            // special case for array("result":false,"message":"服务端忙碌") (a "Busy Server" reply)
            $result = $this->safe_value($response, 'result');
            if ($result !== null) {
                if (!$result) {
                    $message = $this->safe_string($response, 'message');
                    if ($message === '服务端忙碌') {
                        throw new ExchangeNotAvailable($feedback);
                    } else {
                        throw new ExchangeError($feedback);
                    }
                }
            }
        }
    }
}
