/**
 * Auto-generated by SBE (Simple Binary Encoding)
 * Schema: spot_sbe
 * DO NOT EDIT
 */
export class OrderResponseDecoder {
    constructor(byteOrder = 'little') {
        this.littleEndian = byteOrder === 'little';
    }
    decode(buffer, offset = 0) {
        const view = new DataView(buffer);
        let pos = offset;
        const priceExponent = view.getInt8(pos);
        pos += 1;
        const qtyExponent = view.getInt8(pos);
        pos += 1;
        const orderId = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const orderListId = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const price = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const origQty = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const executedQty = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const cummulativeQuoteQty = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const status = view.getUint8(pos);
        pos += 1;
        const timeInForce = view.getUint8(pos);
        pos += 1;
        const orderType = view.getUint8(pos);
        pos += 1;
        const side = view.getUint8(pos);
        pos += 1;
        const stopPrice = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const trailingDelta = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const trailingTime = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const icebergQty = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const time = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const updateTime = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const isWorking = view.getUint8(pos);
        pos += 1;
        const workingTime = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const origQuoteOrderQty = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const strategyId = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const strategyType = view.getInt32(pos, this.littleEndian);
        pos += 4;
        const orderCapacity = view.getUint8(pos);
        pos += 1;
        const workingFloor = view.getUint8(pos);
        pos += 1;
        const selfTradePreventionMode = view.getUint8(pos);
        pos += 1;
        const preventedMatchId = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const preventedQuantity = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const usedSor = view.getUint8(pos);
        pos += 1;
        const pegPriceType = view.getUint8(pos);
        pos += 1;
        const pegOffsetType = view.getUint8(pos);
        pos += 1;
        const pegOffsetValue = view.getUint8(pos);
        pos += 1;
        const peggedPrice = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        // Skip to end of block for forward compatibility
        pos = offset + OrderResponseDecoder.BLOCK_LENGTH;
        const symbol = this.decodeVarData(view, pos);
        pos = symbol.nextOffset;
        const clientOrderId = this.decodeVarData(view, pos);
        pos = clientOrderId.nextOffset;
        return {
            priceExponent: priceExponent,
            qtyExponent: qtyExponent,
            orderId: orderId,
            orderListId: orderListId,
            price: price,
            origQty: origQty,
            executedQty: executedQty,
            cummulativeQuoteQty: cummulativeQuoteQty,
            status: status,
            timeInForce: timeInForce,
            orderType: orderType,
            side: side,
            stopPrice: stopPrice,
            trailingDelta: trailingDelta,
            trailingTime: trailingTime,
            icebergQty: icebergQty,
            time: time,
            updateTime: updateTime,
            isWorking: isWorking,
            workingTime: workingTime,
            origQuoteOrderQty: origQuoteOrderQty,
            strategyId: strategyId,
            strategyType: strategyType,
            orderCapacity: orderCapacity,
            workingFloor: workingFloor,
            selfTradePreventionMode: selfTradePreventionMode,
            preventedMatchId: preventedMatchId,
            preventedQuantity: preventedQuantity,
            usedSor: usedSor,
            pegPriceType: pegPriceType,
            pegOffsetType: pegOffsetType,
            pegOffsetValue: pegOffsetValue,
            peggedPrice: peggedPrice,
            symbol: symbol.value,
            clientOrderId: clientOrderId.value
        };
    }
    decodeVarData(view, offset) {
        let pos = offset;
        const length = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const value = new Uint8Array(view.buffer, view.byteOffset + pos, length);
        pos += length;
        return { value, nextOffset: pos };
    }
    static getBlockLength() {
        return OrderResponseDecoder.BLOCK_LENGTH;
    }
    static getTemplateId() {
        return OrderResponseDecoder.TEMPLATE_ID;
    }
    static getSchemaId() {
        return OrderResponseDecoder.SCHEMA_ID;
    }
    static getSchemaVersion() {
        return OrderResponseDecoder.SCHEMA_VERSION;
    }
}
OrderResponseDecoder.BLOCK_LENGTH = 162;
OrderResponseDecoder.TEMPLATE_ID = 304;
OrderResponseDecoder.SCHEMA_ID = 3;
OrderResponseDecoder.SCHEMA_VERSION = 2;
