/**
 * Auto-generated by SBE (Simple Binary Encoding)
 * Schema: spot_sbe
 * DO NOT EDIT
 */
export class OrdersResponseDecoder {
    constructor(byteOrder = 'little') {
        this.littleEndian = byteOrder === 'little';
    }
    decode(buffer, offset = 0) {
        const view = new DataView(buffer);
        let pos = offset;
        // Skip to end of block for forward compatibility
        pos = offset + OrdersResponseDecoder.BLOCK_LENGTH;
        const orders = this.decodeOrdersGroup(view, pos);
        pos = orders.nextOffset;
        return {
            orders: orders.items
        };
    }
    decodeOrdersGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            const priceExponent = view.getInt8(pos);
            pos += 1;
            const qtyExponent = view.getInt8(pos);
            pos += 1;
            const orderId = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const orderListId = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const price = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const origQty = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const executedQty = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const cummulativeQuoteQty = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const status = view.getUint8(pos);
            pos += 1;
            const timeInForce = view.getUint8(pos);
            pos += 1;
            const orderType = view.getUint8(pos);
            pos += 1;
            const side = view.getUint8(pos);
            pos += 1;
            const stopPrice = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const trailingDelta = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const trailingTime = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const icebergQty = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const time = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const updateTime = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const isWorking = view.getUint8(pos);
            pos += 1;
            const workingTime = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const origQuoteOrderQty = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const strategyId = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const strategyType = view.getInt32(pos, this.littleEndian);
            pos += 4;
            const orderCapacity = view.getUint8(pos);
            pos += 1;
            const workingFloor = view.getUint8(pos);
            pos += 1;
            const selfTradePreventionMode = view.getUint8(pos);
            pos += 1;
            const preventedMatchId = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const preventedQuantity = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const usedSor = view.getUint8(pos);
            pos += 1;
            const pegPriceType = view.getUint8(pos);
            pos += 1;
            const pegOffsetType = view.getUint8(pos);
            pos += 1;
            const pegOffsetValue = view.getUint8(pos);
            pos += 1;
            const peggedPrice = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({
                priceExponent: priceExponent,
                qtyExponent: qtyExponent,
                orderId: orderId,
                orderListId: orderListId,
                price: price,
                origQty: origQty,
                executedQty: executedQty,
                cummulativeQuoteQty: cummulativeQuoteQty,
                status: status,
                timeInForce: timeInForce,
                orderType: orderType,
                side: side,
                stopPrice: stopPrice,
                trailingDelta: trailingDelta,
                trailingTime: trailingTime,
                icebergQty: icebergQty,
                time: time,
                updateTime: updateTime,
                isWorking: isWorking,
                workingTime: workingTime,
                origQuoteOrderQty: origQuoteOrderQty,
                strategyId: strategyId,
                strategyType: strategyType,
                orderCapacity: orderCapacity,
                workingFloor: workingFloor,
                selfTradePreventionMode: selfTradePreventionMode,
                preventedMatchId: preventedMatchId,
                preventedQuantity: preventedQuantity,
                usedSor: usedSor,
                pegPriceType: pegPriceType,
                pegOffsetType: pegOffsetType,
                pegOffsetValue: pegOffsetValue,
                peggedPrice: peggedPrice
            });
        }
        return { items, nextOffset: pos };
    }
    static getBlockLength() {
        return OrdersResponseDecoder.BLOCK_LENGTH;
    }
    static getTemplateId() {
        return OrdersResponseDecoder.TEMPLATE_ID;
    }
    static getSchemaId() {
        return OrdersResponseDecoder.SCHEMA_ID;
    }
    static getSchemaVersion() {
        return OrdersResponseDecoder.SCHEMA_VERSION;
    }
}
OrdersResponseDecoder.BLOCK_LENGTH = 0;
OrdersResponseDecoder.TEMPLATE_ID = 308;
OrdersResponseDecoder.SCHEMA_ID = 3;
OrdersResponseDecoder.SCHEMA_VERSION = 2;
