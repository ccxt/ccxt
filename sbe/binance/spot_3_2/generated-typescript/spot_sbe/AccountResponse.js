/**
 * Auto-generated by SBE (Simple Binary Encoding)
 * Schema: spot_sbe
 * DO NOT EDIT
 */
export class AccountResponseDecoder {
    constructor(byteOrder = 'little') {
        this.littleEndian = byteOrder === 'little';
    }
    decode(buffer, offset = 0) {
        const view = new DataView(buffer);
        let pos = offset;
        const commissionExponent = view.getInt8(pos);
        pos += 1;
        const commissionRateMaker = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const commissionRateTaker = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const commissionRateBuyer = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const commissionRateSeller = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const canTrade = view.getUint8(pos);
        pos += 1;
        const canWithdraw = view.getUint8(pos);
        pos += 1;
        const canDeposit = view.getUint8(pos);
        pos += 1;
        const brokered = view.getUint8(pos);
        pos += 1;
        const requireSelfTradePrevention = view.getUint8(pos);
        pos += 1;
        const preventSor = view.getUint8(pos);
        pos += 1;
        const updateTime = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const accountType = view.getUint8(pos);
        pos += 1;
        const tradeGroupId = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const uid = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        // Skip to end of block for forward compatibility
        pos = offset + AccountResponseDecoder.BLOCK_LENGTH;
        const balances = this.decodeBalancesGroup(view, pos);
        pos = balances.nextOffset;
        const permissions = this.decodePermissionsGroup(view, pos);
        pos = permissions.nextOffset;
        const reduceOnlyAssets = this.decodeReduceOnlyAssetsGroup(view, pos);
        pos = reduceOnlyAssets.nextOffset;
        return {
            commissionExponent: commissionExponent,
            commissionRateMaker: commissionRateMaker,
            commissionRateTaker: commissionRateTaker,
            commissionRateBuyer: commissionRateBuyer,
            commissionRateSeller: commissionRateSeller,
            canTrade: canTrade,
            canWithdraw: canWithdraw,
            canDeposit: canDeposit,
            brokered: brokered,
            requireSelfTradePrevention: requireSelfTradePrevention,
            preventSor: preventSor,
            updateTime: updateTime,
            accountType: accountType,
            tradeGroupId: tradeGroupId,
            uid: uid,
            balances: balances.items,
            permissions: permissions.items,
            reduceOnlyAssets: reduceOnlyAssets.items
        };
    }
    decodeBalancesGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            const exponent = view.getInt8(pos);
            pos += 1;
            const free = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const locked = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({
                exponent: exponent,
                free: free,
                locked: locked
            });
        }
        return { items, nextOffset: pos };
    }
    decodePermissionsGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({});
        }
        return { items, nextOffset: pos };
    }
    decodeReduceOnlyAssetsGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({});
        }
        return { items, nextOffset: pos };
    }
    static getBlockLength() {
        return AccountResponseDecoder.BLOCK_LENGTH;
    }
    static getTemplateId() {
        return AccountResponseDecoder.TEMPLATE_ID;
    }
    static getSchemaId() {
        return AccountResponseDecoder.SCHEMA_ID;
    }
    static getSchemaVersion() {
        return AccountResponseDecoder.SCHEMA_VERSION;
    }
}
AccountResponseDecoder.BLOCK_LENGTH = 64;
AccountResponseDecoder.TEMPLATE_ID = 400;
AccountResponseDecoder.SCHEMA_ID = 3;
AccountResponseDecoder.SCHEMA_VERSION = 2;
