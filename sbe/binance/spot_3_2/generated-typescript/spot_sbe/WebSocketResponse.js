/**
 * Auto-generated by SBE (Simple Binary Encoding)
 * Schema: spot_sbe
 * DO NOT EDIT
 */
export class WebSocketResponseDecoder {
    constructor(byteOrder = 'little') {
        this.littleEndian = byteOrder === 'little';
    }
    decode(buffer, offset = 0) {
        const view = new DataView(buffer);
        let pos = offset;
        const sbeSchemaIdVersionDeprecated = view.getUint8(pos);
        pos += 1;
        const status = view.getUint16(pos, this.littleEndian);
        pos += 2;
        // Skip to end of block for forward compatibility
        pos = offset + WebSocketResponseDecoder.BLOCK_LENGTH;
        const rateLimits = this.decodeRateLimitsGroup(view, pos);
        pos = rateLimits.nextOffset;
        const id = this.decodeVarData(view, pos);
        pos = id.nextOffset;
        const result = this.decodeVarData(view, pos);
        pos = result.nextOffset;
        return {
            sbeSchemaIdVersionDeprecated: sbeSchemaIdVersionDeprecated,
            status: status,
            rateLimits: rateLimits.items,
            id: id.value,
            result: result.value
        };
    }
    decodeRateLimitsGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            const rateLimitType = view.getUint8(pos);
            pos += 1;
            const interval = view.getUint8(pos);
            pos += 1;
            const intervalNum = view.getUint8(pos);
            pos += 1;
            const rateLimit = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            const current = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({
                rateLimitType: rateLimitType,
                interval: interval,
                intervalNum: intervalNum,
                rateLimit: rateLimit,
                current: current
            });
        }
        return { items, nextOffset: pos };
    }
    decodeVarData(view, offset) {
        let pos = offset;
        const length = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const value = new Uint8Array(view.buffer, view.byteOffset + pos, length);
        pos += length;
        return { value, nextOffset: pos };
    }
    static getBlockLength() {
        return WebSocketResponseDecoder.BLOCK_LENGTH;
    }
    static getTemplateId() {
        return WebSocketResponseDecoder.TEMPLATE_ID;
    }
    static getSchemaId() {
        return WebSocketResponseDecoder.SCHEMA_ID;
    }
    static getSchemaVersion() {
        return WebSocketResponseDecoder.SCHEMA_VERSION;
    }
}
WebSocketResponseDecoder.BLOCK_LENGTH = 3;
WebSocketResponseDecoder.TEMPLATE_ID = 50;
WebSocketResponseDecoder.SCHEMA_ID = 3;
WebSocketResponseDecoder.SCHEMA_VERSION = 2;
