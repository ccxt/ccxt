/**
 * Auto-generated by SBE (Simple Binary Encoding)
 * Schema: spot_sbe
 * DO NOT EDIT
 */
export class ErrorResponseDecoder {
    constructor(byteOrder = 'little') {
        this.littleEndian = byteOrder === 'little';
    }
    decode(buffer, offset = 0) {
        const view = new DataView(buffer);
        let pos = offset;
        const code = view.getInt16(pos, this.littleEndian);
        pos += 2;
        const serverTime = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        const retryAfter = view.getBigInt64(pos, this.littleEndian);
        pos += 8;
        // Skip to end of block for forward compatibility
        pos = offset + ErrorResponseDecoder.BLOCK_LENGTH;
        const msg = this.decodeVarData(view, pos);
        pos = msg.nextOffset;
        const data = this.decodeVarData(view, pos);
        pos = data.nextOffset;
        return {
            code: code,
            serverTime: serverTime,
            retryAfter: retryAfter,
            msg: msg.value,
            data: data.value
        };
    }
    decodeVarData(view, offset) {
        let pos = offset;
        const length = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const value = new Uint8Array(view.buffer, view.byteOffset + pos, length);
        pos += length;
        return { value, nextOffset: pos };
    }
    static getBlockLength() {
        return ErrorResponseDecoder.BLOCK_LENGTH;
    }
    static getTemplateId() {
        return ErrorResponseDecoder.TEMPLATE_ID;
    }
    static getSchemaId() {
        return ErrorResponseDecoder.SCHEMA_ID;
    }
    static getSchemaVersion() {
        return ErrorResponseDecoder.SCHEMA_VERSION;
    }
}
ErrorResponseDecoder.BLOCK_LENGTH = 18;
ErrorResponseDecoder.TEMPLATE_ID = 100;
ErrorResponseDecoder.SCHEMA_ID = 3;
ErrorResponseDecoder.SCHEMA_VERSION = 2;
