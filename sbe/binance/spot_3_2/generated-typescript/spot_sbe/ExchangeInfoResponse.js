/**
 * Auto-generated by SBE (Simple Binary Encoding)
 * Schema: spot_sbe
 * DO NOT EDIT
 */
export class ExchangeInfoResponseDecoder {
    constructor(byteOrder = 'little') {
        this.littleEndian = byteOrder === 'little';
    }
    decode(buffer, offset = 0) {
        const view = new DataView(buffer);
        let pos = offset;
        // Skip to end of block for forward compatibility
        pos = offset + ExchangeInfoResponseDecoder.BLOCK_LENGTH;
        const rateLimits = this.decodeRateLimitsGroup(view, pos);
        pos = rateLimits.nextOffset;
        const exchangeFilters = this.decodeExchangeFiltersGroup(view, pos);
        pos = exchangeFilters.nextOffset;
        const symbols = this.decodeSymbolsGroup(view, pos);
        pos = symbols.nextOffset;
        const sors = this.decodeSorsGroup(view, pos);
        pos = sors.nextOffset;
        return {
            rateLimits: rateLimits.items,
            exchangeFilters: exchangeFilters.items,
            symbols: symbols.items,
            sors: sors.items
        };
    }
    decodeRateLimitsGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            const rateLimitType = view.getUint8(pos);
            pos += 1;
            const interval = view.getUint8(pos);
            pos += 1;
            const intervalNum = view.getUint8(pos);
            pos += 1;
            const rateLimit = view.getBigInt64(pos, this.littleEndian);
            pos += 8;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({
                rateLimitType: rateLimitType,
                interval: interval,
                intervalNum: intervalNum,
                rateLimit: rateLimit
            });
        }
        return { items, nextOffset: pos };
    }
    decodeExchangeFiltersGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({});
        }
        return { items, nextOffset: pos };
    }
    decodeSymbolsGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            const status = view.getUint8(pos);
            pos += 1;
            const baseAssetPrecision = view.getUint8(pos);
            pos += 1;
            const quoteAssetPrecision = view.getUint8(pos);
            pos += 1;
            const baseCommissionPrecision = view.getUint8(pos);
            pos += 1;
            const quoteCommissionPrecision = view.getUint8(pos);
            pos += 1;
            const orderTypes = view.getUint16(pos, this.littleEndian);
            pos += 2;
            const icebergAllowed = view.getUint8(pos);
            pos += 1;
            const ocoAllowed = view.getUint8(pos);
            pos += 1;
            const otoAllowed = view.getUint8(pos);
            pos += 1;
            const quoteOrderQtyMarketAllowed = view.getUint8(pos);
            pos += 1;
            const allowTrailingStop = view.getUint8(pos);
            pos += 1;
            const cancelReplaceAllowed = view.getUint8(pos);
            pos += 1;
            const amendAllowed = view.getUint8(pos);
            pos += 1;
            const isSpotTradingAllowed = view.getUint8(pos);
            pos += 1;
            const isMarginTradingAllowed = view.getUint8(pos);
            pos += 1;
            const defaultSelfTradePreventionMode = view.getUint8(pos);
            pos += 1;
            const allowedSelfTradePreventionModes = view.getUint8(pos);
            pos += 1;
            const pegInstructionsAllowed = view.getUint8(pos);
            pos += 1;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({
                status: status,
                baseAssetPrecision: baseAssetPrecision,
                quoteAssetPrecision: quoteAssetPrecision,
                baseCommissionPrecision: baseCommissionPrecision,
                quoteCommissionPrecision: quoteCommissionPrecision,
                orderTypes: orderTypes,
                icebergAllowed: icebergAllowed,
                ocoAllowed: ocoAllowed,
                otoAllowed: otoAllowed,
                quoteOrderQtyMarketAllowed: quoteOrderQtyMarketAllowed,
                allowTrailingStop: allowTrailingStop,
                cancelReplaceAllowed: cancelReplaceAllowed,
                amendAllowed: amendAllowed,
                isSpotTradingAllowed: isSpotTradingAllowed,
                isMarginTradingAllowed: isMarginTradingAllowed,
                defaultSelfTradePreventionMode: defaultSelfTradePreventionMode,
                allowedSelfTradePreventionModes: allowedSelfTradePreventionModes,
                pegInstructionsAllowed: pegInstructionsAllowed
            });
        }
        return { items, nextOffset: pos };
    }
    decodeSorsGroup(view, offset) {
        let pos = offset;
        const blockLength = view.getUint16(pos, this.littleEndian);
        pos += 2;
        const numInGroup = view.getUint32(pos, this.littleEndian);
        pos += 4;
        const items = [];
        for (let i = 0; i < numInGroup; i++) {
            const itemStart = pos;
            // Skip to next block for forward compatibility
            pos = itemStart + blockLength;
            items.push({});
        }
        return { items, nextOffset: pos };
    }
    static getBlockLength() {
        return ExchangeInfoResponseDecoder.BLOCK_LENGTH;
    }
    static getTemplateId() {
        return ExchangeInfoResponseDecoder.TEMPLATE_ID;
    }
    static getSchemaId() {
        return ExchangeInfoResponseDecoder.SCHEMA_ID;
    }
    static getSchemaVersion() {
        return ExchangeInfoResponseDecoder.SCHEMA_VERSION;
    }
}
ExchangeInfoResponseDecoder.BLOCK_LENGTH = 0;
ExchangeInfoResponseDecoder.TEMPLATE_ID = 103;
ExchangeInfoResponseDecoder.SCHEMA_ID = 3;
ExchangeInfoResponseDecoder.SCHEMA_VERSION = 2;
