# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.bithumb import ImplicitAPI
import asyncio
import hashlib
from ccxt.base.types import Any, Balances, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Str, Strings, Ticker, Tickers, Trade, MarketInterface
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import DECIMAL_PLACES
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS
from ccxt.base.precise import Precise


class bithumb(Exchange, ImplicitAPI):

    def describe(self) -> Any:
        return self.deep_extend(super(bithumb, self).describe(), {
            'id': 'bithumb',
            'name': 'Bithumb',
            'countries': ['KR'],  # South Korea
            'rateLimit': 500,
            'pro': True,
            'has': {
                'CORS': True,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'addMargin': False,
                'borrowCrossMargin': False,
                'borrowIsolatedMargin': False,
                'borrowMargin': False,
                'cancelOrder': True,
                'closeAllPositions': False,
                'closePosition': False,
                'createMarketOrder': True,
                'createOrder': True,
                'createOrderWithTakeProfitAndStopLoss': False,
                'createOrderWithTakeProfitAndStopLossWs': False,
                'createReduceOnlyOrder': False,
                'fetchBalance': True,
                'fetchBorrowInterest': False,
                'fetchBorrowRate': False,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchBorrowRates': False,
                'fetchBorrowRatesPerSymbol': False,
                'fetchCrossBorrowRate': False,
                'fetchCrossBorrowRates': False,
                'fetchCurrencies': False,
                'fetchFundingHistory': False,
                'fetchFundingInterval': False,
                'fetchFundingIntervals': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchGreeks': False,
                'fetchIndexOHLCV': False,
                'fetchIsolatedBorrowRate': False,
                'fetchIsolatedBorrowRates': False,
                'fetchIsolatedPositions': False,
                'fetchLeverage': False,
                'fetchLeverages': False,
                'fetchLeverageTiers': False,
                'fetchLiquidations': False,
                'fetchLongShortRatio': False,
                'fetchLongShortRatioHistory': False,
                'fetchMarginAdjustmentHistory': False,
                'fetchMarginMode': False,
                'fetchMarginModes': False,
                'fetchMarketLeverageTiers': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMarkPrices': False,
                'fetchMyLiquidations': False,
                'fetchMySettlementHistory': False,
                'fetchOHLCV': True,
                'fetchOpenInterest': False,
                'fetchOpenInterestHistory': False,
                'fetchOpenInterests': False,
                'fetchOpenOrders': True,
                'fetchOption': False,
                'fetchOptionChain': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchPosition': False,
                'fetchPositionHistory': False,
                'fetchPositionMode': False,
                'fetchPositions': False,
                'fetchPositionsForSymbol': False,
                'fetchPositionsHistory': False,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchSettlementHistory': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'fetchVolatilityHistory': False,
                'reduceMargin': False,
                'repayCrossMargin': False,
                'repayIsolatedMargin': False,
                'setLeverage': False,
                'setMargin': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'transfer': False,
                'withdraw': True,
            },
            'hostname': 'bithumb.com',
            'urls': {
                'logo': 'https://github.com/user-attachments/assets/c9e0eefb-4777-46b9-8f09-9d7f7c4af82d',
                'api': {
                    'public': 'https://api.{hostname}/public',
                    'private': 'https://api.{hostname}',
                    'v2public': 'https://api.bithumb.com/v1',
                    'v2private': 'https://api.bithumb.com/v1',
                    'v2order': 'https://api.bithumb.com/v2',
                },
                'www': 'https://www.bithumb.com',
                'doc': 'https://apidocs.bithumb.com',
                'fees': 'https://en.bithumb.com/customer_support/info_fee',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker/ALL_{quoteId}',
                        'ticker/{baseId}_{quoteId}',
                        'orderbook/ALL_{quoteId}',
                        'orderbook/{baseId}_{quoteId}',
                        'transaction_history/{baseId}_{quoteId}',
                        'network-info',
                        'assetsstatus/multichain/ALL',
                        'assetsstatus/multichain/{currency}',
                        'withdraw/minimum/ALL',
                        'withdraw/minimum/{currency}',
                        'assetsstatus/ALL',
                        'assetsstatus/{baseId}',
                        'candlestick/{baseId}_{quoteId}/{interval}',
                    ],
                },
                'private': {
                    'post': [
                        'info/account',
                        'info/balance',
                        'info/wallet_address',
                        'info/ticker',
                        'info/orders',
                        'info/user_transactions',
                        'info/order_detail',
                        'trade/place',
                        'trade/cancel',
                        'trade/btc_withdrawal',
                        'trade/krw_deposit',
                        'trade/krw_withdrawal',
                        'trade/market_buy',
                        'trade/market_sell',
                        'trade/stop_limit',
                    ],
                },
                'v2public': {
                    'get': [
                        'market/all',
                        'ticker',
                        'orderbook',
                        'trades/ticks',
                        'candles/minutes/{unit}',
                        'candles/{interval}',
                        'candlestick/{market}/{interval}',
                    ],
                },
                'v2private': {
                    'get': [
                        'accounts',
                        'orders/chance',
                        'order',
                        'orders',
                    ],
                    'post': [
                        'orders',
                    ],
                    'delete': [
                        'order',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': self.parse_number('0.0025'),
                    'taker': self.parse_number('0.0025'),
                },
            },
            'precisionMode': SIGNIFICANT_DIGITS,
            'features': {
                'spot': {
                    'sandbox': False,
                    'createOrder': {
                        'marginMode': False,
                        'triggerPrice': False,
                        'triggerPriceType': None,
                        'triggerDirection': False,
                        'stopLossPrice': False,
                        'takeProfitPrice': False,
                        'attachedStopLossTakeProfit': None,
                        'timeInForce': {
                            'IOC': False,
                            'FOK': False,
                            'PO': False,
                            'GTD': False,
                        },
                        'hedged': False,
                        'trailing': False,
                        'leverage': False,
                        'marketBuyRequiresPrice': False,
                        'marketBuyByCost': False,
                        'selfTradePrevention': False,
                        'iceberg': False,
                    },
                    'createOrders': None,
                    'fetchMyTrades': None,
                    'fetchOrder': {
                        'marginMode': False,
                        'trigger': False,
                        'trailing': False,
                        'symbolRequired': True,
                    },
                    'fetchOpenOrders': {
                        'marginMode': False,
                        'limit': 1000,
                        'trigger': False,
                        'trailing': False,
                        'symbolRequired': True,
                    },
                    'fetchOrders': None,
                    'fetchClosedOrders': None,
                    'fetchOHLCV': {
                        'limit': 1000,
                    },
                },
                'swap': {
                    'linear': None,
                    'inverse': None,
                },
                'future': {
                    'linear': None,
                    'inverse': None,
                },
            },
            'exceptions': {
                'Bad Request(SSL)': BadRequest,
                'Bad Request(Bad Method)': BadRequest,
                'Bad Request.(Auth Data)': AuthenticationError,  # {"status": "5100", "message": "Bad Request.(Auth Data)"}
                'Not Member': AuthenticationError,
                'Invalid Apikey': AuthenticationError,  # {"status":"5300","message":"Invalid Apikey"}
                'Method Not Allowed.(Access IP)': PermissionDenied,
                'Method Not Allowed.(BTC Adress)': InvalidAddress,
                'Method Not Allowed.(Access)': PermissionDenied,
                'Database Fail': ExchangeNotAvailable,
                'Invalid Parameter': BadRequest,
                '5600': ExchangeError,
                'Unknown Error': ExchangeError,
                'After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions': ExchangeError,  # {"status":"5100","message":"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions"}
            },
            'timeframes': {
                '1m': '1',
                '3m': '3',
                '5m': '5',
                '10m': '10',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '4h': '240',
                '1d': 'days',
                '1w': 'weeks',
                '1M': 'months',
            },
            'options': {
                'quoteCurrencies': {
                    'BTC': {
                        'limits': {
                            'cost': {
                                'min': 0.0002,
                                'max': 100,
                            },
                        },
                    },
                    'KRW': {
                        'limits': {
                            'cost': {
                                'min': 500,
                                'max': 5000000000,
                            },
                        },
                    },
                    'USDT': {
                        'limits': {
                            'cost': {
                                'min': None,
                                'max': None,
                            },
                        },
                    },
                },
            },
            'commonCurrencies': {
                'ALT': 'ArchLoot',
                'FTC': 'FTC2',
                'SOC': 'Soda Coin',
            },
        })

    def safe_market(self, marketId: Str = None, market: Market = None, delimiter: Str = None, marketType: Str = None) -> MarketInterface:
        # bithumb has a different type of conflict in markets, because
        # their ids are the base currency(BTC for instance), so we can have
        # multiple "BTC" ids representing the different markets(BTC/ETH, "BTC/DOGE", etc)
        # since they're the same we just need to return one
        return super(bithumb, self).safe_market(marketId, market, delimiter, 'spot')

    def amount_to_precision(self, symbol, amount):
        return self.decimal_to_precision(amount, TRUNCATE, self.markets[symbol]['precision']['amount'], DECIMAL_PLACES)

    async def fetch_markets(self, params={}) -> List[Market]:
        response = await self.v2publicGetMarketAll(params)
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "korean_name": "비트코인",
        #            "english_name": "Bitcoin",
        #            "market_warning": "NONE"
        #        },
        #        ...
        #    ]
        #
        result = []
        for i in range(0, len(response)):
            entry = response[i]
            marketId = self.safe_string(entry, 'market')
            quoteId, baseId = marketId.split('-')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            result.append({
                'id': marketId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'active': True,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDateTime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': int('4'),  # todo: check if api provides precision
                    'price': int('4'),
                },
                'limits': {
                    'leverage': {'min': None, 'max': None},
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                },
                'created': None,
                'info': entry,
            })
        return result

    def parse_balance(self, response) -> Balances:
        result: dict = {'info': response}
        balances = self.safe_list(response, 'data', [])
        for i in range(0, len(balances)):
            entry = balances[i]
            currencyId = self.safe_string(entry, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_string(entry, 'balance')
            account['used'] = self.safe_string(entry, 'locked')
            result[code] = account
        return self.safe_balance(result)

    async def fetch_balance(self, params={}) -> Balances:
        await self.load_markets()
        response = await self.v2privateGetAccounts(params)
        return self.parse_balance(response)

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'markets': market['quote'] + '-' + market['base'],
        }
        response = await self.v2publicGetOrderbook(self.extend(request, params))
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "timestamp": 1698125744837,
        #            "total_ask_size": 12.345,
        #            "total_bid_size": 23.456,
        #            "orderbook_units": [
        #                {
        #                    "ask_price": 45831000,
        #                    "bid_price": 45830000,
        #                    "ask_size": 0.123,
        #                    "bid_size": 0.234
        #                },
        #                ...
        #            ]
        #        }
        #    ]
        #
        data = self.safe_dict(response, 0, {})
        timestamp = self.safe_integer(data, 'timestamp')
        orderbookUnits = self.safe_list(data, 'orderbook_units', [])
        bids = []
        asks = []
        for i in range(0, len(orderbookUnits)):
            entry = orderbookUnits[i]
            askPrice = self.safe_number(entry, 'ask_price')
            askSize = self.safe_number(entry, 'ask_size')
            bidPrice = self.safe_number(entry, 'bid_price')
            bidSize = self.safe_number(entry, 'bid_size')
            if askPrice is not None and askSize is not None:
                if askSize > 0:
                    asks.append([askPrice, askSize])
            if bidPrice is not None and bidSize is not None:
                if bidSize > 0:
                    bids.append([bidPrice, bidSize])
        return {
            'symbol': symbol,
            'bids': self.sort_by(bids, 0, True),
            'asks': self.sort_by(asks, 0),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'nonce': None,
        }

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        timestamp = self.safe_integer(ticker, 'timestamp')
        if timestamp is None:
            timestamp = self.safe_integer(ticker, 'trade_timestamp')
        marketId = self.safe_string(ticker, 'market')
        symbol = self.safe_symbol(marketId, market)
        open = self.safe_string(ticker, 'opening_price')
        close = self.safe_string(ticker, 'trade_price')
        high = self.safe_string(ticker, 'high_price')
        low = self.safe_string(ticker, 'low_price')
        # workaround for Bithumb data inconsistency
        if close is not None:
            if high is not None:
                if Precise.string_lt(high, close):
                    high = close
            if low is not None:
                if Precise.string_gt(low, close):
                    low = close
        baseVolume = self.safe_string(ticker, 'acc_trade_volume_24h')
        quoteVolume = self.safe_string(ticker, 'acc_trade_price_24h')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': high,
            'low': low,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': close,
            'last': close,
            'previousClose': self.safe_string(ticker, 'prev_closing_price'),
            'change': self.safe_string(ticker, 'change_price'),
            'percentage': self.safe_string(ticker, 'change_rate'),
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }, market)

    async def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        marketIds = []
        if symbols is None:
            marketIds = list(self.markets_by_id.keys())
        else:
            marketIds = self.market_ids(symbols)
        promises = []
        chunkSize = 20  # safe chunk size
        for i in range(0, len(marketIds)):
            chunk = marketIds[i:i + chunkSize]
            markets = []
            for j in range(0, len(chunk)):
                marketId = chunk[j]
                market = self.safe_market(marketId)
                markets.append(market['quote'] + '-' + market['base'])
            marketsString = ','.join(markets)
            promises.append(self.v2publicGetTicker(self.extend(params, {'markets': marketsString})))
        responses = await asyncio.gather(*promises)
        result = []
        for i in range(0, len(responses)):
            response = responses[i]
            for j in range(0, len(response)):
                result.append(response[j])
        return self.parse_tickers(result, symbols)

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'markets': market['quote'] + '-' + market['base'],
        }
        response = await self.v2publicGetTicker(self.extend(request, params))
        data = self.safe_dict(response, 0, {})
        return self.parse_ticker(data, market)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        return [
            self.parse8601(self.safe_string(ohlcv, 'candle_date_time_utc')),
            self.safe_number(ohlcv, 'opening_price'),
            self.safe_number(ohlcv, 'high_price'),
            self.safe_number(ohlcv, 'low_price'),
            self.safe_number(ohlcv, 'trade_price'),
            self.safe_number(ohlcv, 'candle_acc_trade_volume'),
        ]

    async def fetch_ohlcv(self, symbol: str, timeframe: str = '1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        market = self.market(symbol)
        interval = self.safe_string(self.timeframes, timeframe, timeframe)
        request: dict = {
            'market': market['quote'] + '-' + market['base'],
        }
        if timeframe == '1d' or timeframe == '1w' or timeframe == '1M':
            request['interval'] = interval
        else:
            request['unit'] = interval
        if limit is not None:
            request['count'] = limit
        response = None
        if timeframe == '1d' or timeframe == '1w' or timeframe == '1M':
            response = await self.v2publicGetCandlesInterval(self.extend(request, params))
        else:
            response = await self.v2publicGetCandlesMinutesUnit(self.extend(request, params))
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "candle_date_time_utc": "2023-10-24T06:35:00",
        #            "candle_date_time_kts": "2023-10-24T15:35:00",
        #            "opening_price": 45831000,
        #            "high_price": 45831000,
        #            "low_price": 45831000,
        #            "trade_price": 45831000,
        #            "timestamp": 1698125700000,
        #            "candle_acc_trade_price": 435133614.99125,
        #            "candle_acc_trade_volume": 9.4943,
        #            "unit": 1
        #        },
        #        ...
        #    ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        timestamp = self.safe_integer(trade, 'timestamp')
        side = self.safe_string_lower(trade, 'ask_bid') == 'sell' if 'ask' else 'buy'
        price = self.safe_string(trade, 'trade_price')
        amount = self.safe_string(trade, 'trade_volume')
        id = self.safe_string(trade, 'sequential_id')
        symbol = self.safe_symbol(None, market)
        return self.safe_trade({
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': None,
            'type': None,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': None,
        }, market)

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'market': market['quote'] + '-' + market['base'],
        }
        if limit is not None:
            request['count'] = limit
        response = await self.v2publicGetTradesTicks(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'market': market['quote'] + '-' + market['base'],
            'side': 'bid' if (side == 'buy') else 'ask',
            'volume': self.amount_to_precision(symbol, amount),
            'ord_type': 'limit' if (type == 'limit') else 'price',  # price is market buy/sell
        }
        if type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
        response = await self.v2privatePostOrders(self.extend(request, params))
        return self.parse_order(response, market)

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        request = {
            'uuid': id,
        }
        response = await self.v2privateDeleteOrder(self.extend(request, params))
        return self.parse_order(response)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        timestamp = self.parse8601(self.safe_string(order, 'created_at'))
        status = self.parse_order_status(self.safe_string(order, 'state'))
        symbol = self.safe_symbol(self.safe_string(order, 'market'), market)
        side = self.safe_string_lower(order, 'side') == 'buy' if 'bid' else 'sell'
        type = self.safe_string_lower(order, 'ord_type')
        price = self.safe_string(order, 'price')
        amount = self.safe_string(order, 'volume')
        remaining = self.safe_string(order, 'remaining_volume')
        filled = self.safe_string(order, 'executed_volume')
        id = self.safe_string(order, 'uuid')
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'cost': None,
            'trades': None,
            'fee': {
                'currency': None,
                'cost': self.safe_string(order, 'paid_fee'),
            },
            'info': order,
        }, market)

    def parse_order_status(self, status: Str):
        statuses: dict = {
            'wait': 'open',
            'done': 'closed',
            'cancel': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        await self.load_markets()
        request: dict = {}
        if symbol is not None:
            market = self.market(symbol)
            request['market'] = market['quote'] + '-' + market['base']
        if limit is not None:
            request['limit'] = limit
        response = await self.v2privateGetOrders(self.extend(request, params))
        return self.parse_orders(response, None, since, limit)

    async def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        await self.load_markets()
        request = {
            'uuid': id,
        }
        response = await self.v2privateGetOrder(self.extend(request, params))
        return self.parse_order(response)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        endpoint = self.implode_params(path, params)
        url = self.urls['api'][api] + '/' + endpoint
        query = self.omit(params, self.extract_params(path))
        if api == 'v2public' or api == 'v2private':
            if query:
                url += '?' + self.urlencode(query)
            if api == 'v2private':
                self.check_required_credentials()
                nonce = self.uuid()
                timestamp = self.milliseconds()
                payload: dict = {
                    'access_key': self.apiKey,
                    'nonce': nonce,
                    'timestamp': timestamp,
                }
                if query:
                    if method == 'GET' or method == 'DELETE':
                        queryString = self.urlencode(query)
                        payload['query_hash'] = self.hash(self.encode(queryString), 'sha512')
                        payload['query_hash_alg'] = 'SHA512'
                    else:
                        body = self.json(query)
                        payload['query_hash'] = self.hash(self.encode(body), 'sha512')
                        payload['query_hash_alg'] = 'SHA512'
                token = self.jwt(payload, self.encode(self.secret), 'sha256')
                headers = {
                    'Authorization': 'Bearer ' + token,
                }
                if method == 'POST':
                    headers['Content-Type'] = 'application/json'
        else:
            if api == 'public':
                if query:
                    url += '?' + self.urlencode(query)
            else:
                self.check_required_credentials()
                body = self.urlencode(self.extend({
                    'endpoint': '/' + endpoint,
                }, query))
                nonce = str(self.milliseconds())
                auth = '/' + endpoint + ';' + body + ';' + nonce
                signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha512, 'hex')
                signature64 = self.string_to_base64(signature)
                headers = {
                    'Api-Key': self.apiKey,
                    'Api-Sign': signature64,
                    'Api-Nonce': nonce,
                    'Content-Type': 'application/x-www-form-urlencoded',
                }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
