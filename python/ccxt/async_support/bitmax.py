# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.decimal_to_precision import ROUND


class bitmax(Exchange):

    def describe(self):
        # There are cash/margin/futures accounts for each bitmax user.
        # You could provide it when call the api: params = {'account': 'cash'/'margin'/'futures'}
        # or you can set in advance by calling setAccount(account), where account is one of 'cash'/'margin'/'futures'.
        # e.g.  bitmax.createOrder('BTC-PERP', 'limit', 'buy', 0.01, 7125, params = {'account':'futures'})
        # or bitmax.setAccount('futures')
        return self.deep_extend(super(bitmax, self).describe(), {
            'id': 'bitmax',
            'name': 'BitMax',
            'countries': ['CN'],  # China
            'rateLimit': 500,
            'certified': False,
            # new metainfo interface
            'has': {
                'CORS': False,
                'fetchAccounts': True,
                'fetchTickers': True,
                'fetchOHLCV': True,
                'fetchMyTrades': False,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchOrderTrades': False,
                'fetchClosedOrders': True,
                'fetchTransactions': False,
                'fetchCurrencies': True,
                'cancelAllOrders': True,
                'fetchDepositAddress': True,
            },
            'timeframes': {
                '1m': '1',
                '3m': '3',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '6h': '360',
                '12h': '720',
                '1d': '1d',
                '1w': '1w',
                '1M': '1m',
            },
            'version': 'v1',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/66820319-19710880-ef49-11e9-8fbe-16be62a11992.jpg',
                'api': 'https://bitmax.io',
                'test': 'https://bitmax-test.io/api',
                'www': 'https://bitmax.io',
                'doc': [
                    'https://bitmax-exchange.github.io/bitmax-pro-api/#rest-apis',
                ],
                'fees': 'https://bitmax.io/#/feeRate/tradeRate',
                'referral': 'https://bitmax.io/#/register?inviteCode=T6J9R0EB',
            },
            'api': {
                'public': {
                    'get': [
                        'assets',
                        'barhist',
                        'barhist/info',
                        'cash/assets',
                        'cash/products',
                        'depth',
                        'fees',
                        'futures/collateral',
                        'futures/contracts',
                        'depth',
                        'margin/assets',
                        'margin/products',
                        'margin/ref-price',
                        'trades',
                        'products',
                        'ticker',
                    ],
                },
                'private': {
                    'get': [
                        'cash/balance',
                        'cash/order/hist/current',
                        'cash/order/open',
                        'cash/order/status',
                        'futures/balance',
                        'futures/order/hist/current',
                        'futures/order/open',
                        'futures/order/status',
                        'margin/balance',
                        'margin/order/hist/current',
                        'margin/order/open',
                        'margin/order/status',
                        'margin/risk',
                        'order/hist',
                        'transaction',
                        'info',
                        'wallet/deposit/address',
                    ],
                    'post': [
                        'cash/order',
                        'cash/order/batch',
                        'futures/order',
                        'futures/order/batch',
                        'margin/order',
                        'margin/order/batch',
                    ],
                    'delete': [
                        'cash/order',
                        'cash/order/all',
                        'cash/order/batch',
                        'margin/order',
                        'margin/order/all',
                        'margin/order/batch',
                        'futures/order',
                        'futures/order/all',
                        'futures/order/batch',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'taker': 0.001,
                    'maker': 0.001,
                },
            },
            'options': {
                'account': 'cash',  # 'cash'/'margin'/'futures'
                'accountGroup': None,
                'parseOrderToPrecision': False,
            },
            'exceptions': {
                'exact': {
                    # TODO: fix error code mapping
                    '2100': AuthenticationError,  # {"code":2100,"message":"ApiKeyFailure"}
                    '5002': BadSymbol,  # {"code":5002,"message":"Invalid Symbol"}
                    '6001': BadSymbol,  # {"code":6001,"message":"Trading is disabled on symbol."}
                    '6010': InsufficientFunds,  # {'code': 6010, 'message': 'Not enough balance.'}
                    '60060': InvalidOrder,  # {'code': 60060, 'message': 'The order is already filled or canceled.'}
                    '600503': InvalidOrder,  # {"code":600503,"message":"Notional is too small."}
                },
                'broad': {},
            },
            'commonCurrencies': {
                'BTCBEAR': 'BEAR',
                'BTCBULL': 'BULL',
            },
        })

    def get_valid_accounts(self):
        # Bitmax sub-account
        return ['cash', 'margin', 'futures']

    def get_account(self, params={}):
        # get current or provided bitmax sub-account
        account = self.safe_value(params, 'account', self.options['account'])
        return account.lower().capitalize()

    def set_account(self, account):
        # set default bitmax sub-account
        validAccounts = self.get_valid_accounts()
        if account in validAccounts:
            self.options['account'] = account

    def get_futures_collateral(self, params={}):
        # futures collateral
        response = self.publicGetFuturesCollateral(params)
        return self.safe_value(response, 'data', [])

    async def fetch_currencies(self, params={}):
        response = await self.publicGetAssets(params)
        #
        # {
        #    "code": 0,
        #    "data": [
        #        {
        #            "assetCode": "ONG",
        #            "assetName": "ONG",
        #            "precisionScale": 9,
        #            "nativeScale": 3,
        #            "withdrawalFee": "1.0",
        #            "minWithdrawalAmt": "2.0",
        #            "status": "Normal"
        #        }
        #    ]
        # }
        #
        result = {}
        if self.safe_value(response, 'code', -1) != 0:
            return result
        records = self.safe_value(response, 'data', [])
        for i in range(0, len(records)):
            currency = records[i]
            id = self.safe_string(currency, 'assetCode')
            # todo: will need to rethink the fees
            # to add support for multiple withdrawal/deposit methods and
            # differentiated fees for each particular method
            code = self.safe_currency_code(id)
            precision = self.safe_integer(currency, 'precisionScale')
            fee = self.safe_float(currency, 'withdrawalFee')  # todo: redesign
            status = self.safe_string(currency, 'status')
            active = (status == 'Normal')
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'type': None,
                'name': self.safe_string(currency, 'assetName'),
                'active': active,
                # Todo: tiered fee make fee calculation complicated now. To provide separate fee related method.
                'fee': fee,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision),
                        'max': None,
                    },
                    'price': {
                        'min': math.pow(10, -precision),
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': self.safe_float(currency, 'minWithdrawalAmt'),
                        'max': None,
                    },
                },
            }
        return result

    async def fetch_markets(self, params={}):
        response = await self.publicGetProducts(params)
        #
        # {
        #    "code": 0,
        #    "data": [
        #        {
        #            "symbol": "DAD/USDT",
        #            "baseAsset": "DAD",
        #            "quoteAsset": "USDT",
        #            "status": "Normal",
        #            "minNotional": "5",
        #            "maxNotional": "50000",
        #            "marginTradable": False,
        #            "commissionType": "Quote",
        #            "commissionReserveRate": "0.001",
        #            "tickSize": "0.00001",
        #            "lotSize": "1"
        #        }
        #    ]
        # }
        #
        result = []
        if self.safe_value(response, 'code', -1) != 0:
            return result
        records = self.safe_value(response, 'data', [])
        for i in range(0, len(records)):
            market = records[i]
            id = self.safe_string(market, 'symbol')
            baseId = self.safe_string(market, 'baseAsset')
            quoteId = self.safe_string(market, 'quoteAsset')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = id  # base + '/' + quote
            precision = {
                'amount': self.precision_from_string(self.safe_string(market, 'lotSize')),
                'price': self.precision_from_string(self.safe_string(market, 'tickSize')),
            }
            status = self.safe_string(market, 'status')
            active = (status == 'Normal')
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'lotSize'),
                        'max': None,
                    },
                    'price': {
                        'min': self.safe_float(market, 'tickSize'),
                        'max': None,
                    },
                    'cost': {
                        'min': self.safe_float(market, 'minNotional'),
                        'max': self.safe_float(market, 'maxNotional'),
                    },
                },
            })
        return result

    def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        # TODO: fee calculation here is incorrect, we need to support tiered fee calculation.
        market = self.markets[symbol]
        key = 'quote'
        rate = market[takerOrMaker]
        cost = amount * rate
        precision = market['precision']['price']
        if side == 'sell':
            cost *= price
        else:
            key = 'base'
            precision = market['precision']['amount']
        cost = self.decimal_to_precision(cost, ROUND, precision, self.precisionMode)
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': float(cost),
        }

    async def fetch_accounts(self, params={}):
        accountGroup = self.safe_string(self.options, 'accountGroup')
        records = None
        if accountGroup is None:
            response = await self.privateGetInfo(params)
            #
            # {
            #    'code': 0,
            #    'data':
            #        {
            #            'email': 'xxxcc@gmail.com',
            #            'accountGroup': 5,
            #            'viewPermission': True,
            #            'tradePermission': True,
            #            'transferPermission': True,
            #            'withdrawPermission': True,
            #            'cashAccount': ['xxxxxxxxxxxxxxxxxxxxxxxxxx'],
            #            'marginAccount': ['yyyyyyyyyyyyyyyyyyyyyyyyy'],
            #            'futuresAccount': ['zzzzzzzzzzzzzzzzzzzzzzzzz'],
            #            'userUID': 'U123456789'
            #        }
            # }
            #
            if response['code'] == 0:
                records = response['data']
                accountGroup = self.safe_string(records, 'accountGroup')
                self.options['accountGroup'] = accountGroup
        return [
            {
                'id': accountGroup,
                'type': None,
                'currency': None,
                'info': records,
            },
        ]

    async def fetch_balance(self, params={}):
        await self.load_markets()
        await self.load_accounts()
        method = 'privateGet' + self.get_account(params) + 'Balance'
        response = await getattr(self, method)(params)
        #
        # {
        #    'code': 0,
        #    'data':
        #        [
        #            {
        #                'asset': 'BCHSV',
        #                'totalBalance': '64.298000048',
        #                'availableBalance': '64.298000048'
        #            },
        #         ]
        # }
        #
        result = {'info': response}
        balances = self.safe_value(response, 'data', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_currency_code(self.safe_string(balance, 'asset'))
            account = self.account()
            account['free'] = self.safe_float(balance, 'availableBalance')
            account['total'] = self.safe_float(balance, 'totalBalance')
            account['used'] = account['total'] - account['free']
            result[code] = account
        return self.parse_balance(result)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['n'] = limit  # default = maximum = 100
        response = await self.publicGetDepth(self.extend(request, params))
        #
        # {
        #    "code": 0,
        #    "data": {
        #        "m": "depth-snapshot",
        #        "symbol": "BTC/USDT",
        #        "data": {
        #            "ts": 1583558793465,
        #            "seqnum": 8273359781,
        #            "asks": [
        #                [
        #                    "9082.73",
        #                    "1.31752"
        #                ],
        #                [
        #                    "9082.76",
        #                    "0.00342"
        #                ]
        #            ],
        #            "bids": [
        #                [
        #                    "5532.27",
        #                    "0.00606"
        #                ],
        #                [
        #                    "4858.54",
        #                    "0.02789"
        #                ]
        #            ]
        #        }
        #    }
        # }
        #
        data = self.safe_value(response, 'data', {})
        records = self.safe_value(data, 'data', {})
        timestamp = self.safe_integer(records, 'ts')
        result = self.parse_order_book(records, timestamp)
        result['nonce'] = self.safe_integer(records, 'seqnum')
        return result

    def parse_ticker(self, ticker, market=None):
        #
        # {
        #    'symbol': 'BTC/USDT',
        #    'open': '8086.63',
        #    'close': '7846.16',
        #    'high': '7846.16',
        #    'low': '7846.16',
        #    'volume': '8100.10864',
        #    'ask': ['7847.7', '0.52882'],
        #    'bid': ['7846.87', '3.9718']
        # }
        #
        timestamp = self.milliseconds()
        timestamp = timestamp - timestamp % 60000
        symbol = None
        marketId = self.safe_string(ticker, 'symbol')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        elif marketId is not None:
            baseId, quoteId = marketId.split('/')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        last = self.safe_float(ticker, 'close')
        bid = self.safe_value(ticker, 'bid', [None, None])
        ask = self.safe_value(ticker, 'ask', [None, None])
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': bid[0],
            'bidVolume': bid[1],
            'ask': ask[0],
            'askVolume': ask[1],
            'vwap': None,
            'open': self.safe_float(ticker, 'open'),
            'close': last,
            'last': last,
            'previousClose': None,  # previous day close
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume'),
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = await self.publicGetTicker(self.extend(request, params))
        #
        # {
        #    'code': 0,
        #    'data':
        #        {
        #            'symbol': 'BTC/USDT',
        #            'open': '8086.63',
        #            'close': '7846.16',
        #            'high': '7846.16',
        #            'low': '7846.16',
        #            'volume': '8100.10864',
        #            'ask': ['7847.7', '0.52882'],
        #            'bid': ['7846.87', '3.9718']
        #        }
        # }
        #
        return self.parse_ticker(self.safe_value(response, 'data', {}), market)

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        request = {}
        if symbols is not None and len(symbols) > 0:
            symbol = self.market(symbols[0])['id']
            for i in range(1, len(symbols)):
                market = self.market(symbols[i])
                symbol = symbol + ',' + market['id']
        response = await self.publicGetTicker(self.extend(request, params))
        tickers = self.safe_value(response, 'data', [])
        return self.parse_tickers(tickers, symbols)

    def parse_ohlcv(self, ohlcvRecord, market=None, timeframe='1m', since=None, limit=None):
        #
        # {
        #    'm': 'bar',
        #    's': 'BTC/USDT',
        #    'data':
        #        {
        #            'i': '1',
        #            'ts': 1583901000000,
        #            'o': '7924.98',
        #            'c': '7926.80',
        #            'h': '7926.80',
        #            'l': '7924.98',
        #            'v': '0.32144'
        #        }
        # }
        #
        ohlcv = self.safe_value(ohlcvRecord, 'data', {})
        return [
            self.safe_integer(ohlcv, 'ts'),
            self.safe_float(ohlcv, 'o'),
            self.safe_float(ohlcv, 'h'),
            self.safe_float(ohlcv, 'l'),
            self.safe_float(ohlcv, 'c'),
            self.safe_float(ohlcv, 'v'),
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'interval': self.timeframes[timeframe],
        }
        # if since and limit are not specified
        # the exchange will return just 1 last candle by default
        duration = self.parse_timeframe(timeframe)
        if since is not None:
            request['from'] = since
            if limit is not None:
                request['to'] = self.sum(since, limit * duration * 1000, 1)
        elif limit is not None:
            request['to'] = self.milliseconds()
            request['from'] = request['to'] - limit * duration * 1000 - 1
        response = await self.publicGetBarhist(self.extend(request, params))
        return self.parse_ohlcvs(self.safe_value(response, 'data', []), market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # public fetchTrades
        #
        #     {
        #         "p": "13.75",  # price
        #         "q": "6.68",  # quantity
        #         "ts": 1528988084944,  # timestamp
        #         "bm": False,  # if True, the buyer is the market maker, we only use self field to "define the side" of a public trade
        #     }
        #
        # privateGetCashOrderStatus / privateGetMarginOrderStatus / privateGetFuturesOrderStatus
        #
        # {
        #    'seqNum': 4208248561,
        #    'orderId': 'r170adcc717eU123456789bbtmabc3P',
        #    'symbol': 'BTMX/USDT',
        #    'orderType': 'Limit',
        #    'lastExecTime': 1583463823205,
        #    'price': '0.06043',
        #    'orderQty': '100',
        #    'side': 'Buy',
        #    'status': 'Filled',
        #    'avgPx': '0.06043',
        #    'cumFilledQty': '100',
        #    'stopPrice': '',
        #    'errorCode': '',
        #    'cumFee': '0.006043',
        #    'feeAsset': 'USDT',
        #    'execInst': 'NULL_VAL'
        # }
        #
        timestamp = self.safe_integer(trade, 'ts')
        price = self.safe_float(trade, 'price') or self.safe_float(trade, 'p')
        amount = self.safe_float(trade, 'orderQty') or self.safe_float(trade, 'q')
        cost = None
        if (price is not None) and (amount is not None):
            cost = price * amount
        buyerIsMaker = self.safe_value(trade, 'bm')
        makerOrTaker = None
        if buyerIsMaker is not None:
            if buyerIsMaker:
                makerOrTaker = 'maker'
            else:
                makerOrTaker = 'taker'
        symbol = None
        marketId = self.safe_string(trade, 's')
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
            else:
                baseId, quoteId = market.split('/')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        fee = None
        feeCost = self.safe_float(trade, 'cumFee')
        if feeCost is not None:
            feeCurrencyId = self.safe_string(trade, 'feeAsset')
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            }
        orderId = self.safe_string(trade, 'orderId')
        side = self.safe_string_lower(trade, 'side')
        if (side is None) and (buyerIsMaker is not None):
            side = 'buy' if buyerIsMaker else 'sell'
        type = self.safe_string_lower(trade, 'orderType')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': None,
            'order': orderId,
            'type': type,
            'takerOrMaker': makerOrTaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['n'] = limit  # currently limited to 100 or fewer
        response = await self.publicGetTrades(self.extend(request, params))
        #
        #    {
        #        'code': 0,
        #        'data':
        #            {
        #                'm': 'trades',
        #                'symbol': 'BTC/USDT',
        #                'data': [{'p': '7812.61',
        #                        'q': '0.01998',
        #                        'ts': 1583760687790,
        #                        'bm': False,  # if True, the buyer is the market maker
        #                        'seqnum': 72057603463162642}]
        #              }
        #     }
        #
        records = self.safe_value(response, 'data', [])
        trades = self.safe_value(records, 'data', [])
        return self.parse_trades(trades, market, since, limit)

    def parse_order_status(self, status):
        statuses = {
            'PendingNew': 'open',
            'New': 'open',
            'PartiallyFilled': 'open',
            'Filled': 'closed',
            'Canceled': 'canceled',
            'Rejected': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        # createOrder
        #
        # {
        #    'symbol': 'BTC/USDT',
        #    'orderType': 'Limit',
        #    'action': 'new',
        #    'timestamp': 1583812256973,
        #    'id': '0e602eb4337d4aebbe3c438f6cc41aee',
        #    'orderId': 'a170c29124378418641348f6cc41aee'
        # }
        #
        # fetchOrder, fetchOpenOrders, fetchClosedOrders
        #
        # {
        #    'avgPx': '9126.75',
        #    'cumFee': '0.002738025',
        #    'cumFilledQty': '0.0005',
        #    'errorCode': '',
        #    'execInst': 'NULL_VAL',
        #    'feeAsset': 'USDT',
        #    'lastExecTime': 1583443804918,
        #    'orderId': 'r170ac9b032cU9490877774sbtcpeAAb',
        #    'orderQty': '0.0005',
        #    'orderType': 'Market',
        #    'price': '8853',
        #    'seqNum': 4204789616,
        #    'side': 'Sell',
        #    'status': 'Filled',
        #    'stopPrice': '',
        #    'symbol': 'BTC-PERP'
        # }
        #
        status = self.parse_order_status(self.safe_string(order, 'status'))
        marketId = self.safe_string(order, 'symbol')
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            else:
                baseId, quoteId = marketId.split('/')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        timestamp = self.safe_integer(order, 'lastExecTime') or self.safe_integer(order, 'timestamp')
        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'orderQty')
        avgFillPx = self.safe_float(order, 'avgPx')
        filled = self.safe_float(order, 'cumFilledQty')
        remaining = (amount or 0) - (filled or 0)
        if remaining < 0:
            remaining = 0
        if symbol is not None:
            remaining = self.amount_to_precision(symbol, remaining)
        cost = (avgFillPx or 0) * (filled or 0)
        id = self.safe_string(order, 'orderId')
        type = self.safe_string(order, 'orderType')
        if type is not None:
            type = type.lower()
            if type == 'market':
                if price == 0.0:
                    if (cost is not None) and (filled is not None):
                        if (cost > 0) and (filled > 0):
                            price = cost / filled
        side = self.safe_string_lower(order, 'side')
        fee = {
            'cost': self.safe_float(order, 'cumFee'),
            'currency': self.safe_string(order, 'feeAsset'),
        }
        clientOrderId = id
        return {
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': avgFillPx,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': None,
        }

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        await self.load_accounts()
        market = self.market(symbol)
        request = {
            'id': self.coid(),  # optional, a unique identifier of length 32
            # 'time': self.milliseconds(),  # milliseconds since UNIX epoch in UTC, self is filled in the private section of the sign() method below
            'symbol': market['id'],
            'orderPrice': self.price_to_precision(symbol, price or 0),  # optional, limit price of the order. This field is required for limit orders and stop limit orders
            'stopPrice': self.price_to_precision(symbol, self.safe_value(params, 'stopPrice', 0.0)),  # optional, stopPrice of the order. This field is required for stop_market orders and stop limit orders
            'orderQty': self.amount_to_precision(symbol, amount),
            'orderType': type,  # order type, you shall specify one of the following: "limit", "market", "stop_market", "stop_limit"
            'side': side,  # "buy" or "sell"
            'postOnly': self.safe_value(params, 'postOnly', False),  # optional, if True, the order will either be posted to the limit order book or be cancelled, i.e. the order cannot take liquidity, default is False
            'timeInForce': self.safe_string(params, 'timeInForce', 'GTC'),  # optional, supports "GTC" good-till-canceled, "IOC" immediate-or-cancel, and "FOK" for fill-or-kill
        }
        if (type == 'limit') or (type == 'stop_limit'):
            request['orderPrice'] = self.price_to_precision(symbol, price)
        method = 'privatePost' + self.get_account(params) + 'Order'
        response = await getattr(self, method)(self.extend(request, params))
        #
        # {
        #  'code': 0,
        #  'data': {
        #              'ac': 'CASH',
        #              'accountId': 'hongyu.wang',
        #              'action': 'place-order',
        #              'info': {
        #                   'id': 'JhAAjOoTY6EINXC8QcOL18HoXw89FU0u',
        #                   'orderId': 'a170d000346b5450276356oXw89FU0u',
        #                   'orderType': 'Limit',
        #                   'symbol': 'BTMX/USDT',
        #                   'timestamp': 1584037640014
        #                  },
        #              'status': 'Ack'
        #          }
        # }
        #
        data = self.safe_value(response, 'data', {})
        info = self.extend(self.safe_value(data, 'info'), {'status': None})
        return self.parse_order(info, market)

    async def fetch_order(self, id, symbol=None, params={}):
        await self.load_markets()
        await self.load_accounts()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request = {
            'orderId': id,
        }
        accounts = None
        if 'account' in params:
            accounts = [self.safe_value(params, 'account')]
        else:
            accounts = self.get_valid_accounts()
        response = None
        for i in range(0, len(accounts)):
            if response is None:
                try:
                    account = self.get_account({'account': accounts[i]})
                    method = 'privateGet' + account + 'OrderStatus'
                    response = await getattr(self, method)(self.extend(request, params))
                except Exception as error:
                    # log error
                    response = None
        #
        #  {
        #      'code': 0,
        #      'accountId': 'ABCDEFGHIJKLMNOPQRSTUVWXYZABC',
        #      'ac': 'CASH',
        #      'data': {
        #          'seqNum': 4208248561,
        #          'orderId': 'r170adcc717eU123456789bbtmabc3P',
        #          'symbol': 'BTMX/USDT',
        #          'orderType': 'Limit',
        #          'lastExecTime': 1583463823205,
        #          'price': '0.06043',
        #          'orderQty': '100',
        #          'side': 'Buy',
        #          'status': 'Filled',
        #          'avgPx': '0.06043',
        #          'cumFilledQty': '100',
        #          'stopPrice': '',
        #          'errorCode': '',
        #          'cumFee': '0.006043',
        #          'feeAsset': 'USDT',
        #          'execInst': 'NULL_VAL'
        #          }
        # }
        #
        data = self.safe_value(response, 'data', {})
        return self.parse_order(data, market)

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        await self.load_accounts()
        market = None
        request = {
            # 'symbol': 'ETH/BTC',  # optional
            # 'category': 'CASH',  # optional, string
            # 'orderType': 'Market',  # optional, string
            # 'page': 1,  # optional, integer type, starts at 1
            # 'pageSize': 100,  # optional, integer type
            # 'side': 'buy',  # or 'sell', optional, case insensitive.
            # 'startTime': 1566091628227,  # optional, integer milliseconds since UNIX epoch representing the start of the range
            # 'endTime': 1566091628227,  # optional, integer milliseconds since UNIX epoch representing the end of the range
            # 'status': 'Filled',  # optional, can only be one of "Filled", "Canceled", "Rejected"
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['n'] = limit  # default 15, max 50
        request['executedOnly'] = self.safe_value(params, 'executedOnly', False)
        method = 'privateGet' + self.get_account(params) + 'OrderHistCurrent'
        response = await getattr(self, method)(self.extend(request, params))
        #
        # {
        #    'code': 0,
        #    'accountId': 'test1@xxxxx.io',
        #    'ac': 'CASH',
        #    'data': [
        #        {
        #            'seqNum': 30181890,
        #            'orderId': 'a170c4f6cae084186413483b0e984fe',
        #            'symbol': 'BTC/USDT',
        #            'orderType': 'Limit',
        #            'lastExecTime': 1583852473185,
        #            'price': '8500',
        #            'orderQty': '0.01',
        #            'side': 'Buy',
        #            'status': 'Filled',
        #            'avgPx': '8032.04',
        #            'cumFilledQty': '0.01',
        #            'stopPrice': '',
        #            'errorCode': '',
        #            'cumFee': '0.065862728',
        #            'feeAsset': 'USDT',
        #            'execInst': 'NULL_VAL'
        #        }]
        # }
        #
        orders = self.safe_value(response, 'data', [])
        return self.parse_orders(orders, market, since, limit)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        await self.load_accounts()
        market = None
        request = {
            # 'symbol': 'symbol'  optional
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        method = 'privateGet' + self.get_account(params) + 'OrderOpen'
        response = await getattr(self, method)(self.extend(request, params))
        #
        # {
        #    'code': 0,
        #    'accountId': 'MPXFNEYEJIJ93CREXT3LTCIDIJPCFNIX',
        #    'ac': 'CASH',
        #    'data':
        #        [{
        #            'seqNum': 4305977824,
        #            'orderId': 'a170c9e191a7U9490877774397007e73',
        #            'symbol': 'BTMX/USDT',
        #            'orderType': 'Limit',
        #            'lastExecTime': 1583934968446,
        #            'price': '0.045',
        #            'orderQty': '200',
        #            'side': 'Buy',
        #            'status': 'New',
        #            'avgPx': '0',
        #            'cumFilledQty': '0',
        #            'stopPrice': '',
        #            'errorCode': '',
        #            'cumFee': '0',
        #            'feeAsset': 'USDT',
        #            'execInst': 'NULL_VAL'
        #        }]
        # }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market, since, limit)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        await self.load_accounts()
        market = None
        request = {
            # 'symbol': 'ETH/BTC',  # optional
            # 'category': 'CASH'/'MARGIN'/"FUTURES',  # optional, string
            # 'orderType': 'Market',  # optional, string
            # 'page': 1,  # optional, integer type, starts at 1
            # 'pageSize': 100,  # optional, integer type
            # 'side': 'buy',  # or 'sell', optional, case insensitive.
            # 'startTime': 1566091628227,  # optional, integer milliseconds since UNIX epoch representing the start of the range
            # 'endTime': 1566091628227,  # optional, integer milliseconds since UNIX epoch representing the end of the range
            # 'status': 'Filled',  # optional, can only be one of "Filled", "Canceled", "Rejected"
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['n'] = limit  # default 15, max 50
        response = await self.privateGetOrderHist(self.extend(request, params))
        #
        # {
        #    'code': 0,
        #    'data':
        #        {
        #            'page': 1,
        #            'pageSize': 20,
        #            'limit': 500,
        #            'hasNext': True,
        #            'data': [
        #                {
        #                    'ac': 'CASH',
        #                    'accountId': 'ABCDEFGHIJKLMOPQRSTUVWXYZABC',
        #                    'avgPx': '0',
        #                    'cumFee': '0',
        #                    'cumQty': '0',
        #                    'errorCode': 'NULL_VAL',
        #                    'feeAsset': 'USDT',
        #                    'lastExecTime': 1583894311925,
        #                    'orderId': 'r170c77528bdU9490877774bbtcu9DwL',
        #                    'orderQty': '0.001', 'orderType': 'Limit',
        #                    'price': '7912.88',
        #                    'sendingTime': 1583894310880,
        #                    'seqNum': 4297339552,
        #                    'side': 'Buy',
        #                    'status': 'Canceled',
        #                    'stopPrice': '',
        #                    'symbol': 'BTC/USDT',
        #                    'execInst': 'NULL_VAL'
        #                }
        #            ]
        #        }
        # }
        #
        data = self.safe_value(response, 'data', {})
        orders = self.safe_value(data, 'data', [])
        return self.parse_orders(orders, market, since, limit)

    async def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder requires a symbol argument')
        await self.load_markets()
        await self.load_accounts()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'id': self.coid(),  # optional
            'orderId': id,
            # 'time': self.milliseconds(),  # self is filled in the private section of the sign() method below
        }
        method = 'privateDelete' + self.get_account(params) + 'Order'
        response = await getattr(self, method)(self.extend(request, params))
        #
        # {
        #    'code': 0,
        #    'data':
        #        {
        #            'accountId': 'test1@xxxxx.io',
        #            'ac': 'CASH',
        #            'action': 'cancel-order',
        #            'status': 'Ack',
        #            'info': {
        #                'symbol': 'BTC/USDT',
        #                'orderType': '',
        #                'timestamp': 1583868590663,
        #                'id': 'de4f5a7c5df2433cbe427da14d8f84d5',
        #                'orderId': 'a170c5136edb8418641348575f38457'}
        #        }
        # }
        #
        order = self.safe_value(self.safe_value(response, 'data', {}), 'info', {})
        order['status'] = None
        return self.parse_order(order)

    async def cancel_all_orders(self, symbol=None, params={}):
        await self.load_markets()
        await self.load_accounts()
        request = {
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']  # optional
        method = 'privateDelete' + self.get_account(params) + 'OrderAll'
        response = await getattr(self, method)(self.extend(request, params))
        #
        # {
        #    'code': 0,
        #    'data':
        #        {
        #            'accountId': 'test1@dengpan.io',
        #            'ac': 'CASH',
        #            'action': 'cancel-all',
        #            'status': 'Ack',
        #            'info':
        #                {
        #                    'symbol': '',
        #                    'orderType': 'NULL_VAL',
        #                    'timestamp': 1584057856765,
        #                    'id': '',
        #                    'orderId': ''
        #                }
        #             }
        #    }
        # }
        #
        order = self.safe_value(self.safe_value(response, 'data', {}), 'info', {})
        order['status'] = None
        order['orderType'] = None
        order['symbol'] = symbol
        return self.parse_order(order)

    def coid(self):
        uuid = self.uuid()
        parts = uuid.split('-')
        clientOrderId = ''.join(parts)
        coid = clientOrderId[0:32]
        return coid

    async def fetch_deposit_address(self, code, params={}):
        await self.load_markets()
        await self.load_accounts()
        currency = self.currency(code)
        request = {
            'requestId': self.coid(),
            # 'time': self.milliseconds(),  # self is filled in the private section of the sign() method below
            'asset': currency['id'],
            'isCommonApi': True,  # not from request
        }
        response = await self.privateGetWalletDepositAddress(self.extend(request, params))
        #
        #
        # {
        #    'code': 0,
        #    'data':
        #        {
        #            'asset': 'BTC',
        #            'assetName': 'Bitcoin',
        #            'address':
        #                [
        #                    {
        #                        'address': '3P5e8M6nQaGPB6zYJ447uGJKCJN2ZkEDLB',
        #                        'destTag': '',
        #                        'tagType': '',
        #                        'tagId': '',
        #                        'chainName': 'Bitcoin',
        #                        'numConfirmations': 3,
        #                        'withdrawalFee': 0.0005,
        #                        'nativeScale': 8,
        #                        'tips': []
        #                    }
        #                ]
        #        }
        # }
        #
        data = self.safe_value(response, 'data', {})
        addressData = self.safe_value(data, 'address', [])
        if isinstance(addressData, list):
            addressData = self.safe_value(addressData, 0, {})
        address = self.safe_string(addressData, 'address')
        tag = self.safe_string(addressData, 'destTag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = '/api/pro/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            if not self.safe_value(params, 'isCommonApi', False):
                accountGroup = self.safe_string(self.options, 'accountGroup')
                if accountGroup is None:
                    if self.accounts is not None:
                        accountGroup = self.accounts[0]['id']
                if accountGroup is not None:
                    url = '/' + accountGroup + url
            query['time'] = str(self.milliseconds())
            auth = query['time'] + '+' + path.replace('/{orderId}', '')  # fix sign error
            headers = {
                'x-auth-key': self.apiKey,
                'x-auth-timestamp': query['time'],
                'Content-Type': 'application/json',
            }
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            headers['x-auth-signature'] = self.decode(signature)
            if method == 'GET':
                if query:
                    url += '?' + self.urlencode(query)
            else:
                body = self.json(query)
        url = self.urls['api'] + url
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        #
        #     {"code":2100,"message":"ApiKeyFailure"}
        #     {'code': 6010, 'message': 'Not enough balance.'}
        #     {'code': 60060, 'message': 'The order is already filled or canceled.'}
        #
        code = self.safe_string(response, 'code')
        message = self.safe_string(response, 'message')
        error = (code is not None) and (code != '0')
        if error or (message is not None):
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], code, feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message
