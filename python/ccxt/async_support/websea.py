# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.websea import ImplicitAPI
import asyncio
from ccxt.base.types import Any, Balances, Currencies, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Position, Str, Strings, Ticker, Tickers, FundingRate, Trade, MarketInterface
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import NotSupported
from ccxt.base.decimal_to_precision import TICK_SIZE


class websea(Exchange, ImplicitAPI):

    def describe(self) -> Any:
        return self.deep_extend(super(websea, self).describe(), {
            'id': 'websea',
            'name': 'Websea',
            'countries': ['SG'],  # Singapore
            'rateLimit': 1000,
            'certified': False,
            'pro': False,
            'has': {
                'CORS': False,
                'spot': True,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'createOrder': True,
                'createOrders': False,
                'createPostOnlyOrder': False,
                'createReduceOnlyOrder': True,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchAccounts': False,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': False,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchDeposits': False,
                'fetchDepositsWithdrawals': False,
                'fetchDepositWithdrawFee': False,
                'fetchDepositWithdrawFees': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': True,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchGreeks': False,
                'fetchIndexOHLCV': False,
                'fetchLeverage': False,
                'fetchLeverages': False,
                'fetchLeverageTiers': False,
                'fetchMarginMode': False,
                'fetchMarginModes': False,
                'fetchMarketLeverageTiers': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMySettlementHistory': False,
                'fetchOHLCV': True,
                'fetchOpenInterest': False,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': True,
                'fetchOption': False,
                'fetchOptionChain': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': False,
                'fetchPosition': True,
                'fetchPositionMode': False,
                'fetchPositions': True,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchSettlementHistory': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': True,
                'fetchTransactionFee': False,
                'fetchTransactionFees': False,
                'fetchTransactions': False,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'fetchVolatilityHistory': False,
                'fetchWithdrawal': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'sandbox': False,
                'setLeverage': True,
                'setMarginMode': False,
                'setPositionMode': False,
                'transfer': False,
            },
            'features': {
                'default': {
                    'sandbox': False,
                    'createOrder': {
                        'marginMode': False,
                        'triggerPrice': False,
                        'triggerPriceType': None,
                        'stopLossPrice': False,
                        'takeProfitPrice': False,
                        'attachedStopLossTakeProfit': None,
                        'timeInForce': {
                            'GTC': True,
                            'IOC': False,
                            'FOK': False,
                            'PO': False,
                            'GTD': False,
                        },
                        'hedged': False,
                        'trailing': False,
                        'leverage': False,
                        'marketBuyRequiresPrice': False,
                        'marketBuyByCost': False,
                        'selfTradePrevention': False,
                        'iceberg': False,
                    },
                    'createOrders': {
                        'max': 5,
                    },
                    'fetchMyTrades': {
                        'marginMode': False,
                        'daysBack': 0,
                        'limit': 0,
                        'untilDays': 0,
                        'symbolRequired': True,
                    },
                    'fetchOrder': {
                        'marginMode': False,
                        'trigger': False,
                        'trailing': False,
                        'symbolRequired': True,
                    },
                    'fetchOpenOrders': {
                        'marginMode': False,
                        'limit': 0,
                        'trigger': False,
                        'trailing': False,
                        'symbolRequired': True,
                    },
                    'fetchOrders': {
                        'marginMode': False,
                        'limit': 0,
                        'daysBack': 0,
                        'untilDays': 0,
                        'trigger': False,
                        'trailing': False,
                        'symbolRequired': True,
                    },
                    'fetchClosedOrders': {
                        'marginMode': False,
                        'limit': 0,
                        'daysBack': 0,
                        'daysBackCanceled': 0,
                        'untilDays': 0,
                        'trigger': False,
                        'trailing': False,
                        'symbolRequired': True,
                    },
                    'fetchOHLCV': {
                        'limit': 0,
                    },
                },
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '6h': '360',
                '12h': '720',
                '1d': '1d',
                '1w': '1w',
                '1M': '1M',
            },
            'version': 'v1',
            'urls': {
                'logo': 'https://webseaex.github.io/favicon.ico',
                'api': {
                    'rest': 'https://oapi.websea.com',
                },
                'test': {
                    'rest': 'https://oapi.websea.com',
                },
                'www': 'https://www.websea.com',
                'doc': [
                    'https://webseaex.github.io/en/',
                ],
                'fees': 'https://websea.com/fees',
                'referral': {
                    'url': 'https://www.websea.com',
                    'discount': 0,
                },
            },
            'options': {
                'defaultType': 'spot',  # 'spot', 'swap'
                'defaultSubType': 'linear',  # 'linear'
            },
            'api': {
                'public': {
                    'get': {
                        'openApi/market/symbols': 1,  # 交易对列表
                        'openApi/market/currencies': 1,  # 币种列表
                        'openApi/market/trade': 1,  # 市场交易记录
                        'openApi/market/depth': 1,  # 市场深度
                        'openApi/market/orderbook': 1,  # 订单簿
                        'openApi/market/kline': 1,  # K线数据
                        'openApi/market/24kline': 1,  # 24小时K线数据
                        'openApi/market/24kline-list': 1,  # 24小时市场列表
                        'openApi/market/precision': 1,  # 交易对精度
                        'openApi/futures/symbols': 1,  # 期货交易对列表
                        'openApi/futures/trade': 1,  # 期货交易记录
                        'openApi/futures/depth': 1,  # 期货市场深度
                        'openApi/futures/kline': 1,  # 期货K线数据
                    },
                },
                'private': {
                    'get': {
                        'openApi/wallet/list': 1,  # 钱包列表 - 余额查询
                        'openApi/entrust/historyList': 1,  # 历史订单列表 - 已完成订单
                    },
                    'post': {
                        'openApi/entrust/add': 1,  # 下单
                        'openApi/entrust/cancel': 1,  # 取消订单
                        'openApi/entrust/orderDetail': 1,  # 订单详情
                        'openApi/entrust/orderTrade': 1,  # 订单成交记录
                        'openApi/entrust/historyDetail': 1,  # 历史订单详情
                        'openApi/wallet/detail': 1,  # 钱包详情
                        'openApi/futures/entrust/add': 1,  # 期货下单
                        'openApi/futures/entrust/cancel': 1,  # 期货取消订单
                        'openApi/futures/entrust/orderList': 1,  # 期货当前订单列表
                        'openApi/futures/entrust/orderDetail': 1,  # 期货订单详情
                        'openApi/futures/position/list': 1,  # 期货持仓列表
                        'openApi/futures/position/detail': 1,  # 期货持仓详情
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': self.parse_number('0.002'),
                    'taker': self.parse_number('0.002'),
                },
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {
                    '1001': BadSymbol,  # 交易对错误
                    '1002': ExchangeError,  # 参数错误
                    '1003': ExchangeError,  # 请求方法错误
                    '1004': ExchangeError,  # 请求地址不存在
                },
                'broad': {
                    'symbol error': BadSymbol,
                    'base symbol error': BadSymbol,
                    'The request method is wrong': ExchangeError,
                    'The request address does not exist': ExchangeError,
                },
            },
            'commonCurrencies': {
                # 常见货币映射
            },
        })

    def parse_order(self, order, market: Market = None) -> Order:
        #
        # 需要根据实际API响应结构调整
        #
        marketId = self.safe_string(order, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        id = self.safe_string(order, 'order_id')
        timestamp = self.safe_integer(order, 'create_time')
        status = self.safe_string(order, 'status')
        side = self.safe_string(order, 'side')
        type = self.safe_string(order, 'type')
        price = self.safe_number(order, 'price')
        amount = self.safe_number(order, 'amount')
        filled = self.safe_number(order, 'filled')
        remaining = self.safe_number(order, 'remaining')
        cost = self.safe_number(order, 'cost')
        fee = None  # 需要根据实际API调整
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'triggerPrice': None,
            'amount': amount,
            'cost': cost,
            'average': None,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': None,
        }, market)

    def market(self, symbol: str) -> MarketInterface:
        if self.markets is None:
            raise ExchangeError(self.id + ' markets not loaded')
        # 根据defaultType选择市场
        defaultType = self.safe_string(self.options, 'defaultType', 'spot')
        if isinstance(symbol, str):
            if symbol in self.markets:
                market = self.markets[symbol]
                # 如果指定了类型，优先返回对应类型的市场
                typeInParams = self.safe_string_2(self.options, 'defaultType', 'type')
                if typeInParams is not None and typeInParams != market['type']:
                    # 尝试查找相同交易对但不同类型 markets
                    baseQuote = symbol.split(':')[0]  # 移除结算货币部分
                    for i in range(0, len(self.symbols)):
                        otherSymbol = self.symbols[i]
                        otherMarket = self.markets[otherSymbol]
                        if otherMarket['type'] == typeInParams:
                            otherBaseQuote = otherSymbol.split(':')[0]
                            if baseQuote == otherBaseQuote:
                                return otherMarket
                return market
            elif symbol in self.markets_by_id:
                markets = self.markets_by_id[symbol]
                typeInParams = self.safe_string_2(self.options, 'defaultType', 'type', defaultType)
                for i in range(0, len(markets)):
                    market = markets[i]
                    if market[typeInParams]:
                        return market
                return markets[0]
        raise BadSymbol(self.id + ' does not have market symbol ' + symbol)

    def nonce(self):
        return self.milliseconds()

    async def fetch_markets(self, params={}) -> List[Market]:
        """
        retrieves data on all markets for websea
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: an array of objects representing market data
        """
        # 并发获取现货和期货市场数据
        requests = [
            self.publicGetOpenApiMarketSymbols(params),
        ]
        # 尝试获取期货市场数据，如果失败则使用空数组
        swapRequestPromise = None
        try:
            swapRequestPromise = self.publicGetOpenApiFuturesSymbols(params)
            requests.append(swapRequestPromise)
        except Exception as e:
            # 如果期货API不可用，在后续处理中使用空数组
            # 这里不需要做任何操作
            pass
        # 并发执行所有请求
        responses = []
        try:
            responses = await asyncio.gather(*requests)
        except Exception as e:
            # 如果期货请求失败，只使用现货市场的响应
            spotResponse = await self.publicGetOpenApiMarketSymbols(params)
            responses = [spotResponse]
        spotMarkets = self.safe_value(responses[0], 'result', [])
        # 如果有期货市场响应则使用，否则使用空数组
        swapMarkets = self.safe_value(responses[1], 'result', []) if len(responses) > 1 else []
        # 为现货市场添加type字段
        for i in range(0, len(spotMarkets)):
            spotMarkets[i]['type'] = 'spot'
        # 为期货市场添加type字段
        for i in range(0, len(swapMarkets)):
            swapMarkets[i]['type'] = 'swap'
        allMarkets = self.array_concat(spotMarkets, swapMarkets)
        return self.parse_markets(allMarkets)

    def parse_market(self, market) -> Market:
        #
        # 现货市场:
        #     {
        #         "id": 1223,
        #         "symbol": "BTC-USDT",
        #         "base_currency": "BTC",
        #         "quote_currency": "USDT",
        #         "min_size": 0.0000001,
        #         "max_size": 10000,
        #         "min_price": 0.001,
        #         "max_price": 1000,
        #         "maker_fee": 0.002,
        #         "taker_fee": 0.002
        #     }
        #
        # 期货市场:
        #     {
        #         # 需要根据实际API响应结构调整
        #     }
        #
        marketId = self.safe_string(market, 'symbol')
        baseId = self.safe_string(market, 'base_currency')
        quoteId = self.safe_string(market, 'quote_currency')
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        minAmount = self.safe_number(market, 'min_size')
        maxAmount = self.safe_number(market, 'max_size')
        minPrice = self.safe_number(market, 'min_price')
        maxPrice = self.safe_number(market, 'max_price')
        # 检测是否为永续合约市场
        isSwap = marketId.find('-PERP') >= 0 or marketId.find('-SWAP') >= 0
        isSpot = not isSwap
        # Convert market ID to unified symbol format
        symbol = (base + '/' + quote) if isSpot else (base + '/' + quote + ':' + quote)
        # Calculate precision from min values - derive tick sizes from the minimum values
        minSizeString = self.safe_string(market, 'min_size')
        minPriceString = self.safe_string(market, 'min_price')
        # For TICK_SIZE mode, we need to ensure precision values are proper tick sizes
        # Use the minimum values sizes, but ensure they're not problematic integers
        amountPrecision = self.parse_number(minSizeString)
        pricePrecision = self.parse_number(minPriceString)
        # Ensure precision values are valid tick sizes(not integers like 5.0)
        # Convert problematic integer-like values to proper decimal tick sizes
        if amountPrecision is not None and amountPrecision >= 1 and amountPrecision % 1 == 0:
            amountPrecision = self.parse_number('0.00000001')  # Default to 8 decimal places
        if pricePrecision is not None and pricePrecision >= 1 and pricePrecision % 1 == 0:
            pricePrecision = self.parse_number('0.0001')  # Default to 4 decimal places for price
        # If precision values are still None, set safe defaults
        if amountPrecision is None:
            amountPrecision = self.parse_number('0.00000001')
        if pricePrecision is None:
            pricePrecision = self.parse_number('0.0001')
        return {
            'id': marketId,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'settle': quote if isSwap else None,  # 永续合约的结算币种
            'baseId': baseId,
            'quoteId': quoteId,
            'settleId': quoteId if isSwap else None,
            'type': 'swap' if isSwap else 'spot',
            'spot': isSpot,
            'margin': False,
            'swap': isSwap,
            'future': False,
            'option': False,
            'active': True,
            'contract': isSwap,
            'linear': True if isSwap else None,  # U本位永续合约
            'inverse': False if isSwap else None,
            'contractSize': 1 if isSwap else None,  # 永续合约的合约大小
            'expiry': None,
            'expiryDatetime': None,
            'strike': None,
            'optionType': None,
            'precision': {
                'amount': amountPrecision,
                'price': pricePrecision,
            },
            'limits': {
                'leverage': {
                    'min': None,
                    'max': None,
                },
                'amount': {
                    'min': minAmount,
                    'max': maxAmount,
                },
                'price': {
                    'min': minPrice,
                    'max': maxPrice,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
            'created': None,
            'info': market,
        }

    async def fetch_currencies(self, params={}) -> Currencies:
        """
        fetches all available currencies on an exchange
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an associative dictionary of currencies
        """
        response = await self.publicGetOpenApiMarketCurrencies(params)
        #
        #     {
        #         "errno": 0,
        #         "errmsg": "success",
        #         "result": {
        #             "BTC": {
        #                 "name": "Bitcoin",
        #                 "canWithdraw": True,
        #                 "canDeposit": True,
        #                 "minWithdraw": "0.001",
        #                 "maxWithdraw": "8",
        #                 "makerFee": "0.0016",
        #                 "takerFee": "0.0018"
        #             },
        #             ...
        #         }
        #     }
        #
        result = self.safe_value(response, 'result', {})
        currencies = {}
        currencyCodes = list(result.keys())
        for i in range(0, len(currencyCodes)):
            code = currencyCodes[i]
            currency = result[code]
            parsed = self.parse_currency(currency, code)
            currencies[code] = parsed
        return currencies

    def parse_currency(self, currency, code=None):
        #
        #     {
        #         "name": "Bitcoin",
        #         "canWithdraw": True,
        #         "canDeposit": True,
        #         "minWithdraw": "0.001",
        #         "maxWithdraw": "8",
        #         "makerFee": "0.0016",
        #         "takerFee": "0.0018"
        #     }
        #
        currencyCode = self.safe_currency_code(code)
        name = self.safe_string(currency, 'name')
        canDeposit = self.safe_bool(currency, 'canDeposit')
        canWithdraw = self.safe_bool(currency, 'canWithdraw')
        active = canDeposit and canWithdraw
        minWithdraw = self.safe_number(currency, 'minWithdraw')
        maxWithdraw = self.safe_number(currency, 'maxWithdraw')
        # For TICK_SIZE mode, use a proper tick size value
        precision = self.parse_number('0.00000001')  # 8 decimal places proper tick size
        return {
            'id': currencyCode,
            'code': currencyCode,
            'name': name,
            'type': 'crypto',
            'active': active,
            'deposit': canDeposit,
            'withdraw': canWithdraw,
            'fee': None,
            'precision': precision,
            'limits': {
                'amount': {
                    'min': None,
                    'max': None,
                },
                'deposit': {
                    'min': None,
                    'max': None,
                },
                'withdraw': {
                    'min': minWithdraw,
                    'max': maxWithdraw,
                },
            },
            'networks': {},
            'info': currency,
        }

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.publicGetOpenApiMarketDepth(self.extend(request, params))
        #
        # {
        #     "errno": 0,
        #     "errmsg": "success",
        #     "result": {
        #         "buyType": 1,
        #         "sellType": 1,
        #         "ts": 1760939021875,
        #         "symbol": "BTC-USDT",
        #         "asks": [["110725.6","0.2525"], ...],
        #         "bids": [["110725.5","1.9671"], ...]
        #     }
        # }
        #
        result = self.safe_value(response, 'result', {})
        timestamp = self.safe_integer(result, 'ts')
        # 处理订单簿数据，确保价格严格排序
        rawBids = self.safe_value(result, 'bids', [])
        rawAsks = self.safe_value(result, 'asks', [])
        # 聚合相同价格的订单
        aggregatedBids = self.aggregate_order_book_side(rawBids)
        aggregatedAsks = self.aggregate_order_book_side(rawAsks)
        # 创建新的订单簿对象，parseOrderBook会自动处理排序
        orderBook = {
            'bids': aggregatedBids,
            'asks': aggregatedAsks,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'nonce': None,
        }
        return self.parse_order_book(orderBook, market['symbol'], timestamp, 'bids', 'asks')

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = await self.publicGetOpenApiMarket24kline(self.extend(request, params))
        result = self.safe_value(response, 'result', [])
        if isinstance(result, list):
            for i in range(0, len(result)):
                tickerData = result[i]
                marketId = self.safe_string(tickerData, 'symbol')
                if marketId == market['id']:
                    return self.parse_ticker(tickerData, market)
            raise BadSymbol(self.id + ' fetchTicker() symbol ' + symbol + ' not found')
        else:
            # If result is not an array, it might be a single ticker object
            return self.parse_ticker(result, market)

    async def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        """
        fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        :param str[] [symbols]: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        response = await self.publicGetOpenApiMarket24kline(params)
        result = self.safe_value(response, 'result', [])
        tickers = []
        for i in range(0, len(result)):
            ticker = self.parse_ticker(result[i])
            tickers.append(ticker)
        return self.filter_by_array(tickers, 'symbol', symbols)

    def parse_ticker(self, ticker, market: Market = None) -> Ticker:
        #
        # Websea API响应格式:
        # {
        #     "symbol": "BTC-USDT",
        #     "data": {
        #         "id": 1760938769,
        #         "amount": "1289.933562236625251263",
        #         "count": 48117,
        #         "open": "106889.1",
        #         "close": "110752.1",
        #         "low": "106110.3",
        #         "high": "110812.8",
        #         "vol": "139704901.8914099999997562741"
        #     },
        #     "ask": "110752.3",
        #     "bid": "110752.0"
        # }
        #
        marketId = self.safe_string(ticker, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        data = self.safe_value(ticker, 'data', {})
        last = self.safe_number(data, 'close')
        open = self.safe_number(data, 'open')
        change = last - open if (last is not None and open is not None) else None
        percentage = (change / open) * 100 if (change is not None and open is not None and open != 0) else None
        baseVolume = self.safe_number(data, 'amount')
        quoteVolume = self.safe_number(data, 'vol')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': None,
            'datetime': None,
            'high': self.safe_number(data, 'high'),
            'low': self.safe_number(data, 'low'),
            'bid': self.safe_number(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_number(ticker, 'ask'),
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }, market)

    async def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int[][]: A list of candles ordered, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'period': self.safe_string(self.timeframes, timeframe, timeframe),
        }
        if since is not None:
            request['since'] = since
        if limit is not None:
            request['limit'] = limit
        response = await self.publicGetOpenApiMarketKline(self.extend(request, params))
        #
        # 需要根据实际API响应结构调整
        #
        result = self.safe_value(response, 'result', {})
        ohlcvs = self.safe_value(result, 'data', [])
        return self.parse_ohlcvs(ohlcvs, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        #
        # 需要根据实际API响应结构调整
        #
        return [
            self.safe_integer(ohlcv, 0),  # timestamp
            self.safe_number(ohlcv, 1),  # open
            self.safe_number(ohlcv, 2),  # high
            self.safe_number(ohlcv, 3),  # low
            self.safe_number(ohlcv, 4),  # close
            self.safe_number(ohlcv, 5),  # volume
        ]

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int [since]: timestamp in ms of the earliest trade to fetch
        :param int [limit]: the maximum amount of trades to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if since is not None:
            request['since'] = since
        if limit is not None:
            request['limit'] = limit
        response = await self.publicGetOpenApiMarketTrade(self.extend(request, params))
        #
        # {
        #     "errno": 0,
        #     "errmsg": "success",
        #     "result": {
        #         "symbol": "BTC-USDT",
        #         "ts": 1760939128378,
        #         "data": [
        #             {
        #                 "id": 1760939127130444,
        #                 "amount": "0.0003",
        #                 "price": "110798.6",
        #                 "vol": "33.23958",
        #                 "direction": "buy",
        #                 "ts": 1760939127
        #             }
        #         ]
        #     }
        # }
        #
        result = self.safe_value(response, 'result', {})
        trades = self.safe_value(result, 'data', [])
        return self.parse_trades(trades, market, since, limit)

    def parse_trade(self, trade, market: Market = None) -> Trade:
        #
        # {
        #     "id": 1760939127130444,
        #     "amount": "0.0003",
        #     "price": "110798.6",
        #     "vol": "33.23958",
        #     "direction": "buy",
        #     "ts": 1760939127
        # }
        #
        marketId = self.safe_string(trade, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        id = self.safe_string(trade, 'id')
        timestamp = self.safe_timestamp(trade, 'ts')  # Convert to milliseconds
        side = self.safe_string(trade, 'direction')
        priceString = self.safe_string(trade, 'price')
        amountString = self.safe_string(trade, 'amount')
        costString = self.safe_string(trade, 'vol')
        return self.safe_trade({
            'info': trade,
            'id': id,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'order': None,
            'type': None,
            'side': side,
            'takerOrMaker': None,
            'price': priceString,
            'amount': amountString,
            'cost': costString,
            'fee': None,
        }, market)

    async def fetch_balance(self, params={}) -> Balances:
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'swap', if not provided self.options['defaultType'] is used
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        await self.load_markets()
        marketType, query = self.handle_market_type_and_params('fetchBalance', None, params)
        response = None
        if marketType == 'swap':
            # Websea API没有专门的期货账户余额查询端点
            # 根据API文档，使用通用的钱包列表端点
            # 注意：这可能返回所有账户的余额，需要在解析时进行过滤
            response = await self.privateGetOpenApiWalletList(query)
        else:
            # 现货账户余额查询
            response = await self.privateGetOpenApiWalletList(query)
        #
        # Websea API响应格式示例:
        # {
        #     "errno": 0,
        #     "errmsg": "success",
        #     "result": [
        #         {
        #             "currency": "BTC",
        #             "available": "0.1",
        #             "frozen": "0.01",
        #             "total": "0.11"
        #         }
        #     ]
        # }
        #
        result = self.safe_value(response, 'result', [])
        return self.parse_balance(result)

    async def fetch_positions(self, symbols: Strings = None, params={}) -> List[Position]:
        """
        fetch all open positions
        :param str[] [symbols]: list of unified market symbols
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict[]: a list of `position structure <https://docs.ccxt.com/#/?id=position-structure>`
        """
        await self.load_markets()
        response = await self.privatePostOpenApiFuturesPositionList(params)
        #
        # 需要根据实际API响应结构调整
        #
        positions = self.safe_value(response, 'result', [])
        result = []
        for i in range(0, len(positions)):
            position = self.parse_position(positions[i])
            result.append(position)
        return self.filter_by_array(result, 'symbol', symbols)

    def parse_position(self, position, market=None):
        #
        # 需要根据实际API响应结构调整
        #
        marketId = self.safe_string(position, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        side = self.safe_string(position, 'side')
        amount = self.safe_number(position, 'amount')
        entryPrice = self.safe_number(position, 'entryPrice')
        markPrice = self.safe_number(position, 'markPrice')
        liquidationPrice = self.safe_number(position, 'liquidationPrice')
        leverage = self.safe_number(position, 'leverage')
        unrealizedPnl = self.safe_number(position, 'unrealizedPnl')
        realizedPnl = self.safe_number(position, 'realizedPnl')
        return {
            'info': position,
            'symbol': symbol,
            'timestamp': None,
            'datetime': None,
            'isolated': None,
            'leverage': leverage,
            'side': side,
            'contracts': amount,
            'contractSize': market['contractSize'],
            'entryPrice': entryPrice,
            'markPrice': markPrice,
            'notional': None,
            'liquidationPrice': liquidationPrice,
            'collateral': None,
            'initialMargin': None,
            'maintenanceMargin': None,
            'initialMarginPercentage': None,
            'maintenanceMarginPercentage': None,
            'marginRatio': None,
            'hedged': None,
            'percentage': None,
            'unrealizedPnl': unrealizedPnl,
            'realizedPnl': realizedPnl,
        }

    async def fetch_funding_rate(self, symbol: str, params={}) -> FundingRate:
        """
        fetch the current funding rate
        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a `funding rate structure <https://docs.ccxt.com/#/?id=funding-rate-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        if not market['swap']:
            raise BadSymbol(self.id + ' fetchFundingRate() supports swap contracts only')
        # 需要根据实际API实现
        raise NotSupported(self.id + ' fetchFundingRate() is not yet implemented')

    def parse_balance(self, response) -> Balances:
        result = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        for i in range(0, len(response)):
            balance = response[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'frozen')
            account['total'] = self.safe_string(balance, 'total')
            result[code] = account
        return self.safe_balance(result)

    def aggregate_order_book_side(self, orderBookSide: List[Any]) -> List[Any]:
        """
        aggregates orders with the same price by summing their amounts
        :param any[] orderBookSide: array of [price, amount] tuples
        :returns any[]: aggregated order book side
        """
        aggregated = {}
        for i in range(0, len(orderBookSide)):
            order = orderBookSide[i]
            price = self.safe_number(order, 0)
            amount = self.safe_number(order, 1)
            if price is not None and amount is not None:
                priceKey = str(price)
                if not (priceKey in aggregated):
                    aggregated[priceKey] = [price, amount]
                else:
                    aggregated[priceKey][1] += amount
        return list(aggregated.values())

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        """
        create a trade order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'swap', if not provided self.options['defaultType'] is used
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        marketType, query = self.handle_market_type_and_params('createOrder', market, params)
        orderType = side + '-limit' if (type == 'limit') else side + '-market'
        request = {
            'symbol': market['id'],
            'type': orderType,
            'amount': self.amount_to_precision(symbol, amount),
        }
        if type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
        response = None
        if marketType == 'swap':
            # 期货下单
            response = await self.privatePostOpenApiFuturesEntrustAdd(self.extend(request, query))
        else:
            # 现货下单
            response = await self.privatePostOpenApiEntrustAdd(self.extend(request, query))
        #
        # 需要根据实际API响应结构调整
        #
        result = self.safe_value(response, 'result', {})
        return self.parse_order(result, market)

    async def cancel_order(self, id: str, symbol: Str = None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'swap', if not provided self.options['defaultType'] is used
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        request = {
            'order_id': id,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        marketType, query = self.handle_market_type_and_params('cancelOrder', market, params)
        response = None
        if marketType == 'swap':
            # 期货取消订单
            response = await self.privatePostOpenApiFuturesEntrustCancel(self.extend(request, query))
        else:
            # 现货取消订单
            response = await self.privatePostOpenApiEntrustCancel(self.extend(request, query))
        #
        # 需要根据实际API响应结构调整
        #
        result = self.safe_value(response, 'result', {})
        return self.parse_order(result)

    async def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        """
        fetches information on an order made by the user
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'swap', if not provided self.options['defaultType'] is used
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        request = {
            'order_id': id,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        marketType, query = self.handle_market_type_and_params('fetchOrder', market, params)
        response = None
        if marketType == 'swap':
            # 期货订单详情
            response = await self.privatePostOpenApiFuturesEntrustOrderDetail(self.extend(request, query))
        else:
            # 现货订单详情
            response = await self.privatePostOpenApiEntrustOrderDetail(self.extend(request, query))
        #
        # 需要根据实际API响应结构调整
        #
        result = self.safe_value(response, 'result', {})
        return self.parse_order(result)

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetch all unfilled currently open orders
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of  open orders structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'swap', if not provided self.options['defaultType'] is used
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['start_time'] = since
        if limit is not None:
            request['limit'] = limit
        marketType, query = self.handle_market_type_and_params('fetchOpenOrders', market, params)
        response = None
        if marketType == 'swap':
            # 期货当前订单列表
            response = await self.privatePostOpenApiFuturesEntrustOrderList(self.extend(request, query))
        else:
            # 注意：Websea API没有提供获取当前订单的端点
            # 只能获取历史订单，所以fetchOpenOrders暂时无法实现
            raise NotSupported(self.id + ' fetchOpenOrders is not supported by the API')
        #
        # 需要根据实际API响应结构调整
        #
        result = self.safe_value(response, 'result', [])
        return self.parse_orders(result, None, since, limit)

    async def fetch_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetches information on multiple closed orders made by the user
        :param str symbol: unified market symbol of the market orders were made in
        :param int [since]: the earliest time in ms to fetch orders for
        :param int [limit]: the maximum number of order structures to retrieve
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :param str [params.type]: 'spot' or 'swap', if not provided self.options['defaultType'] is used
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['start_time'] = since
        if limit is not None:
            request['limit'] = limit
        marketType, query = self.handle_market_type_and_params('fetchClosedOrders', market, params)
        response = None
        if marketType == 'swap':
            # Websea API没有提供专门的期货历史订单列表端点
            # 根据API文档，使用通用的历史订单列表端点
            # 注意：这可能不会区分现货和期货订单，需要在解析时进行过滤
            response = await self.privateGetOpenApiEntrustHistoryList(self.extend(request, query))
        else:
            # 现货历史订单列表
            response = await self.privateGetOpenApiEntrustHistoryList(self.extend(request, query))
        #
        # Websea API响应格式示例:
        # {
        #     "errno": 0,
        #     "errmsg": "success",
        #     "result": [
        #         {
        #             "order_id": "123456",
        #             "symbol": "BTC-USDT",
        #             "side": "buy",
        #             "type": "limit",
        #             "price": "50000",
        #             "amount": "0.1",
        #             "filled": "0.1",
        #             "remaining": "0",
        #             "status": "closed",
        #             "create_time": 1630000000000,
        #             "update_time": 1630000001000
        #         }
        #     ]
        # }
        #
        result = self.safe_value(response, 'result', [])
        # 如果是期货市场类型，需要过滤结果以仅包含期货订单
        filteredResult = result
        if marketType == 'swap' and market is not None:
            filteredResult = []
            for i in range(0, len(result)):
                order = result[i]
                orderSymbol = self.safe_string(order, 'symbol')
                # 检查订单符号是否为期货市场
                if orderSymbol == market['id'] and market['swap']:
                    filteredResult.append(order)
        return self.parse_orders(filteredResult, None, since, limit)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api']['rest']
        url += '/' + path
        query = self.omit(params, self.extract_params(path))
        if api == 'private':
            self.check_required_credentials()
            # Websea API签名要求：timestamp_5random格式
            timestamp = str(self.seconds())
            randomChars = self.uuid()[0:5]
            nonce = timestamp + '_' + randomChars
            # 构建签名数组：Token + Secret + Nonce + 所有参数
            signatureArray = [
                self.apiKey,
                self.secret,
                nonce,
            ]
            # 添加所有查询参数到签名数组（格式：key=value）
            queryKeys = list(query.keys())
            for i in range(0, len(queryKeys)):
                key = queryKeys[i]
                value = str(query[key])
                signatureArray.append(key + '=' + value)
            # 对数组进行排序
            signatureArray.sort()
            # 连接所有元素并计算SHA1签名
            message = ''.join(signatureArray)
            signature = self.hash(self.encode(message), 'sha1', 'hex')
            headers = {
                'Nonce': nonce,
                'Token': self.apiKey,
                'Signature': signature,
                'Content-Type': 'application/json',
            }
            if method == 'GET':
                if query:
                    queryString = self.urlencode(query)
                    url += '?' + queryString
            else:
                body = self.json(query)
                headers['Content-Length'] = str(self.string_to_base64(len(body)))
        else:
            # 公共API请求
            if query:
                queryString = self.urlencode(query)
                url += '?' + queryString
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if response is None:
            return None
        errorCode = self.safe_string(response, 'errno')
        if errorCode is not None and errorCode != '0':
            errorMessage = self.safe_string(response, 'errmsg', 'Unknown error')
            # 处理特定的Websea错误消息
            if errorMessage.find('symbol error') >= 0 or errorMessage.find('base symbol error') >= 0:
                raise BadSymbol(self.id + ' ' + errorMessage)
            if errorMessage.find('The request method is wrong') >= 0:
                raise ExchangeError(self.id + ' Invalid HTTP method for self endpoint. Please check the API documentation.')
            if errorMessage.find('The request address does not exist') >= 0:
                raise ExchangeError(self.id + ' API endpoint not found. Please check the API documentation.')
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, errorMessage)
            self.throw_broadly_matched_exception(self.exceptions['broad'], errorMessage, errorMessage)
            raise ExchangeError(self.id + ' ' + errorMessage)
        return None
