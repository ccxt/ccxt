# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.deepcoin import ImplicitAPI
import hashlib
from ccxt.base.types import Balances, Int, Market, MarketType, Num, Order, OrderBook, OrderSide, OrderType, Str, Strings, Ticker, Tickers, Trade
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.decimal_to_precision import TICK_SIZE


class deepcoin(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(deepcoin, self).describe(), {
            'id': 'deepcoin',
            'name': 'deepcoin',
            'version': 'v1',
            'countries': ['SG'],
            'rateLimit': 1000,
            'pro': False,
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchTicker': True,
                'fetchTickers': True,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1H': '1H',
                '2H': '2H',
                '4H': '4H',
                '12H': '12H',
                '1D': '1D',
                '1W': '1W',
                '1M': '1M',
                '1Y': '1Y',
            },
            'urls': {
                'logo': 'https://www.deepcoin.com/static/images/nav-logo-black-7ad2482d753feb3.svg',
                'api': {
                    'v1': {
                        'public': 'https://api.deepcoin.com',  # 'https://test-api.goodtest.cc',  # 'https://api.deepcoin.com/',
                        'private': 'https://test-api.goodtest.cc',
                    },
                },
                'www': 'https://www.deepcoin.com',
                'doc': 'https://www.deepcoin.com/en/docs',
            },
            'precisionMode': TICK_SIZE,
            'api': {
                'v1': {
                    'private': {
                        'post': [
                            'deepcoin/trade/cancel-order',
                            'deepcoin/trade/order',
                        ],
                        'get': [
                            'deepcoin/trade/orders-pending',
                            'deepcoin/trade/orders-history',
                            'deepcoin/trade/order',
                            'deepcoin/trade/fills',
                            'deepcoin/account/balances',
                        ],
                    },
                    'public': {
                        'get': [
                            'deepcoin/market/instruments',
                            'deepcoin/market/tickers',
                            'deepcoin/market/books',
                            'deepcoin/market/candles',
                        ],
                    },
                },
            },
            'fees': {
                'trading': {
                    # 'tierBased': False,
                    # 'percentage': True,
                    # 'taker': self.parse_number('0.001'),
                    # 'maker': self.parse_number('0.001'),
                },
            },
            'exceptions': {
                'exact': {},
                'broad': {
                },
            },
        })

    async def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        """
        fetch all trades made by the user
        https://www.deepcoin.com/en/docs#deepcoin-trade-fills
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch trades for
        :param int [limit]: the maximum number of trades structures to retrieve
        :param str [params.instType]: Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Trade[]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request: dict = {
            'instType': self.safe_string(params, 'instType', 'SPOT'),
        }
        if since is not None:
            request['begin'] = since
        if limit is not None:
            request['limit'] = limit
        response = await self.v1PrivateGetDeepcoinTradeFills(self.extend(request, params))
        result = self.safe_list(response, 'data', [])
        return self.parse_trades(result, market, since, limit)

    async def fetch_balance(self, params={}) -> Balances:
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param str [params.instType]: Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        :param dict [params.ccy]: currency, eg:'USDT'
        :returns dict: a `balance structure <https://docs.ccxt.com/#/?id=balance-structure>`
        """
        request: dict = {
            'instType': self.safe_string(params, 'instType', 'SPOT'),
        }
        response = await self.v1PrivateGetDeepcoinAccountBalances(self.extend(request, params))
        return self.parse_balance(response)

    async def fetch_order(self, id: str, symbol: Str = None, params={}) -> Order:
        """
        fetches information on an order made by the user
        :param str symbol: unified market symbol
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'instId': market['id'],
            'ordId': id,
        }
        response = await self.v1PrivateGetDeepcoinTradeOrder(self.extend(request, params))
        data = self.safe_list(response, 'data', [])
        if len(data) == 0:
            return self.safe_order({})
        return self.parse_order(self.extend(request, params, data[0]))

    async def fetch_closed_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetch all unfilled currently open orders
        https://www.deepcoin.com/en/docs#deepcoin-trade-orders-history
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of open order structures to retrieve
        :param str [params.instType]: Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        :param str [params.ordType]: Order type. 'market': Market order,'limit': Limit order,'post_only': Post-only order
        :param str [params.state]: State. 'live' or 'partially_filled'
        :param str [params.after]: Pagination of data to return records earlier than the requested ordId, eg:"1000314896749646
        :param str [params.before]: Pagination of data to return records newer than the requested ordId, eg:"1000314896749646
        :param dict [params.ordId]: order id
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        request: dict = {
            'instType': self.safe_string(params, 'instType', 'SPOT'),
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.v1PrivateGetDeepcoinTradeOrdersHistory(self.extend(request, params))
        data = self.safe_list(response, 'data', [])
        result = []
        for i in range(0, len(data)):
            result.append(self.parse_order(self.extend(request, params, data[i])))
        return result

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        """
        fetch all unfilled currently open orders
        https://www.deepcoin.com/en/docs#deepcoin-trade-orders-pending
        :param str symbol: unified market symbol
        :param int [since]: the earliest time in ms to fetch open orders for
        :param int [limit]: the maximum number of open order structures to retrieve
        :param str [params.instType]: Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
        :param str [params.ordType]: Order type. 'market': Market order,'limit': Limit order,'post_only': Post-only order
        :param str [params.state]: State. 'live' or 'partially_filled'
        :param str [params.after]: Pagination of data to return records earlier than the requested ordId, eg:"1000314896749646
        :param str [params.before]: Pagination of data to return records newer than the requested ordId, eg:"1000314896749646
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns Order[]: a list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        ordType = self.safe_string(params, 'ordType')
        state = self.safe_string(params, 'state')
        after = self.safe_string(params, 'after')
        before = self.safe_string(params, 'before')
        request: dict = {
            'instType': self.safe_string(params, 'instType', 'SPOT'),
        }
        if limit is not None:
            request['limit'] = limit
        if ordType is not None:
            request['ordType'] = ordType
        if state is not None:
            request['state'] = state
        if after is not None:
            request['after'] = after
        if before is not None:
            request['before'] = before
        response = await self.v1PrivateGetDeepcoinTradeOrdersPending(self.extend(request, params))
        data = self.safe_list(response, 'data', [])
        result = []
        for i in range(0, len(data)):
            result.append(self.parse_order(self.extend(request, params, data[i])))
        return result

    async def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        https://www.deepcoin.com/en/docs#deepcoin-market-candles
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int [since]: timestamp in ms of the earliest candle to fetch
        :param int [limit]: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns int[][]: A list of candles ordered, open, high, low, close, volume(base units)
        """
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'instId': market['id'],
            'bar': self.safe_string(self.timeframes, timeframe, timeframe),
        }
        if since is not None:
            request['before'] = since
        if limit is not None:
            request['limit'] = limit
        response = await self.v1PublicGetDeepcoinMarketCandles(self.extend(request, params))
        result = self.safe_list(response, 'data', [])
        return self.parse_ohlcvs(result, market, timeframe, since, limit)

    async def fetch_order_book(self, symbol: str, limit: Int = 10, params={}) -> OrderBook:
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        https://www.deepcoin.com/en/docs#deepcoin-market-books
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int [limit]: the maximum amount of order book entries to return
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'instId': market['id'],
            'sz': limit,
        }
        response = await self.v1PublicGetDeepcoinMarketBooks(self.extend(request, params))
        result = self.safe_dict(response, 'data', {})
        return self.parse_order_book(result, market['symbol'], None)

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        fetches price tickers for multiple data, statistical information calculated over the past 24 hours for each market
        https://www.deepcoin.com/en/docs#deepcoin-market-tickers
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of `ticker structures <https://www.deepcoin.com/en/docs#deepcoin-market-tickers>`
        """
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'instType': self.market_type_to_inst_type(market['type']),
            'instId': market['id'],
        }
        response = await self.v1PublicGetDeepcoinMarketTickers(self.extend(request, params))
        tickers = self.safe_list(response, 'data', [])
        result: dict = {}
        for i in range(0, len(tickers)):
            ticker = self.parse_ticker(tickers[i])
            result[ticker['symbol']] = ticker
        result = self.filter_by_array_tickers(result, 'symbol', [symbol])
        return result[symbol]

    async def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        """
        fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        https://www.deepcoin.com/en/docs#deepcoin-market-tickers
        :param str[]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of `ticker structures <https://www.deepcoin.com/en/docs#deepcoin-market-tickers>`
        """
        request: dict = {
            'instType': self.safe_string(params, 'instType', 'SPOT'),
        }
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        response = await self.v1PublicGetDeepcoinMarketTickers(self.extend(request, params))
        tickers = self.safe_list(response, 'data', [])
        result: dict = {}
        for i in range(0, len(tickers)):
            ticker = self.parse_ticker(tickers[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return self.filter_by_array_tickers(result, 'symbol', symbols)

    async def fetch_markets(self, params={}) -> List[Market]:
        """
        retrieves data on all markets for deepcoin
        https://www.deepcoin.com/en/docs#deepcoin-market-instruments
        :param str [params.uly]: Underlying. Only applicable to SWAP
        :param str [params.instId]: Instrument ID
        :returns dict[]: an array of objects representing market data
        """
        instTypes = ['SPOT', 'SWAP']
        result = []
        for j in range(0, len(instTypes)):
            request: dict = {
                'instType': instTypes[j],
            }
            response = await self.v1PublicGetDeepcoinMarketInstruments(self.extend(request, params))
            markets = self.safe_list(response, 'data', [])
            for i in range(0, len(markets)):
                result.append(self.parse_market(markets[i]))
        return result

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        """
        create a trade order
        https://www.deepcoin.com/en/docs#deepcoin-trade-order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float [price]: the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        :param str [params.tdMode]: Margin mode 'cross', isolated Non-Margin mode 'cash', 'cash' by default
        :param str [params.ccy]: Margin currency. Only applicable to cross MARGIN orders in Single-currency margin. eg:'USDT'
        :param str [params.clOrdId]: client order id by the client, A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters
        :param str [params.ccy]: Margin currency. Only applicable to cross MARGIN orders in Single-currency margin. eg:'USDT'
        :param str [params.tag]:  Order tag. A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 16 characters
        :param str [params.posSide]: Position side. 'long' or 'short'
        :param str [params.mrgPosition]: Margin position. 'merge' or 'split'
        :param str [params.closePosId]: Waiting for closing split margin positions. Required in split margin mode. eg:'1001063717138767'
        :param str [params.reduceOnly]: Whether the order can only reduce the position size. Valid options: 'true' or 'false'. The default value is 'false'. Only applicable to MARGIN orders, and FUTURES/SWAP orders in net mode Only applicable to Single-currency margin and Multi-currency margin
        :param str [params.tgtCcy]: Quantity type. 'base_ccy': Base currency, 'quote_ccy': Quote currency, Only applicable to SPOT Market Orders Default is 'quote_ccy' for buy, 'base_ccy' for sell
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        tdMode = self.safe_string(params, 'tdMode', 'cash')
        request: dict = {
            'instId': market['id'],
            'side': side,
            'sz': amount,
            'tdMode': tdMode,
            'ordType': type,
            'px': price,
        }
        response = await self.v1PrivatePostDeepcoinTradeOrder(self.extend(request, params))
        result = self.safe_dict(response, 'data', {})
        return self.parse_order(self.extend(request, params, result))

    async def cancel_order(self, id: str, symbol: str = None, params={}):
        """
        cancels an open order
        https://www.deepcoin.com/en/docs#deepcoin-trade-cancel-order
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param str [params.clOrdId]: client order id by the client, A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'instId': market['id'],
            'ordId': id,
        }
        response = await self.v1PrivatePostDeepcoinTradeCancelOrder(self.extend(request, params))
        return self.parse_order(response)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        orderId = self.safe_string(trade, 'ordId')
        timestamp = self.safe_number(trade, 'ts')
        fee = {
            'cost': self.safe_string(trade, 'fee'),
            'currency': self.safe_string(trade, 'feeCcy'),
        }
        return self.safe_trade({
            'info': trade,
            'id': orderId,
            'order': orderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': self.safe_string_upper(trade, 'instId'),
            'type': None,
            'side': self.safe_string(trade, 'side'),
            'price': self.safe_number(trade, 'fillPx'),
            'amount': self.safe_number(trade, 'fillSz'),
            'cost': None,
            'takerOrMaker': self.safe_string_upper(trade, 'execType'),
            'fee': fee,
        }, market)

    def parse_balance(self, response) -> Balances:
        balances = self.safe_list(response, 'data', [])
        result: dict = {'info': balances}
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_string(balance, 'ccy')
            account = self.account()
            account['total'] = self.safe_string(balance, 'bal')
            account['free'] = self.safe_string(balance, 'availBal')
            account['used'] = self.safe_string(balance, 'frozenBal')
            result[code] = account
        return self.safe_balance(result)

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        timestamp = self.safe_number(ticker, 'ts', 0.001)
        # last = self.safe_string(ticker, 'close')
        return self.safe_ticker({
            'info': ticker,
            'symbol': self.safe_string_upper(ticker, 'instId'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_number(ticker, 'high24h'),
            'low': self.safe_number(ticker, 'low24h'),
            'bid': self.safe_number(ticker, 'bidPx'),
            'bidVolume': self.safe_number(ticker, 'bidSz'),
            'ask': self.safe_number(ticker, 'askPx'),
            'askVolume': self.safe_number(ticker, 'askSz'),
            'vwap': None,  # volume weighed average price
            'open': self.safe_string(ticker, 'open24h'),
            'close': self.safe_number(ticker, 'last'),  # price of last trade(closing price for current period)
            'last': self.safe_number(ticker, 'last'),  # same as `close`, duplicated for convenience
            'previousClose': None,  # closing price for the previous period
            'baseVolume': self.safe_number(ticker, 'volCcy24h'),    # volume of base currency traded for last 24 hours
            'quoteVolume': self.safe_number(ticker, 'vol24h'),  # volume of quote currency traded for last 24 hours
        }, market)

    def parse_market(self, market: dict) -> Market:
        instType = self.safe_string(market, 'instType')
        id = self.safe_string(market, 'instId')
        isSpot = False
        isSwap = False
        isContract = False
        type: MarketType
        if instType == 'SPOT':
            isSpot = True
            type = 'spot'
        elif instType == 'SWAP':
            isSwap = True
            isContract = True
            type = 'swap'
        # uly = self.safe_string(market, 'uly')
        base = self.safe_string_upper(market, 'baseCcy')
        quote = self.safe_string_upper(market, 'quoteCcy')
        state = self.safe_string(market, 'state')
        active = state == 'live'
        contractSize = self.safe_number(market, 'ctVal')
        settle = self.safe_string(market, 'ctValCcy')
        created = self.safe_number(market, 'listTime')
        maxLever = self.safe_number(market, 'lever')
        minSz = self.safe_number(market, 'minSz')
        ctType = self.safe_string(market, 'ctType')
        # alias = self.safe_string(market, 'alias')
        # maxLmtSz = self.safe_string(market, 'maxLmtSz')
        # maxMktSz = self.safe_string(market, 'maxMktSz')
        pricePrecision = self.safe_number(market, 'tickSz')
        amountPrecision = self.safe_number(market, 'lotSz')
        return {
            'info': market,
            'id': id,                           # string literal for referencing within an exchange
            'symbol': self.safe_string_upper(market, 'instId'),                   # uppercase string literal of a pair of currencies
            'base': base,                       # uppercase string, unified base currency code, 3 or more letters
            'quote': quote,                     # uppercase string, unified quote currency code, 3 or more letters
            'baseId': base,                     # any string, exchange-specific base currency id
            'quoteId': quote,                   # any string, exchange-specific quote currency id
            'active': active,                   # boolean, market status
            'type': type,                       # spot for spot, future for expiry futures, swap for perpetual swaps, 'option' for options
            'spot': isSpot,                     # whether the market is a spot market
            'margin': None,                # whether the market is a margin market
            'future': None,                # whether the market is a expiring future
            'swap': isSwap,                     # whether the market is a perpetual swap
            'option': None,                # whether the market is an option contract
            'contract': isContract,              # whether the market is a future, a perpetual swap, or an option
            'settle': settle,                # the unified currency code that the contract will settle in, only set if `contract` is True
            'settleId': settle,              # the currencyId of that the contract will settle in, only set if `contract` is True
            'contractSize': contractSize,          # the size of one contract, only used if `contract` is True
            'linear': ctType == 'linear',      # the contract is a linear contract(settled in quote currency)
            'inverse': ctType == 'inverse',               # the contract is an inverse contract(settled in base currency)
            'expiry': None,                # the unix expiry timestamp in milliseconds, None for everything except market['type'] `future`
            'expiryDatetime': None,        # The datetime contract will in iso8601 format
            'strike': None,                # price at which a put or call option can be exercised
            'optionType': None,            # call or put string, call option represents an option with the right to buy and put an option with the right to sell
            'taker': None,                 # taker fee rate, 0.002 = 0.2%
            'maker': None,                 # maker fee rate, 0.0016 = 0.16%
            'percentage': None,            # whether the taker and maker fee rate is a multiplier or a fixed flat amount
            'tierBased': None,             # whether the fee depends on your trading tier(your trading volume)
            'feeSide': None,               # string literal can be 'get', 'give', 'base', 'quote', 'other'
            'precision': {                     # number of decimal digits "after the dot"
                'price': pricePrecision,            # integer or float for tick_size roundingMode, might be missing if not supplied by the exchange
                'amount': amountPrecision,          # integer, might be missing if not supplied by the exchange
                'cost': None,                  # integer, very few exchanges actually have it
            },
            'limits': {                        # value limits when placing orders on self market
                'amount': {
                    'min': minSz,    # order amount should be > min
                    'max': None,                   # order amount should be < max
                },
                'price': {         # same min/max limits for the price of the order
                    'min': None,
                    'max': None,
                },
                'cost': {          # same limits for order cost = price * amount
                    'min': None,
                    'max': None,
                },
                'leverage': {          # same limits for order cost = price * amount
                    'min': None,
                    'max': maxLever,
                },
            },
            'created': created,
        }

    def parse_status(self, state: str) -> str:
        if state == 'live' or state == 'partially_filled':
            return 'open'
        elif state == 'filled':
            return 'closed'
        elif state == 'canceled':
            return 'canceled'
        else:
            return None

    def parse_order(self, order: dict, market: Market = None) -> Order:
        timestamp = self.safe_number(order, 'cTime')
        lastTradeTimestamp = self.safe_number(order, 'fillTime')
        return self.safe_order({
            'info': order,
            'id': self.safe_string(order, 'ordId'),
            'symbol': self.safe_string_upper(order, 'instId'),
            'clientOrderId': self.safe_string(order, 'clOrdId'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'status': self.parse_status(self.safe_string(order, 'state')),
            'timeInForce': None,                                              # 'GTC', 'IOC', 'FOK', 'PO'
            'side': self.safe_string(order, 'side'),
            'type': self.safe_string(order, 'ordType'),                         # 'market', 'limit'
            'price': self.safe_number(order, 'px'),                             # float price in quote currency(may be empty for market orders)
            'average': self.safe_number(order, 'avgPx'),                        # float average filling price
            'amount': self.safe_number(order, 'sz'),                            # ordered amount of base currency
            'filled': self.safe_number(order, 'accFillSz'),                     # filled amount of base currency
            'remaining': None,                                                 # remaining amount to fill
            'cost': None,                                                      # 'filled' * 'price'(filling price used where available)
            'fee': {
                'currency': self.safe_string(order, 'feeCcy'),
                'cost': self.safe_number(order, 'fee'),
            },
            # stopPrice?: number
            # triggerPrice?: number
            # 'takeProfitPrice': self.safe_number(order, 'tpOrdPx'),
            # 'stopLossPrice': self.safe_number(order, 'slOrdPx'),
            # reduceOnly: Bool
            'postOnly': self.safe_string(order, 'ordType') == 'post_only',
            'trades': None,
        })

    def market_type_to_inst_type(self, type: str) -> str:
        return type.upper()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        version = self.safe_value(api, 0)
        accessibility = self.safe_value(api, 1)
        query = self.urlencode(params)
        timestamp = self.iso8601(self.milliseconds())
        url = self.urls['api'][version][accessibility] + '/' + path
        payload = timestamp + method + '/' + path
        if method == 'GET':
            url += '?' + query
            payload += '?' + query
        elif method == 'POST':
            body = self.json(params)
            payload += body
        if accessibility == 'private':
            secret = self.secret
            signature = self.hmac(self.encode(payload), self.encode(secret), hashlib.sha256, 'base64')
            headers = {
                'Content-Type': 'application/json',
                'DC-ACCESS-KEY': self.apiKey,
                'DC-ACCESS-SIGN': signature,
                'DC-ACCESS-TIMESTAMP': timestamp,
                'DC-ACCESS-PASSPHRASE': self.password,
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if response is None:
            return None
        errorCode = self.safe_string_2(response, 'sCode', 'code')
        errorMsg = self.safe_string_2(response, 'sMsg', 'msg')
        if errorCode is not None and errorCode != '0':
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], errorMsg, feedback)
            raise ExchangeError(feedback)
        return None
