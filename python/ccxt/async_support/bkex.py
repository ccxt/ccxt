# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import asyncio
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.decimal_to_precision import TICK_SIZE


class bkex(Exchange):

    def describe(self):
        return self.deep_extend(super(bkex, self).describe(), {
            'id': 'bkex',
            'name': 'BKEX',
            'countries': ['BVI'],  # British Virgin Islands
            'rateLimit': 100,
            'version': 'v2',
            'certified': False,
            'has': {
                'CORS': None,
                'spot': None,
                'margin': None,
                'swap': None,
                'future': None,
                'option': None,
                'addMargin': None,
                'cancelAllOrders': None,
                'cancelOrder': True,
                'cancelOrders': True,
                'createDepositAddress': None,
                'createLimitOrder': None,
                'createMarketOrder': None,
                'createOrder': True,
                'editOrder': None,
                'fetchAccounts': None,
                'fetchBalance': True,
                'fetchBidsAsks': None,
                'fetchBorrowRate': None,
                'fetchBorrowRateHistory': None,
                'fetchBorrowRates': None,
                'fetchBorrowRatesPerSymbol': None,
                'fetchCanceledOrders': None,
                'fetchClosedOrder': None,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDeposit': False,
                'fetchDepositAddress': True,
                'fetchDepositAddresses': None,
                'fetchDepositAddressesByNetwork': None,
                'fetchDeposits': True,
                'fetchDepositWithdrawFee': 'emulated',
                'fetchDepositWithdrawFees': True,
                'fetchFundingHistory': None,
                'fetchFundingRate': None,
                'fetchFundingRateHistory': True,
                'fetchFundingRates': None,
                'fetchIndexOHLCV': None,
                'fetchL2OrderBook': None,
                'fetchLedger': None,
                'fetchLedgerEntry': None,
                'fetchLeverageTiers': None,
                'fetchMarginMode': False,
                'fetchMarketLeverageTiers': True,
                'fetchMarkets': True,
                'fetchMarkOHLCV': None,
                'fetchMyTrades': None,
                'fetchOHLCV': True,
                'fetchOpenOrder': True,
                'fetchOpenOrders': True,
                'fetchOrder': False,
                'fetchOrderBook': True,
                'fetchOrderBooks': None,
                'fetchOrders': None,
                'fetchOrderTrades': None,
                'fetchPosition': None,
                'fetchPositionMode': False,
                'fetchPositions': None,
                'fetchPositionsRisk': None,
                'fetchPremiumIndexOHLCV': None,
                'fetchStatus': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': None,
                'fetchTransactionFee': 'emulated',
                'fetchTransactionFees': True,
                'fetchTransactions': None,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'fetchWithdrawal': False,
                'fetchWithdrawals': True,
                'privateAPI': True,
                'publicAPI': True,
                'reduceMargin': None,
                'setLeverage': None,
                'setMarginMode': None,
                'setPositionMode': None,
                'signIn': None,
                'transfer': False,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '4h': '4h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1d',
                '1w': '1w',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/158043180-bb079a65-69e8-45a2-b393-f094d334e610.jpg',
                'api': {
                    'spot': 'https://api.bkex.com',
                    'swap': 'https://fapi.bkex.com',
                },
                'www': 'https://www.bkex.com/',
                'doc': [
                    'https://bkexapi.github.io/docs/api_en.htm',
                ],
                'fees': [
                    'https://www.bkex.com/help/instruction/33',
                ],
            },
            'api': {
                'public': {
                    'spot': {
                        'get': {
                            '/common/symbols': 1,
                            '/common/currencys': 1,
                            '/common/timestamp': 1,
                            '/q/kline': 1,
                            '/q/tickers': 1,
                            '/q/ticker/price': 1,
                            '/q/depth': 1,
                            '/q/deals': 1,
                        },
                    },
                    'swap': {
                        'get': {
                            '/market/candle': 1,
                            '/market/deals': 1,
                            '/market/depth': 1,
                            '/market/fundingRate': 1,
                            '/market/index': 1,
                            '/market/riskLimit': 1,
                            '/market/symbols': 1,
                            '/market/ticker/price': 1,
                            '/market/tickers': 1,
                            '/server/ping': 1,
                        },
                    },
                },
                'private': {
                    'spot': {
                        'get': {
                            '/u/api/info': 1,
                            '/u/account/balance': 1,
                            '/u/wallet/address': 1,
                            '/u/wallet/depositRecord': 1,
                            '/u/wallet/withdrawRecord': 1,
                            '/u/order/openOrders': 1,
                            '/u/order/openOrder/detail': 1,
                            '/u/order/historyOrders': 1,
                        },
                        'post': {
                            '/u/account/transfer': 1,
                            '/u/wallet/withdraw': 1,
                            '/u/order/create': 1,
                            '/u/order/cancel': 1,
                            '/u/order/batchCreate': 1,
                            '/u/order/batchCancel': 1,
                        },
                    },
                    'swap': {
                        'get': {
                            '/account/balance': 1,
                            '/account/balanceRecord': 1,
                            '/account/order': 1,
                            '/account/orderForced': 1,
                            '/account/position': 1,
                            '/entrust/finished': 1,
                            '/entrust/unFinish': 1,
                            '/order/finished': 1,
                            '/order/finishedInfo': 1,
                            '/order/unFinish': 1,
                            '/position/info': 1,
                        },
                        'post': {
                            '/account/setLeverage': 1,
                            '/entrust/add': 1,
                            '/entrust/cancel': 1,
                            '/order/batchCancel': 1,
                            '/order/batchOpen': 1,
                            '/order/cancel': 1,
                            '/order/close': 1,
                            '/order/closeAll': 1,
                            '/order/open': 1,
                            '/position/setSpSl': 1,
                            '/position/update': 1,
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': self.parse_number('0.0015'),
                    'taker': self.parse_number('0.002'),
                },
            },
            'options': {
                'timeframes': {
                    'spot': {
                        '1m': '1m',
                        '5m': '5m',
                        '15m': '15m',
                        '30m': '30m',
                        '1h': '1h',
                        '4h': '4h',
                        '6h': '6h',
                        '12h': '12h',
                        '1d': '1d',
                        '1w': '1w',
                    },
                    'swap': {
                        '1m': 'M1',
                        '5m': 'M5',
                        '15m': 'M15',
                        '30m': 'M30',
                        '1h': 'H1',
                        '4h': 'H4',
                        '6h': 'H6',
                        '1d': 'D1',
                    },
                },
                'defaultType': 'spot',  # spot, swap
                'networks': {
                    'TRX': 'TRC-20',
                    'TRC20': 'TRC-20',
                    'ETH': 'ERC-20',
                    'ERC20': 'ERC-20',
                    'BEP20': 'BEP-20(BSC)',
                },
            },
            'commonCurrencies': {
                'SHINJA': 'SHINJA(1M)',
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {
                    '1005': InsufficientFunds,
                },
                'broad': {
                    'Not Enough balance': InsufficientFunds,
                    'Order does not exist': InvalidOrder,
                    'System busy, please try again later': BadRequest,  # in my tests, self was thrown mostly when request was bad, not the problem of exchange. It is easily reproduced in 'cancelOrders'
                },
            },
        })

    async def fetch_markets(self, params={}):
        """
        retrieves data on all markets for bkex
        see https://bkexapi.github.io/docs/api_en.htm?shell#basicInformation-1
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-market-symbols
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns [dict]: an array of objects representing market data
        """
        promises = [
            self.publicSpotGetCommonSymbols(params),
            self.publicSwapGetMarketSymbols(params),
        ]
        promises = await asyncio.gather(*promises)
        spotMarkets = promises[0]
        #
        #     {
        #         "code": "0",
        #         "data": [
        #             {
        #                 "minimumOrderSize": "0",
        #                 "minimumTradeVolume": "0E-18",
        #                 "pricePrecision": "11",
        #                 "supportTrade": True,
        #                 "symbol": "COMT_USDT",
        #                 "volumePrecision": 0
        #             },
        #         ],
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        swapMarkets = promises[1]
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "luna_usdt",
        #                 "supportTrade": False,
        #                 "volumePrecision": 0,
        #                 "pricePrecision": 3,
        #                 "marketMiniAmount": "1",
        #                 "limitMiniAmount": "1"
        #             },
        #         ]
        #     }
        #
        spotData = self.safe_value(spotMarkets, 'data', [])
        swapData = self.safe_value(swapMarkets, 'data', [])
        data = self.array_concat(spotData, swapData)
        result = []
        for i in range(0, len(data)):
            market = data[i]
            marketId = self.safe_string(market, 'symbol')
            id = self.safe_string_upper(market, 'symbol')
            baseId, quoteId = id.split('_')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            minimumOrderSize = self.safe_string(market, 'minimumOrderSize')
            type = 'spot' if (minimumOrderSize is not None) else 'swap'
            swap = (type == 'swap')
            symbol = base + '/' + quote
            settleId = None
            settle = None
            if swap:
                settleId = quoteId
                settle = quote
                symbol = base + '/' + quote + ':' + settle
            linear = True if swap else None
            result.append({
                'id': marketId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': settle,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': settleId,
                'type': type,
                'spot': (type == 'spot'),
                'margin': False,
                'future': False,
                'swap': swap,
                'option': False,
                'active': self.safe_value(market, 'supportTrade'),
                'contract': swap,
                'linear': linear,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': self.parse_number(self.parse_precision(self.safe_string(market, 'volumePrecision'))),
                    'price': self.parse_number(self.parse_precision(self.safe_string(market, 'pricePrecision'))),
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': self.safe_number_n(market, ['minimumOrderSize', 'marketMiniAmount', 'limitMiniAmount']),
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': self.safe_number(market, 'minimumTradeVolume'),
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    async def fetch_currencies(self, params={}):
        """
        fetches all available currencies on an exchange
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: an associative dictionary of currencies
        """
        response = await self.publicSpotGetCommonCurrencys(params)
        #
        # {
        #     "code": "0",
        #     "data": [
        #        {
        #           "currency": "ETH",
        #           "maxWithdrawOneDay": "100.000000000000000000",
        #           "maxWithdrawSingle": "50.000000000000000000",
        #           "minWithdrawSingle": "0.005000000000000000",
        #           "supportDeposit": True,
        #           "supportTrade": True,
        #           "supportWithdraw": True,
        #           "withdrawFee": 0.01
        #        },
        #     ],
        #     "msg": "success",
        #     "status": 0
        # }
        #
        data = self.safe_value(response, 'data', [])
        result = {}
        for i in range(0, len(data)):
            currency = data[i]
            id = self.safe_string(currency, 'currency')
            code = self.safe_currency_code(id)
            name = self.safe_string(currency, 'name')
            withdrawEnabled = self.safe_value(currency, 'supportWithdraw')
            depositEnabled = self.safe_value(currency, 'supportDeposit')
            tradeEnabled = self.safe_value(currency, 'supportTrade')
            active = withdrawEnabled and depositEnabled and tradeEnabled
            result[code] = {
                'id': id,
                'code': code,
                'name': name,
                'deposit': depositEnabled,
                'withdraw': withdrawEnabled,
                'active': active,
                'fee': self.safe_number(currency, 'withdrawFee'),
                'precision': None,
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                    'withdraw': {'min': self.safe_number(currency, 'minWithdrawSingle'), 'max': self.safe_number(currency, 'maxWithdrawSingle')},
                },
                'info': currency,
            }
        return result

    async def fetch_time(self, params={}):
        """
        fetches the current integer timestamp in milliseconds from the exchange server
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns int: the current integer timestamp in milliseconds from the exchange server
        """
        response = await self.publicSpotGetCommonTimestamp(params)
        #
        # {
        #     "code": '0',
        #     "data": 1573542445411,
        #     "msg": "success",
        #     "status": 0
        # }
        #
        return self.safe_integer(response, 'data')

    async def fetch_status(self, params={}):
        """
        the latest known information on the availability of the exchange API
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: a `status structure <https://docs.ccxt.com/en/latest/manual.html#exchange-status-structure>`
        """
        response = await self.publicSpotGetCommonTimestamp(params)
        #
        #     {
        #         "code": '0',
        #         "data": 1573542445411,
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        statusRaw = self.safe_integer(response, 'status')
        codeRaw = self.safe_integer(response, 'code')
        updated = self.safe_integer(response, 'data')
        return {
            'status': 'ok' if (statusRaw == 0 and codeRaw == 0) else statusRaw,
            'updated': updated,
            'eta': None,
            'url': None,
            'info': response,
        }

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-1
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-kline
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int|None since: timestamp in ms of the earliest candle to fetch
        :param int|None limit: the maximum amount of candles to fetch
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [[int]]: A list of candles ordered as timestamp, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        swap = market['swap']
        request = {
            'symbol': market['id'],
        }
        method = 'publicSpotGetQKline'
        timeframes = self.safe_value(self.options, 'timeframes')
        if swap:
            swapTimeframes = self.safe_value(timeframes, 'swap')
            method = 'publicSwapGetMarketCandle'
            request['period'] = swapTimeframes[timeframe]
            if limit is not None:
                request['count'] = limit
        else:
            spotTimeframes = self.safe_value(timeframes, 'spot')
            request['symbol'] = market['id']
            request['period'] = spotTimeframes[timeframe]
        if limit is not None:
            limitRequest = 'count' if swap else 'size'
            request[limitRequest] = limit
        # their docs says that 'from/to' arguments are mandatory, however that's not True in reality
        if since is not None:
            sinceRequest = 'start' if swap else 'from'
            request[sinceRequest] = since
            # when 'since' [from] argument is set, then exchange also requires 'to' value to be set. So we have to set 'to' argument depending 'limit' amount(if limit was not provided, then exchange-default 500).
            if limit is None:
                limit = 500
            duration = self.parse_timeframe(timeframe)
            timerange = limit * duration * 1000
            toRequest = 'end' if swap else 'to'
            request[toRequest] = self.sum(request[sinceRequest], timerange)
        response = await getattr(self, method)(request)
        #
        # spot
        #
        #     {
        #         "code": "0",
        #         "data": [
        #             {
        #                 "close": "43414.68",
        #                 "high": "43446.47",
        #                 "low": "43403.05",
        #                 "open": "43406.05",
        #                 "quoteVolume": "61500.40099",
        #                 "symbol": "BTC_USDT",
        #                 "ts": "1646152440000",
        #                 "volume": 1.41627
        #             },
        #         ],
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        # swap
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "btc_usdt",
        #                 "amount": "10.26",
        #                 "volume": "172540.9433",
        #                 "open": "16817.29",
        #                 "close": "1670476440000",
        #                 "high": "16816.45",
        #                 "low": "16817.29",
        #                 "ts": 1670476440000
        #             },
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_ohlcvs(data, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        baseCurrencyVolume = 'amount' if market['swap'] else 'volume'
        return [
            self.safe_integer(ohlcv, 'ts'),
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            self.safe_float(ohlcv, baseCurrencyVolume),
        ]

    async def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-2
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-ticker-data
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        marketType, query = self.handle_market_type_and_params('fetchTicker', market, params)
        method = 'publicSwapGetMarketTickers' if (marketType == 'swap') else 'publicSpotGetQTickers'
        response = await getattr(self, method)(self.extend(request, query))
        #
        # spot
        #
        #     {
        #         "code": "0",
        #         "data": [
        #             {
        #                 "change": "6.52",
        #                 "close": "43573.470000",
        #                 "high": "44940.540000",
        #                 "low": "40799.840000",
        #                 "open": "40905.780000",
        #                 "quoteVolume": "225621691.5991",
        #                 "symbol": "BTC_USDT",
        #                 "ts": "1646156490781",
        #                 "volume": 5210.349
        #             }
        #         ],
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        # swap
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "btc_usdt",
        #                 "amount": "171035.45",
        #                 "volume": "2934757466.3859",
        #                 "open": "17111.43",
        #                 "close": "17135.74",
        #                 "high": "17225.99",
        #                 "low": "17105.77",
        #                 "lastPrice": "17135.74",
        #                 "lastAmount": "1.05",
        #                 "lastTime": 1670709364912,
        #                 "change": "0.14"
        #             }
        #         ]
        #     }
        #
        tickers = self.safe_value(response, 'data', [])
        ticker = self.safe_value(tickers, 0)
        return self.parse_ticker(ticker, market)

    async def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-2
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-ticker-data
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: an array of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        await self.load_markets()
        request = {}
        if symbols is not None:
            if not isinstance(symbols, list):
                raise BadRequest(self.id + ' fetchTickers() symbols argument should be an array')
        market = None
        if symbols is not None:
            marketIds = self.market_ids(symbols)
            symbol = self.safe_string(symbols, 0)
            market = self.market(symbol)
            if market['swap']:
                if isinstance(symbols, list):
                    symbolsLength = len(symbols)
                    if symbolsLength > 1:
                        raise BadRequest(self.id + ' fetchTickers() symbols argument cannot contain more than 1 symbol for swap markets')
                request['symbol'] = market['id']
            else:
                request['symbol'] = ','.join(marketIds)
        marketType, query = self.handle_market_type_and_params('fetchTickers', market, params)
        method = 'publicSwapGetMarketTickers' if (marketType == 'swap') else 'publicSpotGetQTickers'
        response = await getattr(self, method)(self.extend(request, query))
        #
        # spot
        #
        #     {
        #         "code": "0",
        #         "data": [
        #             {
        #                 "change": "6.52",
        #                 "close": "43573.470000",
        #                 "high": "44940.540000",
        #                 "low": "40799.840000",
        #                 "open": "40905.780000",
        #                 "quoteVolume": "225621691.5991",
        #                 "symbol": "BTC_USDT",
        #                 "ts": "1646156490781",
        #                 "volume": 5210.349
        #             }
        #         ],
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        # swap
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "btc_usdt",
        #                 "amount": "171035.45",
        #                 "volume": "2934757466.3859",
        #                 "open": "17111.43",
        #                 "close": "17135.74",
        #                 "high": "17225.99",
        #                 "low": "17105.77",
        #                 "lastPrice": "17135.74",
        #                 "lastAmount": "1.05",
        #                 "lastTime": 1670709364912,
        #                 "change": "0.14"
        #             }
        #         ]
        #     }
        #
        tickers = self.safe_value(response, 'data', [])
        return self.parse_tickers(tickers, symbols, query)

    def parse_ticker(self, ticker, market=None):
        #
        # spot
        #
        #    {
        #          "change":-0.46,
        #          "close":29664.46,
        #          "high":30784.99,
        #          "low":29455.36,
        #          "open":29803.38,
        #          "quoteVolume":714653752.6991,
        #          "symbol":"BTC_USDT",
        #          "ts":1652812048118,
        #          "volume":23684.9416
        #    }
        #
        # swap
        #
        #     {
        #         "symbol": "btc_usdt",
        #         "amount": "171035.45",
        #         "volume": "2934757466.3859",
        #         "open": "17111.43",
        #         "close": "17135.74",
        #         "high": "17225.99",
        #         "low": "17105.77",
        #         "lastPrice": "17135.74",
        #         "lastAmount": "1.05",
        #         "lastTime": 1670709364912,
        #         "change": "0.14"
        #     }
        #
        marketId = self.safe_string(ticker, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = self.safe_symbol(marketId, market)
        timestamp = self.safe_integer_2(ticker, 'ts', 'lastTime')
        baseCurrencyVolume = 'amount' if market['swap'] else 'volume'
        quoteCurrencyVolume = 'volume' if market['swap'] else 'quoteVolume'
        lastPrice = 'lastPrice' if market['swap'] else 'close'
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'high'),
            'low': self.safe_string(ticker, 'low'),
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': self.safe_string(ticker, 'open'),
            'close': self.safe_string(ticker, 'close'),
            'last': self.safe_string(ticker, lastPrice),
            'previousClose': None,
            'change': None,
            'percentage': self.safe_string(ticker, 'change'),  # 24h percentage change(close - open) / open * 100
            'average': None,
            'baseVolume': self.safe_string(ticker, baseCurrencyVolume),
            'quoteVolume': self.safe_string(ticker, quoteCurrencyVolume),
            'info': ticker,
        }, market)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-4
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-deep-data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        swap = market['swap']
        request = {
            'symbol': market['id'],
        }
        method = 'publicSpotGetQDepth'
        if swap:
            method = 'publicSwapGetMarketDepth'
        else:
            if limit is not None:
                request['depth'] = min(limit, 50)
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot
        #
        #     {
        #         "code": "0",
        #         "data": {
        #             "ask": [
        #                 ["43820.07","0.86947"],
        #                 ["43820.25","0.07503"],
        #             ],
        #             "bid": [
        #                 ["43815.94","0.43743"],
        #                 ["43815.72","0.08901"],
        #             ],
        #             "symbol": "BTC_USDT",
        #             "timestamp": 1646161595841
        #         },
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        # swap
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": {
        #             "bid": [
        #                 ["16803.170000","4.96"],
        #                 ["16803.140000","11.07"],
        #             ],
        #             "ask": [
        #                 ["16803.690000","9.2"],
        #                 ["16804.180000","9.43"],
        #             ]
        #         }
        #     }
        #
        data = self.safe_value(response, 'data')
        timestamp = self.safe_integer(data, 'timestamp')
        return self.parse_order_book(data, market['symbol'], timestamp, 'bid', 'ask')

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        """
        get the list of most recent trades for a particular symbol
        see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-5
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-trades-history
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        swap = market['swap']
        request = {
            'symbol': market['id'],
        }
        method = 'publicSpotGetQDeals'
        if swap:
            method = 'publicSwapGetMarketDeals'
        else:
            if limit is not None:
                request['size'] = min(limit, 50)
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot
        #
        #     {
        #         "code": "0",
        #         "data": [
        #             {
        #                 "direction": "S",
        #                 "price": "43930.63",
        #                 "symbol": "BTC_USDT",
        #                 "ts": "1646224171992",
        #                 "volume": 0.030653
        #             },  # first item is most recent
        #         ],
        #         "msg": "success",
        #         "status": 0
        #     }
        #
        # swap
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "btc_usdt",
        #                 "amount": "0.06",
        #                 "price": "17134.66",
        #                 "side": "sell",
        #                 "time": 1670651851646
        #             },
        #         ]
        #     }
        #
        trades = self.safe_value(response, 'data')
        return self.parse_trades(trades, market, since, limit)

    def parse_trade(self, trade, market=None):
        timestamp = self.safe_integer_2(trade, 'ts', 'time')
        marketId = self.safe_string(trade, 'symbol')
        market = self.safe_market(marketId, market)
        side = self.parse_trade_side(self.safe_string_2(trade, 'direction', 'side'))
        amount = self.safe_number_2(trade, 'volume', 'amount')
        price = self.safe_number(trade, 'price')
        type = None
        id = self.safe_string(trade, 'tid')
        if id is None:
            id = self.synthetic_trade_id(market, timestamp, side, amount, price, type)
        return self.safe_trade({
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'order': None,
            'type': type,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': None,
            'info': trade,
        }, market)

    def parse_trade_side(self, side):
        sides = {
            'B': 'buy',
            'S': 'sell',
            'buy': 'buy',
            'sell': 'sell',
        }
        return self.safe_string(sides, side, side)

    def synthetic_trade_id(self, market=None, timestamp=None, side=None, amount=None, price=None, orderType=None, takerOrMaker=None):
        # TODO: can be unified method? self approach is being used by multiple exchanges(mexc, woo-coinsbit, dydx, ...)
        id = ''
        if timestamp is not None:
            id = self.number_to_string(timestamp) + '-' + self.safe_string(market, 'id', '_')
            if side is not None:
                id += '-' + side
            if orderType is not None:
                id += '-' + orderType
            if takerOrMaker is not None:
                id += '-' + takerOrMaker
            if amount is not None:
                id += '-' + self.number_to_string(amount)
            if price is not None:
                id += '-' + self.number_to_string(price)
        return id

    async def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        await self.load_markets()
        query = self.omit(params, 'type')
        response = await self.privateSpotGetUAccountBalance(query)
        #
        # {
        #     "code": "0",
        #     "data": {
        #       "WALLET": [
        #         {
        #           "available": "0.221212121000000000",
        #           "currency": "PHX",
        #           "frozen": "0E-18",
        #           "total": 0.221212121
        #         },
        #         {
        #           "available": "44.959577229600000000",
        #           "currency": "USDT",
        #           "frozen": "0E-18",
        #           "total": 44.9595772296
        #         }
        #       ]
        #     },
        #     "msg": "success",
        #     "status": 0
        # }
        #
        balances = self.safe_value(response, 'data')
        wallets = self.safe_value(balances, 'WALLET', [])
        result = {'info': wallets}
        for i in range(0, len(wallets)):
            wallet = wallets[i]
            currencyId = wallet['currency']
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_number(wallet, 'available')
            account['used'] = self.safe_number(wallet, 'frozen')
            account['total'] = self.safe_number(wallet, 'total')
            result[code] = account
        return self.safe_balance(result)

    async def fetch_deposit_address(self, code, params={}):
        """
        fetch the deposit address for a currency associated with self account
        :param str code: unified currency code
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: an `address structure <https://docs.ccxt.com/en/latest/manual.html#address-structure>`
        """
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = await self.privateSpotGetUWalletAddress(self.extend(request, params))
        # NOTE: You can only retrieve addresses of already generated wallets - so should already have generated that COIN deposit address in UI. Otherwise, it seems from API you can't create/obtain addresses for those coins.
        #
        # {
        #     "code": "0",
        #     "data": [
        #       {
        #         "currency": "BTC",
        #         "address": "1m4k2yUKTSrX6SM9FGgvwMyxQbYtRVi2N",
        #         "memo": ""
        #       }
        #     ],
        #     "msg": "success",
        #     "status": 0
        # }
        #
        data = self.safe_value(response, 'data', {})
        return self.parse_deposit_address(data, currency)

    def parse_deposit_address(self, data, currency=None):
        depositObject = self.safe_value(data, 0)
        address = self.safe_string(depositObject, 'address')
        tag = self.safe_string(depositObject, 'memo')
        currencyId = self.safe_string(depositObject, 'currency')
        currency = self.safe_currency(currencyId, currency)
        return {
            'currency': currency['code'],
            'address': address,
            'tag': tag,
            'network': None,
            'info': data,
        }

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        """
        fetch all deposits made to an account
        :param str code: unified currency code
        :param int|None since: the earliest time in ms to fetch deposits for
        :param int|None limit: the maximum number of deposits structures to retrieve
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        if code is None:
            raise ArgumentsRequired(self.id + ' fetchDeposits() requires code argument')
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        if since is not None:
            request['startTime'] = since
            endTime = self.milliseconds()
            request['endTime'] = endTime
        if limit is not None:
            request['Size'] = limit  # Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        response = await self.privateSpotGetUWalletDepositRecord(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": {
        #       "data": [
        #         {
        #           "createTime": "1622274255000",
        #           "currency": "BNB",
        #           "fromAddress": "bnb10af52w77pkehgxhnwgeca50q2t2354q4xexa5y",
        #           "hash": "97B982F497782C2777C0F6AD16CEAAC65A93A364B684A23A71CFBB8C010DEEA6",
        #           "id": "2021052923441510234383337",
        #           "status": "0",
        #           "toAddress": "bnb13w64gkc42c0l45m2p5me4qn35z0a3ej9ldks3j_82784659",
        #           "volume": 0.073
        #         }
        #       ],
        #       "total": 1
        #     },
        #     "msg": "success",
        #     "status": 0
        # }
        #
        data = self.safe_value(response, 'data', {})
        dataInner = self.safe_value(data, 'data', [])
        for i in range(0, len(dataInner)):
            dataInner[i]['transactType'] = 'deposit'
        return self.parse_transactions(dataInner, currency, since, limit, params)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        """
        fetch all withdrawals made from an account
        :param str code: unified currency code
        :param int|None since: the earliest time in ms to fetch withdrawals for
        :param int|None limit: the maximum number of withdrawals structures to retrieve
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        if code is None:
            raise ArgumentsRequired(self.id + ' fetchWithdrawals() requires code argument')
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        if since is not None:
            request['startTime'] = since
            endTime = self.milliseconds()
            request['endTime'] = endTime
        if limit is not None:
            request['Size'] = limit  # Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        response = await self.privateSpotGetUWalletWithdrawRecord(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": {
        #       "data": [
        #         {
        #           ...
        #         }
        #       ],
        #       "total": 1
        #     },
        #     "msg": "success",
        #     "status": 0
        # }
        #
        data = self.safe_value(response, 'data', {})
        dataInner = self.safe_value(data, 'data', [])
        for i in range(0, len(dataInner)):
            dataInner[i]['transactType'] = 'withdrawal'
        return self.parse_transactions(dataInner, currency, since, limit, params)

    def parse_transaction(self, transaction, currency=None):
        #
        # fetchDeposits
        #
        # {
        #   "createTime": "1622274255000",
        #   "currency": "BNB",
        #   "fromAddress": "bnb10af52w77pkehgxhnwgeca50q2t2354q4xexa5y",
        #   "hash": "97B982F497782C2777C0F6AD16CEAAC65A93A364B684A23A71CFBB8C010DEEA6",
        #   "id": "2021052923441510234383337",
        #   "status": "0",
        #   "toAddress": "bnb13w64gkc42c0l45m2p5me4qn35z0a3ej9ldks3j_82784659",
        #   "volume": 0.073
        # }
        #
        id = self.safe_string(transaction, 'id')
        amount = self.safe_number(transaction, 'volume')
        addressTo = self.safe_value(transaction, 'toAddress', {})
        addressFrom = self.safe_string(transaction, 'fromAddress')
        txid = self.safe_string(transaction, 'hash')
        type = self.safe_string(transaction, 'transactType')
        timestamp = self.safe_integer(transaction, 'createTime')
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId, currency)
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        return {
            'id': id,
            'currency': code,
            'amount': amount,
            'network': None,
            'address': addressTo,
            'addressTo': addressTo,
            'addressFrom': addressFrom,
            'tag': None,
            'tagTo': None,
            'tagFrom': None,
            'status': status,
            'type': type,
            'updated': None,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': {
                'currency': code,
                'cost': None,
            },
            'info': transaction,
        }

    def parse_transaction_status(self, status):
        statuses = {
            '-1': 'failed',
            '0': 'ok',
            '3': 'pending',
            '5': 'pending',
        }
        return self.safe_string(statuses, status, status)

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
        create a trade order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        direction = 'BID' if (side == 'buy') else 'ASK'
        request = {
            'symbol': market['id'],
            'type': type.upper(),
            'volume': self.amount_to_precision(symbol, amount),
            'direction': direction,
        }
        if (type != 'market') and (price is not None):
            request['price'] = self.price_to_precision(symbol, price)
        response = await self.privateSpotPostUOrderCreate(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": "2022030302410146630023187",
        #     "msg": "Create Order Successfully",
        #     "status": 0
        # }
        #
        return self.parse_order(response, market)

    async def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol) if (symbol is not None) else None
        request = {
            'orderId': id,
        }
        response = await self.privateSpotPostUOrderCancel(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": "2022030303032700030025325",
        #     "status": 0
        # }
        #
        return self.parse_order(response, market)

    async def cancel_orders(self, ids, symbol=None, params={}):
        """
        cancel multiple orders
        :param [str] ids: order ids
        :param str|None symbol: unified market symbol, default is None
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: an list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        if not isinstance(ids, list):
            raise ArgumentsRequired(self.id + ' cancelOrders() ids argument should be an array')
        await self.load_markets()
        request = {
            'orders': self.json(ids),
        }
        response = await self.privateSpotPostUOrderBatchCancel(self.extend(request, params))
        # {
        #     "code": 0,
        #     "msg": "success",
        #     "data": {
        #        "success": 2,
        #        "fail": 0,
        #        "results": ["2019062312313131231"," 2019063123131312313"]
        #     }
        # }
        data = self.safe_value(response, 'data')
        results = self.safe_value(data, 'results')
        market = self.market(symbol) if (symbol is not None) else None
        return self.parse_orders(results, market, None, None, params)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all unfilled currently open orders
        :param str symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch open orders for
        :param int|None limit: the maximum number of  open orders structures to retrieve
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOpenOrders() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['size'] = limit  # Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        response = await self.privateSpotGetUOrderOpenOrders(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": {
        #       "data": [
        #         {
        #           "createdTime": "1646248301418",
        #           "dealVolume": "0E-18",
        #           "direction": "BID",
        #           "frozenVolumeByOrder": "2.421300000000000000",
        #           "id": "2022030303114141830007699",
        #           "price": "0.150000000000000000",
        #           "source": "WALLET",
        #           "status": "0",
        #           "symbol": "BKK_USDT",
        #           "totalVolume": "16.142000000000000000",
        #           "type": "LIMIT"
        #         }
        #       ],
        #       "pageRequest": {
        #         "asc": False,
        #         "orderBy": "id",
        #         "page": "1",
        #         "size": 10
        #       },
        #       "total": 1
        #     },
        #     "msg": "success",
        #     "status": 0
        # }
        #
        result = self.safe_value(response, 'data')
        innerData = self.safe_value(result, 'data')
        return self.parse_orders(innerData, market, since, limit, params)

    async def fetch_open_order(self, id, symbol=None, params={}):
        """
        fetch an open order by it's id
        :param str id: order id
        :param str|None symbol: unified market symbol, default is None
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        request = {
            'orderId': id,
        }
        response = await self.privateSpotGetUOrderOpenOrderDetail(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": {
        #       "createdTime": "1646248301418",
        #       "dealAvgPrice": "0",
        #       "dealVolume": "0E-18",
        #       "direction": "BID",
        #       "frozenVolumeByOrder": "2.421300000000000000",
        #       "id": "2022030303114141830002452",
        #       "price": "0.150000000000000000",
        #       "source": "WALLET",
        #       "status": "0",
        #       "symbol": "BKK_USDT",
        #       "totalVolume": "16.142000000000000000",
        #       "type": "LIMIT",
        #       "updateTime": 1646248301418
        #     },
        #     "msg": "success",
        #     "status": 0
        # }
        #
        data = self.safe_value(response, 'data')
        market = self.market(symbol) if (symbol is not None) else None
        return self.parse_order(data, market)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple closed orders made by the user
        :param str symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchClosedOrders() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['size'] = limit  # Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        if since is not None:
            request['startTime'] = since
        response = await self.privateSpotGetUOrderHistoryOrders(self.extend(request, params))
        #
        # {
        #     "code": "0",
        #     "data": {
        #       "data": [
        #         {
        #           "createdTime": "1646247807000",
        #           "dealAvgPrice": "0",
        #           "dealVolume": "0",
        #           "direction": "BID",
        #           "frozenVolumeByOrder": "1.65",
        #           "id": "2022030303032700030025943",
        #           "price": "0.15",
        #           "source": "WALLET",
        #           "status": "2",
        #           "symbol": "BKK_USDT",
        #           "totalVolume": "11",
        #           "type": "LIMIT",
        #           "updateTime": 1646247852558
        #         },
        #       ],
        #       "pageRequest": {
        #         "asc": False,
        #         "orderBy": "id",
        #         "page": "1",
        #         "size": 10
        #       },
        #       "total": 6
        #     },
        #     "msg": "success",
        #     "status": 0
        # }
        #
        result = self.safe_value(response, 'data')
        innerData = self.safe_value(result, 'data')
        return self.parse_orders(innerData, market, since, limit, params)

    def parse_order(self, order, market=None):
        #
        # fetchOpenOrders
        #
        #  {
        #       "createdTime": "1646248301418",
        #       "dealVolume": "0E-18",
        #       "direction": "BID",
        #       "frozenVolumeByOrder": "2.421300000000000000",
        #       "id": "2022030303114141830007699",
        #       "price": "0.150000000000000000",
        #       "source": "WALLET",
        #       "status": "0",
        #       "symbol": "BKK_USDT",
        #       "totalVolume": "16.142000000000000000",
        #       "type": "LIMIT"
        #       "stopPrice":  "0.14",            # present only for 'stop' order types
        #       "operator":  ">="                # present only for 'stop' order types
        #       "dealAvgPrice": "0",             # only present in 'fetchOrder' & 'fetchClosedOrders'
        #       "updateTime": 1646248301418      # only present in 'fetchOrder' & 'fetchClosedOrders'
        #  }
        #
        timestamp = self.safe_integer(order, 'createdTime')
        updateTime = self.safe_integer(order, 'updateTime')
        filled = self.safe_string(order, 'dealVolume')
        side = self.parse_order_side(self.safe_string(order, 'direction'))
        id = self.safe_string_2(order, 'id', 'data')
        price = self.safe_string(order, 'price')
        rawStatus = self.safe_string(order, 'status')
        rawType = self.safe_string(order, 'type')
        type = self.parse_order_type(rawType)
        postOnly = False
        if rawType == 'LIMIT_MAKER':
            postOnly = True
        status = None
        if timestamp is not None:
            # cancelOrder handling
            status = self.parse_order_status(rawStatus)
        marketId = self.safe_string(order, 'symbol')
        market = self.safe_market(marketId, market)
        amount = self.safe_string(order, 'totalVolume')
        stopPrice = self.safe_number(order, 'stopPrice')
        average = self.safe_string(order, 'dealAvgPrice')
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': updateTime,
            'status': status,
            'symbol': market['symbol'],
            'type': type,
            'timeInForce': None,
            'postOnly': postOnly,
            'side': side,
            'price': price,
            'stopPrice': stopPrice,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
            'info': order,
        }, market)

    def parse_order_side(self, side):
        sides = {
            'BID': 'buy',
            'ASK': 'sell',
        }
        return self.safe_string(sides, side, side)

    def parse_order_status(self, status):
        statuses = {
            '0': 'open',
            '1': 'closed',
            '2': 'canceled',
            '3': 'open',
        }
        return self.safe_string(statuses, status, status)

    def parse_order_type(self, status):
        statuses = {
            'MARKET': 'market',
            'LIMIT': 'limit',
            'LIMIT_MAKER': 'limit',
            'STOP_LIMIT': 'limit',
        }
        return self.safe_string(statuses, status, status)

    async def fetch_transaction_fees(self, codes=None, params={}):
        """
        *DEPRECATED* please use fetchDepositWithdrawFees instead
        see https://bkexapi.github.io/docs/api_en.htm?shell#basicInformation-2
        :param [str]|None codes: list of unified currency codes
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: a list of `fee structures <https://docs.ccxt.com/en/latest/manual.html#fee-structure>`
        """
        await self.load_markets()
        response = await self.publicSpotGetCommonCurrencys(params)
        #
        #      {
        #          "msg": "success",
        #          "code": "0",
        #          "data": [
        #            {
        #              "currency": "ETH",
        #              "maxWithdrawOneDay": 2000,
        #              "maxWithdrawSingle": 2000,
        #              "minWithdrawSingle": 0.1,
        #              "supportDeposit": True,
        #              "supportTrade": True,
        #              "supportWithdraw": True,
        #              "withdrawFee": 0.008
        #            },
        #            {
        #              "currency": "BTC",
        #              "maxWithdrawOneDay": 100,
        #              "maxWithdrawSingle": 100,
        #              "minWithdrawSingle": 0.01,
        #              "supportDeposit": True,
        #              "supportTrade": True,
        #              "supportWithdraw": True,
        #              "withdrawFee": 0.008
        #            }
        #          ]
        #      }
        #
        return self.parse_transaction_fees(response, codes)

    def parse_transaction_fees(self, response, codes=None):
        data = self.safe_value(response, 'data')
        result = {}
        for i in range(0, len(data)):
            entry = data[i]
            currencyId = self.safe_string(entry, 'currency')
            currency = self.safe_currency(currencyId)
            code = self.safe_string(currency, 'code')
            if (codes is None) or (self.in_array(code, codes)):
                result[code] = {
                    'withdraw': self.parse_transaction_fee(entry),
                    'deposit': None,
                    'info': entry,
                }
        return result

    def parse_transaction_fee(self, transaction, currency=None):
        #
        #      {
        #          "currency": "ETH",
        #          "maxWithdrawOneDay": 2000,
        #          "maxWithdrawSingle": 2000,
        #          "minWithdrawSingle": 0.1,
        #          "supportDeposit": True,
        #          "supportTrade": True,
        #          "supportWithdraw": True,
        #          "withdrawFee": 0.008
        #      }
        #
        return self.safe_number(transaction, 'withdrawFee')

    async def fetch_deposit_withdraw_fees(self, codes=None, params={}):
        """
        fetch deposit and withdraw fees
        see https://bkexapi.github.io/docs/api_en.htm?shell#basicInformation-2
        :param [str]|None codes: list of unified currency codes
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: a list of `fee structures <https://docs.ccxt.com/en/latest/manual.html#fee-structure>`
        """
        await self.load_markets()
        response = await self.publicSpotGetCommonCurrencys(params)
        #
        #    {
        #        "msg": "success",
        #        "code": "0",
        #        "data": [
        #            {
        #                "currency": "ETH",
        #                "maxWithdrawOneDay": 2000,
        #                "maxWithdrawSingle": 2000,
        #                "minWithdrawSingle": 0.1,
        #                "supportDeposit": True,
        #                "supportTrade": True,
        #                "supportWithdraw": True,
        #                "withdrawFee": 0.008
        #            },
        #            {
        #                "currency": "BTC",
        #                "maxWithdrawOneDay": 100,
        #                "maxWithdrawSingle": 100,
        #                "minWithdrawSingle": 0.01,
        #                "supportDeposit": True,
        #                "supportTrade": True,
        #                "supportWithdraw": True,
        #                "withdrawFee": 0.008
        #            }
        #        ]
        #    }
        #
        data = self.safe_value(response, 'data')
        return self.parse_deposit_withdraw_fees(data, codes, 'currency')

    def parse_deposit_withdraw_fee(self, fee, currency=None):
        #
        #      {
        #          "currency": "ETH",
        #          "maxWithdrawOneDay": 2000,
        #          "maxWithdrawSingle": 2000,
        #          "minWithdrawSingle": 0.1,
        #          "supportDeposit": True,
        #          "supportTrade": True,
        #          "supportWithdraw": True,
        #          "withdrawFee": 0.008
        #      }
        #
        result = self.deposit_withdraw_fee(fee)
        result['withdraw']['fee'] = self.safe_number(fee, 'withdrawFee')
        return result

    async def fetch_funding_rate_history(self, symbol=None, since=None, limit=None, params={}):
        """
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-fundingRate
        fetches historical funding rate prices
        :param str|None symbol: unified symbol of the market to fetch the funding rate history for
        :param int|None since: timestamp in ms of the earliest funding rate to fetch
        :param int|None limit: the maximum amount of `funding rate structures <https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure>` to fetch
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns [dict]: a list of `funding rate structures <https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchFundingRateHistory() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = await self.publicSwapGetMarketFundingRate(self.extend(request, params))
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "btc_usdt",
        #                 "rate": "-0.00008654",
        #                 "time": 1670658302128
        #             },
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        rates = []
        for i in range(0, len(data)):
            entry = data[i]
            marketId = self.safe_string(entry, 'symbol')
            symbol = self.safe_symbol(marketId)
            timestamp = self.safe_integer(entry, 'time')
            rates.append({
                'info': entry,
                'symbol': symbol,
                'fundingRate': self.safe_number(entry, 'rate'),
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
            })
        sorted = self.sort_by(rates, 'timestamp')
        return self.filter_by_symbol_since_limit(sorted, market['symbol'], since, limit)

    async def fetch_market_leverage_tiers(self, symbol, params={}):
        """
        see https://bkexapi.github.io/docs/api_en.htm?shell#contract-riskLimit
        retrieve information on the maximum leverage, for different trade sizes for a single market
        :param str symbol: unified market symbol
        :param dict params: extra parameters specific to the bkex api endpoint
        :returns dict: a `leverage tiers structure <https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        if not market['swap']:
            raise BadRequest(self.id + ' fetchMarketLeverageTiers() supports swap markets only')
        request = {
            'symbol': market['id'],
        }
        response = await self.publicSwapGetMarketRiskLimit(self.extend(request, params))
        #
        #     {
        #         "code": 0,
        #         "msg": "success",
        #         "data": [
        #             {
        #                 "symbol": "btc_usdt",
        #                 "minValue": "0",
        #                 "maxValue": "500000",
        #                 "maxLeverage": 100,
        #                 "maintenanceMarginRate": "0.005"
        #             },
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_market_leverage_tiers(data, market)

    def parse_market_leverage_tiers(self, info, market):
        #
        #     [
        #         {
        #             "symbol": "btc_usdt",
        #             "minValue": "0",
        #             "maxValue": "500000",
        #             "maxLeverage": 100,
        #             "maintenanceMarginRate": "0.005"
        #         },
        #     ]
        #
        tiers = []
        for i in range(0, len(info)):
            tier = info[i]
            marketId = self.safe_string(info, 'symbol')
            market = self.safe_market(marketId, market)
            tiers.append({
                'tier': self.sum(i, 1),
                'currency': market['settle'],
                'minNotional': self.safe_number(tier, 'minValue'),
                'maxNotional': self.safe_number(tier, 'maxValue'),
                'maintenanceMarginRate': self.safe_number(tier, 'maintenanceMarginRate'),
                'maxLeverage': self.safe_number(tier, 'maxLeverage'),
                'info': tier,
            })
        return tiers

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        signed = api[0] == 'private'
        endpoint = api[1]
        pathPart = self.version if (endpoint == 'spot') else 'fapi/' + self.version
        url = self.urls['api'][endpoint] + '/' + pathPart + self.implode_params(path, params)
        params = self.omit(params, self.extract_params(path))
        paramsSortedEncoded = ''
        if params:
            paramsSortedEncoded = self.rawencode(self.keysort(params))
            if method == 'GET':
                url += '?' + paramsSortedEncoded
        if signed:
            self.check_required_credentials()
            signature = self.hmac(self.encode(paramsSortedEncoded), self.encode(self.secret), hashlib.sha256)
            headers = {
                'Cache-Control': 'no-cache',
                'Content-type': 'application/x-www-form-urlencoded',
                'X_ACCESS_KEY': self.apiKey,
                'X_SIGNATURE': signature,
            }
            if method != 'GET':
                body = paramsSortedEncoded
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        #
        # success
        #
        #   {
        #      "code": "0",
        #      "msg": "success",
        #      "status": 0,
        #      "data": [...],
        #   }
        #
        #
        # action error
        #
        #   {
        #     "code":1005,
        #     "msg":"BKK:Not Enough balance",
        #     "status":0
        #   }
        #
        #
        # HTTP error
        #
        #   {
        #      "timestamp": "1646041085490",
        #      "status": "403",
        #      "error": "Forbidden",
        #      "message": "",
        #      "path": "/whatever/incorrect/path"
        #   }
        #
        message = self.safe_value(response, 'msg')
        if message == 'success':
            return
        responseCode = self.safe_string(response, 'code')
        if responseCode != '0':
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], responseCode, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], body, feedback)
            raise ExchangeError(feedback)
