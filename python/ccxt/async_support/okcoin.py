# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import CancelPending
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import RequestTimeout
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class okcoin(Exchange):

    def describe(self):
        return self.deep_extend(super(okcoin, self).describe(), {
            'id': 'okcoin',
            'name': 'OKCoin',
            'countries': ['CN', 'US'],
            'version': 'v3',
            # cheapest endpoint is 100 requests per 2 seconds
            # 50 requests per second => 1000 / 50 = 20ms
            'rateLimit': 20,
            'pro': True,
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': None,
                'future': True,
                'option': None,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,  # see below
                'fetchDepositAddress': True,
                'fetchDeposits': True,
                'fetchLedger': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': None,
                'fetchOrderTrades': True,
                'fetchPosition': True,
                'fetchPositions': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTransactions': None,
                'fetchWithdrawals': True,
                'transfer': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '60',
                '3m': '180',
                '5m': '300',
                '15m': '900',
                '30m': '1800',
                '1h': '3600',
                '2h': '7200',
                '4h': '14400',
                '6h': '21600',
                '12h': '43200',
                '1d': '86400',
                '1w': '604800',
                '1M': '2678400',
                '3M': '8035200',
                '6M': '16070400',
                '1y': '31536000',
            },
            'hostname': 'okcoin.com',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg',
                'api': {
                    'rest': 'https://www.{hostname}',
                },
                'www': 'https://www.okcoin.com',
                'doc': 'https://www.okcoin.com/docs/en/',
                'fees': 'https://www.okcoin.com/coin-fees',
                'referral': 'https://www.okcoin.com/account/register?flag=activity&channelId=600001513',
                'test': {
                    'rest': 'https://testnet.okex.com',
                },
            },
            'api': {
                'general': {
                    'get': {
                        'time': 8.3334,
                    },
                },
                'account': {
                    'get': {
                        'wallet': 8.3334,
                        'sub-account': 1000,
                        'asset-valuation': 1000,
                        'wallet/{currency}': 8.3334,
                        'withdrawal/history': 8.3334,
                        'withdrawal/history/{currency}': 8.3334,
                        'ledger': 5,
                        'deposit/address': 8.3334,
                        'deposit/history': 8.3334,
                        'deposit/history/{currency}': 8.3334,
                        'currencies': 8.3334,
                        'withdrawal/fee': 8.3334,
                        'deposit-lightning': 50,
                        'withdrawal-lightning': 50,
                        'fiat/deposit/detail': 5,
                        'fiat/deposit/details': 8.3334,
                        'fiat/withdraw/detail': 5,
                        'fiat/withdraw/details': 8.3334,
                        'fiat/channel': 8.3334,
                    },
                    'post': {
                        'transfer': 100,  # 1 request per 2 seconds(per currency)
                        'withdrawal': 8.3334,
                        'fiat/cancel_deposit': 1,
                        'fiat/deposit': 8.3334,
                        'fiat/withdraw': 8.3334,
                        'fiat/cancel_withdrawal': 1,
                    },
                },
                # TODO fix signing issue in sign()
                # all other endpoints of the format
                # api/account/v3/wallet
                # otc endpoints actually of the format: (exchanged places)
                # api/v3/otc/rfq/instruments
                'otc': {
                    'get': {
                        'rfq/instruments': 50,  # represents: GET api/v3/otc/rfq/instruments
                        'rfq/trade': 50,
                        'rfq/history': 50,
                    },
                    'post': {
                        'rfq/quote': 50,
                        'rfq/trade': 50,
                    },
                },
                # TODO fix signing issue as above
                'users': {
                    'get': {
                        'subaccount-info': 20,
                        'account-info': 20,
                        'subaccount/apikey': 20,
                    },
                    'post': {
                        'create-subaccount': 5,  # represents: POST api/v3/users/create-subaccount
                        'delete-subaccount': 5,
                        'subaccount/apikey': 50,
                        'subacount/delete-apikey': 20,
                        'subacount/modify-apikey': 20,
                    },
                },
                'earning': {
                    'get': {
                        'offers': 5,
                        'orders': 5,
                        'positions': 8.3334,
                    },
                    'post': {
                        'purchase': 5,
                        'redeem': 5,
                        'cancel': 5,
                    },
                },
                'spot': {
                    'get': {
                        'accounts': 5,
                        'accounts/{currency}': 5,
                        'accounts/{currency}/ledger': 5,
                        'orders': 10,
                        'orders_pending': 5,
                        'orders/{order_id}': 5,
                        'orders/{client_oid}': 5,
                        'trade_fee': 5,
                        'fills': 10,
                        'algo': 5,
                        # public
                        'instruments': 5,
                        'instruments/{instrument_id}/book': 5,
                        'instruments/ticker': 5,
                        'instruments/{instrument_id}/ticker': 5,
                        'instruments/{instrument_id}/trades': 5,
                        'instruments/{instrument_id}/candles': 5,
                    },
                    'post': {
                        'order_algo': 2.5,
                        'orders': 1,
                        'batch_orders': 2,
                        'cancel_orders/{order_id}': 1,
                        'cancel_orders/{client_oid}': 1,
                        'cancel_batch_algos': 5,
                        'cancel_batch_orders': 5,
                        'amend_order/{instrument_id}': 2.5,
                        'amend_batch_orders': 5,
                    },
                },
                'margin': {
                    # Margin trading closed down on February 21, 2022
                    'get': {
                        'accounts': 5,
                        'accounts/{instrument_id}': 5,
                        'accounts/{instrument_id}/ledger': 5,
                        'accounts/availability': 5,
                        'accounts/{instrument_id}/availability': 5,
                        'accounts/borrowed': 5,
                        'accounts/{instrument_id}/borrowed': 5,
                        'orders': 10,
                        'accounts/{instrument_id}/leverage': 1,
                        'orders/{order_id}': 5,
                        'orders/{client_oid}': 5,
                        'orders_pending': 5,
                        'fills': 10,
                        # public
                        'instruments/{instrument_id}/mark_price': 5,
                    },
                    'post': {
                        'accounts/borrow': 1,
                        'accounts/repayment': 1,
                        'orders': 1,
                        'batch_orders': 2,
                        'cancel_orders': 1,
                        'cancel_orders/{order_id}': 1,
                        'cancel_orders/{client_oid}': 1,
                        'cancel_batch_orders': 2,
                        'amend_order/{instrument_id}': 2.5,
                        'amend_batch_orders': 5,
                        'accounts/{instrument_id}/leverage': 1,
                    },
                },
                'system': {
                    'get': {
                        'status': 250,
                    },
                },
                'market': {
                    'get': {
                        'oracle': 250,
                    },
                },
                'futures': {
                    'get': [
                        'position',
                        '{instrument_id}/position',
                        'accounts',
                        'accounts/{underlying}',
                        'accounts/{underlying}/leverage',
                        'accounts/{underlying}/ledger',
                        'order_algo/{instrument_id}',
                        'orders/{instrument_id}',
                        'orders/{instrument_id}/{order_id}',
                        'orders/{instrument_id}/{client_oid}',
                        'fills',
                        'trade_fee',
                        'accounts/{instrument_id}/holds',
                        'order_algo/{instrument_id}',
                        # public
                        'instruments',
                        'instruments/{instrument_id}/book',
                        'instruments/ticker',
                        'instruments/{instrument_id}/ticker',
                        'instruments/{instrument_id}/trades',
                        'instruments/{instrument_id}/candles',
                        'instruments/{instrument_id}/history/candles',
                        'instruments/{instrument_id}/index',
                        'rate',
                        'instruments/{instrument_id}/estimated_price',
                        'instruments/{instrument_id}/open_interest',
                        'instruments/{instrument_id}/price_limit',
                        'instruments/{instrument_id}/mark_price',
                        'instruments/{instrument_id}/liquidation',
                    ],
                    'post': [
                        'accounts/{underlying}/leverage',
                        'order',
                        'amend_order/{instrument_id}',
                        'orders',
                        'cancel_order/{instrument_id}/{order_id}',
                        'cancel_order/{instrument_id}/{client_oid}',
                        'cancel_batch_orders/{instrument_id}',
                        'accounts/margin_mode',
                        'close_position',
                        'cancel_all',
                        'order_algo',
                        'cancel_algos',
                    ],
                },
                'swap': {
                    'get': [
                        'position',
                        '{instrument_id}/position',
                        'accounts',
                        '{instrument_id}/accounts',
                        'accounts/{instrument_id}/settings',
                        'accounts/{instrument_id}/ledger',
                        'orders/{instrument_id}',
                        'orders/{instrument_id}/{order_id}',
                        'orders/{instrument_id}/{client_oid}',
                        'fills',
                        'accounts/{instrument_id}/holds',
                        'trade_fee',
                        'order_algo/{instrument_id}',
                        # public
                        'instruments',
                        'instruments/{instrument_id}/depth',
                        'instruments/ticker',
                        'instruments/{instrument_id}/ticker',
                        'instruments/{instrument_id}/trades',
                        'instruments/{instrument_id}/candles',
                        'instruments/{instrument_id}/history/candles',
                        'instruments/{instrument_id}/index',
                        'rate',
                        'instruments/{instrument_id}/open_interest',
                        'instruments/{instrument_id}/price_limit',
                        'instruments/{instrument_id}/liquidation',
                        'instruments/{instrument_id}/funding_time',
                        'instruments/{instrument_id}/mark_price',
                        'instruments/{instrument_id}/historical_funding_rate',
                    ],
                    'post': [
                        'accounts/{instrument_id}/leverage',
                        'order',
                        'amend_order/{instrument_id}',
                        'orders',
                        'cancel_order/{instrument_id}/{order_id}',
                        'cancel_order/{instrument_id}/{client_oid}',
                        'cancel_batch_orders/{instrument_id}',
                        'order_algo',
                        'cancel_algos',
                        'close_position',
                        'cancel_all',
                        'order_algo',
                        'cancel_algos',
                    ],
                },
                'option': {
                    'get': [
                        'accounts',
                        'position',
                        '{underlying}/position',
                        'accounts/{underlying}',
                        'orders/{underlying}',
                        'fills/{underlying}',
                        'accounts/{underlying}/ledger',
                        'trade_fee',
                        'orders/{underlying}/{order_id}',
                        'orders/{underlying}/{client_oid}',
                        # public
                        'underlying',
                        'instruments/{underlying}',
                        'instruments/{underlying}/summary',
                        'instruments/{underlying}/summary/{instrument_id}',
                        'instruments/{instrument_id}/book',
                        'instruments/{instrument_id}/trades',
                        'instruments/{instrument_id}/ticker',
                        'instruments/{instrument_id}/candles',
                    ],
                    'post': [
                        'order',
                        'orders',
                        'cancel_order/{underlying}/{order_id}',
                        'cancel_order/{underlying}/{client_oid}',
                        'cancel_batch_orders/{underlying}',
                        'amend_order/{underlying}',
                        'amend_batch_orders/{underlying}',
                    ],
                },
                'information': {
                    'get': [
                        '{currency}/long_short_ratio',
                        '{currency}/volume',
                        '{currency}/taker',
                        '{currency}/sentiment',
                        '{currency}/margin',
                    ],
                },
                'index': {
                    'get': [
                        '{instrument_id}/constituents',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.002,
                    'maker': 0.001,
                },
                'spot': {
                    'taker': 0.0015,
                    'maker': 0.0010,
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'password': True,
            },
            'exceptions': {
                # http error codes
                # 400 Bad Request — Invalid request format
                # 401 Unauthorized — Invalid API Key
                # 403 Forbidden — You do not have access to the requested resource
                # 404 Not Found
                # 429 Client Error: Too Many Requests for url
                # 500 Internal Server Error — We had a problem with our server
                'exact': {
                    '1': ExchangeError,  # {"code": 1, "message": "System error"}
                    # undocumented
                    'failure to get a peer from the ring-balancer': ExchangeNotAvailable,  # {"message": "failure to get a peer from the ring-balancer"}
                    'Server is busy, please try again.': ExchangeNotAvailable,  # {"message": "Server is busy, please try again."}
                    'An unexpected error occurred': ExchangeError,  # {"message": "An unexpected error occurred"}
                    'System error': ExchangeError,  # {"error_message":"System error","message":"System error"}
                    '4010': PermissionDenied,  # {"code": 4010, "message": "For the security of your funds, withdrawals are not permitted within 24 hours after changing fund password  / mobile number / Google Authenticator settings "}
                    # common
                    # '0': ExchangeError,  # 200 successful,when the order placement / cancellation / operation is successful
                    '4001': ExchangeError,  # no data received in 30s
                    '4002': ExchangeError,  # Buffer full. cannot write data
                    # --------------------------------------------------------
                    '30001': AuthenticationError,  # {"code": 30001, "message": 'request header "OK_ACCESS_KEY" cannot be blank'}
                    '30002': AuthenticationError,  # {"code": 30002, "message": 'request header "OK_ACCESS_SIGN" cannot be blank'}
                    '30003': AuthenticationError,  # {"code": 30003, "message": 'request header "OK_ACCESS_TIMESTAMP" cannot be blank'}
                    '30004': AuthenticationError,  # {"code": 30004, "message": 'request header "OK_ACCESS_PASSPHRASE" cannot be blank'}
                    '30005': InvalidNonce,  # {"code": 30005, "message": "invalid OK_ACCESS_TIMESTAMP"}
                    '30006': AuthenticationError,  # {"code": 30006, "message": "invalid OK_ACCESS_KEY"}
                    '30007': BadRequest,  # {"code": 30007, "message": 'invalid Content_Type, please use "application/json" format'}
                    '30008': RequestTimeout,  # {"code": 30008, "message": "timestamp request expired"}
                    '30009': ExchangeError,  # {"code": 30009, "message": "system error"}
                    '30010': AuthenticationError,  # {"code": 30010, "message": "API validation failed"}
                    '30011': PermissionDenied,  # {"code": 30011, "message": "invalid IP"}
                    '30012': AuthenticationError,  # {"code": 30012, "message": "invalid authorization"}
                    '30013': AuthenticationError,  # {"code": 30013, "message": "invalid sign"}
                    '30014': DDoSProtection,  # {"code": 30014, "message": "request too frequent"}
                    '30015': AuthenticationError,  # {"code": 30015, "message": 'request header "OK_ACCESS_PASSPHRASE" incorrect'}
                    '30016': ExchangeError,  # {"code": 30015, "message": "you are using v1 apiKey, please use v1 endpoint. If you would like to use v3 endpoint, please subscribe to v3 apiKey"}
                    '30017': ExchangeError,  # {"code": 30017, "message": "apikey's broker id does not match"}
                    '30018': ExchangeError,  # {"code": 30018, "message": "apikey's domain does not match"}
                    '30019': ExchangeNotAvailable,  # {"code": 30019, "message": "Api is offline or unavailable"}
                    '30020': BadRequest,  # {"code": 30020, "message": "body cannot be blank"}
                    '30021': BadRequest,  # {"code": 30021, "message": "Json data format error"}, {"code": 30021, "message": "json data format error"}
                    '30022': PermissionDenied,  # {"code": 30022, "message": "Api has been frozen"}
                    '30023': BadRequest,  # {"code": 30023, "message": "{0} parameter cannot be blank"}
                    '30024': BadSymbol,  # {"code":30024,"message":"\"instrument_id\" is an invalid parameter"}
                    '30025': BadRequest,  # {"code": 30025, "message": "{0} parameter category error"}
                    '30026': DDoSProtection,  # {"code": 30026, "message": "requested too frequent"}
                    '30027': AuthenticationError,  # {"code": 30027, "message": "login failure"}
                    '30028': PermissionDenied,  # {"code": 30028, "message": "unauthorized execution"}
                    '30029': AccountSuspended,  # {"code": 30029, "message": "account suspended"}
                    '30030': ExchangeNotAvailable,  # {"code": 30030, "message": "endpoint request failed. Please try again"}
                    '30031': BadRequest,  # {"code": 30031, "message": "token does not exist"}
                    '30032': BadSymbol,  # {"code": 30032, "message": "pair does not exist"}
                    '30033': BadRequest,  # {"code": 30033, "message": "exchange domain does not exist"}
                    '30034': ExchangeError,  # {"code": 30034, "message": "exchange ID does not exist"}
                    '30035': ExchangeError,  # {"code": 30035, "message": "trading is not supported in self website"}
                    '30036': ExchangeError,  # {"code": 30036, "message": "no relevant data"}
                    '30037': ExchangeNotAvailable,  # {"code": 30037, "message": "endpoint is offline or unavailable"}
                    # '30038': AuthenticationError,  # {"code": 30038, "message": "user does not exist"}
                    '30038': OnMaintenance,  # {"client_oid":"","code":"30038","error_code":"30038","error_message":"Matching engine is being upgraded. Please try in about 1 minute.","message":"Matching engine is being upgraded. Please try in about 1 minute.","order_id":"-1","result":false}
                    '30044': RequestTimeout,  # {"code":30044, "message":"Endpoint request timeout"}
                    # futures
                    '32001': AccountSuspended,  # {"code": 32001, "message": "futures account suspended"}
                    '32002': PermissionDenied,  # {"code": 32002, "message": "futures account does not exist"}
                    '32003': CancelPending,  # {"code": 32003, "message": "canceling, please wait"}
                    '32004': ExchangeError,  # {"code": 32004, "message": "you have no unfilled orders"}
                    '32005': InvalidOrder,  # {"code": 32005, "message": "max order quantity"}
                    '32006': InvalidOrder,  # {"code": 32006, "message": "the order price or trigger price exceeds USD 1 million"}
                    '32007': InvalidOrder,  # {"code": 32007, "message": "leverage level must be the same for orders on the same side of the contract"}
                    '32008': InvalidOrder,  # {"code": 32008, "message": "Max. positions to open(cross margin)"}
                    '32009': InvalidOrder,  # {"code": 32009, "message": "Max. positions to open(fixed margin)"}
                    '32010': ExchangeError,  # {"code": 32010, "message": "leverage cannot be changed with open positions"}
                    '32011': ExchangeError,  # {"code": 32011, "message": "futures status error"}
                    '32012': ExchangeError,  # {"code": 32012, "message": "futures order update error"}
                    '32013': ExchangeError,  # {"code": 32013, "message": "token type is blank"}
                    '32014': ExchangeError,  # {"code": 32014, "message": "your number of contracts closing is larger than the number of contracts available"}
                    '32015': ExchangeError,  # {"code": 32015, "message": "margin ratio is lower than 100% before opening positions"}
                    '32016': ExchangeError,  # {"code": 32016, "message": "margin ratio is lower than 100% after opening position"}
                    '32017': ExchangeError,  # {"code": 32017, "message": "no BBO"}
                    '32018': ExchangeError,  # {"code": 32018, "message": "the order quantity is less than 1, please try again"}
                    '32019': ExchangeError,  # {"code": 32019, "message": "the order price deviates from the price of the previous minute by more than 3%"}
                    '32020': ExchangeError,  # {"code": 32020, "message": "the price is not in the range of the price limit"}
                    '32021': ExchangeError,  # {"code": 32021, "message": "leverage error"}
                    '32022': ExchangeError,  # {"code": 32022, "message": "self function is not supported in your country or region according to the regulations"}
                    '32023': ExchangeError,  # {"code": 32023, "message": "self account has outstanding loan"}
                    '32024': ExchangeError,  # {"code": 32024, "message": "order cannot be placed during delivery"}
                    '32025': ExchangeError,  # {"code": 32025, "message": "order cannot be placed during settlement"}
                    '32026': ExchangeError,  # {"code": 32026, "message": "your account is restricted from opening positions"}
                    '32027': ExchangeError,  # {"code": 32027, "message": "cancelled over 20 orders"}
                    '32028': ExchangeError,  # {"code": 32028, "message": "account is suspended and liquidated"}
                    '32029': ExchangeError,  # {"code": 32029, "message": "order info does not exist"}
                    '32030': InvalidOrder,  # The order cannot be cancelled
                    '32031': ArgumentsRequired,  # client_oid or order_id is required.
                    '32038': AuthenticationError,  # User does not exist
                    '32040': ExchangeError,  # User have open contract orders or position
                    '32044': ExchangeError,  # {"code": 32044, "message": "The margin ratio after submitting self order is lower than the minimum requirement({0}) for your tier."}
                    '32045': ExchangeError,  # str of commission over 1 million
                    '32046': ExchangeError,  # Each user can hold up to 10 trade plans at the same time
                    '32047': ExchangeError,  # system error
                    '32048': InvalidOrder,  # Order strategy track range error
                    '32049': ExchangeError,  # Each user can hold up to 10 track plans at the same time
                    '32050': InvalidOrder,  # Order strategy rang error
                    '32051': InvalidOrder,  # Order strategy ice depth error
                    '32052': ExchangeError,  # str of commission over 100 thousand
                    '32053': ExchangeError,  # Each user can hold up to 6 ice plans at the same time
                    '32057': ExchangeError,  # The order price is zero. Market-close-all function cannot be executed
                    '32054': ExchangeError,  # Trade not allow
                    '32055': InvalidOrder,  # cancel order error
                    '32056': ExchangeError,  # iceberg per order average should between {0}-{1} contracts
                    '32058': ExchangeError,  # Each user can hold up to 6 initiative plans at the same time
                    '32059': InvalidOrder,  # Total amount should exceed per order amount
                    '32060': InvalidOrder,  # Order strategy type error
                    '32061': InvalidOrder,  # Order strategy initiative limit error
                    '32062': InvalidOrder,  # Order strategy initiative range error
                    '32063': InvalidOrder,  # Order strategy initiative rate error
                    '32064': ExchangeError,  # Time Stringerval of orders should set between 5-120s
                    '32065': ExchangeError,  # Close amount exceeds the limit of Market-close-all(999 for BTC, and 9999 for the rest tokens)
                    '32066': ExchangeError,  # You have open orders. Please cancel all open orders before changing your leverage level.
                    '32067': ExchangeError,  # Account equity < required margin in self setting. Please adjust your leverage level again.
                    '32068': ExchangeError,  # The margin for self position will fall short of the required margin in self setting. Please adjust your leverage level or increase your margin to proceed.
                    '32069': ExchangeError,  # Target leverage level too low. Your account balance is insufficient to cover the margin required. Please adjust the leverage level again.
                    '32070': ExchangeError,  # Please check open position or unfilled order
                    '32071': ExchangeError,  # Your current liquidation mode does not support self action.
                    '32072': ExchangeError,  # The highest available margin for your order’s tier is {0}. Please edit your margin and place a new order.
                    '32073': ExchangeError,  # The action does not apply to the token
                    '32074': ExchangeError,  # The number of contracts of your position, open orders, and the current order has exceeded the maximum order limit of self asset.
                    '32075': ExchangeError,  # Account risk rate breach
                    '32076': ExchangeError,  # Liquidation of the holding position(s) at market price will require cancellation of all pending close orders of the contracts.
                    '32077': ExchangeError,  # Your margin for self asset in futures account is insufficient and the position has been taken over for liquidation.(You will not be able to place orders, close positions, transfer funds, or add margin during self period of time. Your account will be restored after the liquidation is complete.)
                    '32078': ExchangeError,  # Please cancel all open orders before switching the liquidation mode(Please cancel all open orders before switching the liquidation mode)
                    '32079': ExchangeError,  # Your open positions are at high risk.(Please add margin or reduce positions before switching the mode)
                    '32080': ExchangeError,  # Funds cannot be transferred out within 30 minutes after futures settlement
                    '32083': ExchangeError,  # The number of contracts should be a positive multiple of %%. Please place your order again
                    # token and margin trading
                    '33001': PermissionDenied,  # {"code": 33001, "message": "margin account for self pair is not enabled yet"}
                    '33002': AccountSuspended,  # {"code": 33002, "message": "margin account for self pair is suspended"}
                    '33003': InsufficientFunds,  # {"code": 33003, "message": "no loan balance"}
                    '33004': ExchangeError,  # {"code": 33004, "message": "loan amount cannot be smaller than the minimum limit"}
                    '33005': ExchangeError,  # {"code": 33005, "message": "repayment amount must exceed 0"}
                    '33006': ExchangeError,  # {"code": 33006, "message": "loan order not found"}
                    '33007': ExchangeError,  # {"code": 33007, "message": "status not found"}
                    '33008': InsufficientFunds,  # {"code": 33008, "message": "loan amount cannot exceed the maximum limit"}
                    '33009': ExchangeError,  # {"code": 33009, "message": "user ID is blank"}
                    '33010': ExchangeError,  # {"code": 33010, "message": "you cannot cancel an order during session 2 of call auction"}
                    '33011': ExchangeError,  # {"code": 33011, "message": "no new market data"}
                    '33012': ExchangeError,  # {"code": 33012, "message": "order cancellation failed"}
                    '33013': InvalidOrder,  # {"code": 33013, "message": "order placement failed"}
                    '33014': OrderNotFound,  # {"code": 33014, "message": "order does not exist"}
                    '33015': InvalidOrder,  # {"code": 33015, "message": "exceeded maximum limit"}
                    '33016': ExchangeError,  # {"code": 33016, "message": "margin trading is not open for self token"}
                    '33017': InsufficientFunds,  # {"code": 33017, "message": "insufficient balance"}
                    '33018': ExchangeError,  # {"code": 33018, "message": "self parameter must be smaller than 1"}
                    '33020': ExchangeError,  # {"code": 33020, "message": "request not supported"}
                    '33021': BadRequest,  # {"code": 33021, "message": "token and the pair do not match"}
                    '33022': InvalidOrder,  # {"code": 33022, "message": "pair and the order do not match"}
                    '33023': ExchangeError,  # {"code": 33023, "message": "you can only place market orders during call auction"}
                    '33024': InvalidOrder,  # {"code": 33024, "message": "trading amount too small"}
                    '33025': InvalidOrder,  # {"code": 33025, "message": "base token amount is blank"}
                    '33026': ExchangeError,  # {"code": 33026, "message": "transaction completed"}
                    '33027': InvalidOrder,  # {"code": 33027, "message": "cancelled order or order cancelling"}
                    '33028': InvalidOrder,  # {"code": 33028, "message": "the decimal places of the trading price exceeded the limit"}
                    '33029': InvalidOrder,  # {"code": 33029, "message": "the decimal places of the trading size exceeded the limit"}
                    '33034': ExchangeError,  # {"code": 33034, "message": "You can only place limit order after Call Auction has started"}
                    '33035': ExchangeError,  # This type of order cannot be canceled(This type of order cannot be canceled)
                    '33036': ExchangeError,  # Exceeding the limit of entrust order
                    '33037': ExchangeError,  # The buy order price should be lower than 130% of the trigger price
                    '33038': ExchangeError,  # The sell order price should be higher than 70% of the trigger price
                    '33039': ExchangeError,  # The limit of callback rate is 0 < x <= 5%
                    '33040': ExchangeError,  # The trigger price of a buy order should be lower than the latest transaction price
                    '33041': ExchangeError,  # The trigger price of a sell order should be higher than the latest transaction price
                    '33042': ExchangeError,  # The limit of price variance is 0 < x <= 1%
                    '33043': ExchangeError,  # The total amount must be larger than 0
                    '33044': ExchangeError,  # The average amount should be 1/1000 * total amount <= x <= total amount
                    '33045': ExchangeError,  # The price should not be 0, including trigger price, order price, and price limit
                    '33046': ExchangeError,  # Price variance should be 0 < x <= 1%
                    '33047': ExchangeError,  # Sweep ratio should be 0 < x <= 100%
                    '33048': ExchangeError,  # Per order limit: Total amount/1000 < x <= Total amount
                    '33049': ExchangeError,  # Total amount should be X > 0
                    '33050': ExchangeError,  # Time interval should be 5 <= x <= 120s
                    '33051': ExchangeError,  # cancel order number not higher limit: plan and track entrust no more than 10, ice and time entrust no more than 6
                    '33059': BadRequest,  # {"code": 33059, "message": "client_oid or order_id is required"}
                    '33060': BadRequest,  # {"code": 33060, "message": "Only fill in either parameter client_oid or order_id"}
                    '33061': ExchangeError,  # Value of a single market price order cannot exceed 100,000 USD
                    '33062': ExchangeError,  # The leverage ratio is too high. The borrowed position has exceeded the maximum position of self leverage ratio. Please readjust the leverage ratio
                    '33063': ExchangeError,  # Leverage multiple is too low, there is insufficient margin in the account, please readjust the leverage ratio
                    '33064': ExchangeError,  # The setting of the leverage ratio cannot be less than 2, please readjust the leverage ratio
                    '33065': ExchangeError,  # Leverage ratio exceeds maximum leverage ratio, please readjust leverage ratio
                    '33085': InvalidOrder,  # The value of the position and buying order has reached the position limit, and no further buying is allowed.
                    # account
                    '21009': ExchangeError,  # Funds cannot be transferred out within 30 minutes after swap settlement(Funds cannot be transferred out within 30 minutes after swap settlement)
                    '34001': PermissionDenied,  # {"code": 34001, "message": "withdrawal suspended"}
                    '34002': InvalidAddress,  # {"code": 34002, "message": "please add a withdrawal address"}
                    '34003': ExchangeError,  # {"code": 34003, "message": "sorry, self token cannot be withdrawn to xx at the moment"}
                    '34004': ExchangeError,  # {"code": 34004, "message": "withdrawal fee is smaller than minimum limit"}
                    '34005': ExchangeError,  # {"code": 34005, "message": "withdrawal fee exceeds the maximum limit"}
                    '34006': ExchangeError,  # {"code": 34006, "message": "withdrawal amount is lower than the minimum limit"}
                    '34007': ExchangeError,  # {"code": 34007, "message": "withdrawal amount exceeds the maximum limit"}
                    '34008': InsufficientFunds,  # {"code": 34008, "message": "insufficient balance"}
                    '34009': ExchangeError,  # {"code": 34009, "message": "your withdrawal amount exceeds the daily limit"}
                    '34010': ExchangeError,  # {"code": 34010, "message": "transfer amount must be larger than 0"}
                    '34011': ExchangeError,  # {"code": 34011, "message": "conditions not met"}
                    '34012': ExchangeError,  # {"code": 34012, "message": "the minimum withdrawal amount for NEO is 1, and the amount must be an integer"}
                    '34013': ExchangeError,  # {"code": 34013, "message": "please transfer"}
                    '34014': ExchangeError,  # {"code": 34014, "message": "transfer limited"}
                    '34015': ExchangeError,  # {"code": 34015, "message": "subaccount does not exist"}
                    '34016': PermissionDenied,  # {"code": 34016, "message": "transfer suspended"}
                    '34017': AccountSuspended,  # {"code": 34017, "message": "account suspended"}
                    '34018': AuthenticationError,  # {"code": 34018, "message": "incorrect trades password"}
                    '34019': PermissionDenied,  # {"code": 34019, "message": "please bind your email before withdrawal"}
                    '34020': PermissionDenied,  # {"code": 34020, "message": "please bind your funds password before withdrawal"}
                    '34021': InvalidAddress,  # {"code": 34021, "message": "Not verified address"}
                    '34022': ExchangeError,  # {"code": 34022, "message": "Withdrawals are not available for sub accounts"}
                    '34023': PermissionDenied,  # {"code": 34023, "message": "Please enable futures trading before transferring your funds"}
                    '34026': RateLimitExceeded,  # transfer too frequently(transfer too frequently)
                    '34036': ExchangeError,  # Parameter is incorrect, please refer to API documentation
                    '34037': ExchangeError,  # Get the sub-account balance interface, account type is not supported
                    '34038': ExchangeError,  # Since your C2C transaction is unusual, you are restricted from fund transfer. Please contact our customer support to cancel the restriction
                    '34039': ExchangeError,  # You are now restricted from transferring out your funds due to abnormal trades on C2C Market. Please transfer your fund on our website or app instead to verify your identity
                    # swap
                    '35001': ExchangeError,  # {"code": 35001, "message": "Contract does not exist"}
                    '35002': ExchangeError,  # {"code": 35002, "message": "Contract settling"}
                    '35003': ExchangeError,  # {"code": 35003, "message": "Contract paused"}
                    '35004': ExchangeError,  # {"code": 35004, "message": "Contract pending settlement"}
                    '35005': AuthenticationError,  # {"code": 35005, "message": "User does not exist"}
                    '35008': InvalidOrder,  # {"code": 35008, "message": "Risk ratio too high"}
                    '35010': InvalidOrder,  # {"code": 35010, "message": "Position closing too large"}
                    '35012': InvalidOrder,  # {"code": 35012, "message": "Incorrect order size"}
                    '35014': InvalidOrder,  # {"code": 35014, "message": "Order price is not within limit"}
                    '35015': InvalidOrder,  # {"code": 35015, "message": "Invalid leverage level"}
                    '35017': ExchangeError,  # {"code": 35017, "message": "Open orders exist"}
                    '35019': InvalidOrder,  # {"code": 35019, "message": "Order size too large"}
                    '35020': InvalidOrder,  # {"code": 35020, "message": "Order price too high"}
                    '35021': InvalidOrder,  # {"code": 35021, "message": "Order size exceeded current tier limit"}
                    '35022': BadRequest,  # {"code": 35022, "message": "Contract status error"}
                    '35024': BadRequest,  # {"code": 35024, "message": "Contract not initialized"}
                    '35025': InsufficientFunds,  # {"code": 35025, "message": "No account balance"}
                    '35026': BadRequest,  # {"code": 35026, "message": "Contract settings not initialized"}
                    '35029': OrderNotFound,  # {"code": 35029, "message": "Order does not exist"}
                    '35030': InvalidOrder,  # {"code": 35030, "message": "Order size too large"}
                    '35031': InvalidOrder,  # {"code": 35031, "message": "Cancel order size too large"}
                    '35032': ExchangeError,  # {"code": 35032, "message": "Invalid user status"}
                    '35037': ExchangeError,  # No last traded price in cache
                    '35039': InsufficientFunds,  # {"code": 35039, "message": "Open order quantity exceeds limit"}
                    '35040': InvalidOrder,  # {"error_message":"Invalid order type","result":"true","error_code":"35040","order_id":"-1"}
                    '35044': ExchangeError,  # {"code": 35044, "message": "Invalid order status"}
                    '35046': InsufficientFunds,  # {"code": 35046, "message": "Negative account balance"}
                    '35047': InsufficientFunds,  # {"code": 35047, "message": "Insufficient account balance"}
                    '35048': ExchangeError,  # {"code": 35048, "message": "User contract is frozen and liquidating"}
                    '35049': InvalidOrder,  # {"code": 35049, "message": "Invalid order type"}
                    '35050': InvalidOrder,  # {"code": 35050, "message": "Position settings are blank"}
                    '35052': InsufficientFunds,  # {"code": 35052, "message": "Insufficient cross margin"}
                    '35053': ExchangeError,  # {"code": 35053, "message": "Account risk too high"}
                    '35055': InsufficientFunds,  # {"code": 35055, "message": "Insufficient account balance"}
                    '35057': ExchangeError,  # {"code": 35057, "message": "No last traded price"}
                    '35058': ExchangeError,  # {"code": 35058, "message": "No limit"}
                    '35059': BadRequest,  # {"code": 35059, "message": "client_oid or order_id is required"}
                    '35060': BadRequest,  # {"code": 35060, "message": "Only fill in either parameter client_oid or order_id"}
                    '35061': BadRequest,  # {"code": 35061, "message": "Invalid instrument_id"}
                    '35062': InvalidOrder,  # {"code": 35062, "message": "Invalid match_price"}
                    '35063': InvalidOrder,  # {"code": 35063, "message": "Invalid order_size"}
                    '35064': InvalidOrder,  # {"code": 35064, "message": "Invalid client_oid"}
                    '35066': InvalidOrder,  # Order interval error
                    '35067': InvalidOrder,  # Time-weighted order ratio error
                    '35068': InvalidOrder,  # Time-weighted order range error
                    '35069': InvalidOrder,  # Time-weighted single transaction limit error
                    '35070': InvalidOrder,  # Algo order type error
                    '35071': InvalidOrder,  # Order total must be larger than single order limit
                    '35072': InvalidOrder,  # Maximum 6 unfulfilled time-weighted orders can be held at the same time
                    '35073': InvalidOrder,  # Order price is 0. Market-close-all not available
                    '35074': InvalidOrder,  # Iceberg order single transaction average error
                    '35075': InvalidOrder,  # Failed to cancel order
                    '35076': InvalidOrder,  # LTC 20x leverage. Not allowed to open position
                    '35077': InvalidOrder,  # Maximum 6 unfulfilled iceberg orders can be held at the same time
                    '35078': InvalidOrder,  # Order amount exceeded 100,000
                    '35079': InvalidOrder,  # Iceberg order price variance error
                    '35080': InvalidOrder,  # Callback rate error
                    '35081': InvalidOrder,  # Maximum 10 unfulfilled trail orders can be held at the same time
                    '35082': InvalidOrder,  # Trail order callback rate error
                    '35083': InvalidOrder,  # Each user can only hold a maximum of 10 unfulfilled stop-limit orders at the same time
                    '35084': InvalidOrder,  # Order amount exceeded 1 million
                    '35085': InvalidOrder,  # Order amount is not in the correct range
                    '35086': InvalidOrder,  # Price exceeds 100 thousand
                    '35087': InvalidOrder,  # Price exceeds 100 thousand
                    '35088': InvalidOrder,  # Average amount error
                    '35089': InvalidOrder,  # Price exceeds 100 thousand
                    '35090': ExchangeError,  # No stop-limit orders available for cancelation
                    '35091': ExchangeError,  # No trail orders available for cancellation
                    '35092': ExchangeError,  # No iceberg orders available for cancellation
                    '35093': ExchangeError,  # No trail orders available for cancellation
                    '35094': ExchangeError,  # Stop-limit order last traded price error
                    '35095': BadRequest,  # Instrument_id error
                    '35096': ExchangeError,  # Algo order status error
                    '35097': ExchangeError,  # Order status and order ID cannot exist at the same time
                    '35098': ExchangeError,  # An order status or order ID must exist
                    '35099': ExchangeError,  # Algo order ID error
                    '35102': RateLimitExceeded,  # {"error_message":"The operation that close all at market price is too frequent","result":"true","error_code":"35102","order_id":"-1"}
                    # option
                    '36001': BadRequest,  # Invalid underlying index.
                    '36002': BadRequest,  # Instrument does not exist.
                    '36005': ExchangeError,  # Instrument status is invalid.
                    '36101': AuthenticationError,  # Account does not exist.
                    '36102': PermissionDenied,  # Account status is invalid.
                    '36103': PermissionDenied,  # Account is suspended due to ongoing liquidation.
                    '36104': PermissionDenied,  # Account is not enabled for options trading.
                    '36105': PermissionDenied,  # Please enable the account for option contract.
                    '36106': PermissionDenied,  # Funds cannot be transferred in or out, as account is suspended.
                    '36107': PermissionDenied,  # Funds cannot be transferred out within 30 minutes after option exercising or settlement.
                    '36108': InsufficientFunds,  # Funds cannot be transferred in or out, as equity of the account is less than zero.
                    '36109': PermissionDenied,  # Funds cannot be transferred in or out during option exercising or settlement.
                    '36201': PermissionDenied,  # New order function is blocked.
                    '36202': PermissionDenied,  # Account does not have permission to short option.
                    '36203': InvalidOrder,  # Invalid format for client_oid.
                    '36204': ExchangeError,  # Invalid format for request_id.
                    '36205': BadRequest,  # Instrument id does not match underlying index.
                    '36206': BadRequest,  # Order_id and client_oid can not be used at the same time.
                    '36207': InvalidOrder,  # Either order price or fartouch price must be present.
                    '36208': InvalidOrder,  # Either order price or size must be present.
                    '36209': InvalidOrder,  # Either order_id or client_oid must be present.
                    '36210': InvalidOrder,  # Either order_ids or client_oids must be present.
                    '36211': InvalidOrder,  # Exceeding max batch size for order submission.
                    '36212': InvalidOrder,  # Exceeding max batch size for oder cancellation.
                    '36213': InvalidOrder,  # Exceeding max batch size for order amendment.
                    '36214': ExchangeError,  # Instrument does not have valid bid/ask quote.
                    '36216': OrderNotFound,  # Order does not exist.
                    '36217': InvalidOrder,  # Order submission failed.
                    '36218': InvalidOrder,  # Order cancellation failed.
                    '36219': InvalidOrder,  # Order amendment failed.
                    '36220': InvalidOrder,  # Order is pending cancel.
                    '36221': InvalidOrder,  # Order qty is not valid multiple of lot size.
                    '36222': InvalidOrder,  # Order price is breaching highest buy limit.
                    '36223': InvalidOrder,  # Order price is breaching lowest sell limit.
                    '36224': InvalidOrder,  # Exceeding max order size.
                    '36225': InvalidOrder,  # Exceeding max open order count for instrument.
                    '36226': InvalidOrder,  # Exceeding max open order count for underlying.
                    '36227': InvalidOrder,  # Exceeding max open size across all orders for underlying
                    '36228': InvalidOrder,  # Exceeding max available qty for instrument.
                    '36229': InvalidOrder,  # Exceeding max available qty for underlying.
                    '36230': InvalidOrder,  # Exceeding max position limit for underlying.
                },
                'broad': {
                },
            },
            'precisionMode': TICK_SIZE,
            'options': {
                'fetchOHLCV': {
                    'type': 'Candles',  # Candles or HistoryCandles
                },
                'createMarketBuyOrderRequiresPrice': True,
                'fetchMarkets': ['spot'],
                'defaultType': 'spot',  # 'account', 'spot', 'futures', 'swap', 'option'
                'accountsByType': {
                    'spot': '1',
                    'funding': '6',
                    'main': '6',
                },
                'accountsById': {
                    '1': 'spot',
                    '6': 'funding',
                },
                'auth': {
                    'time': 'public',
                    'currencies': 'private',
                    'instruments': 'public',
                    'rate': 'public',
                    '{instrument_id}/constituents': 'public',
                },
                'warnOnFetchCurrenciesWithoutAuthorization': False,
            },
            'commonCurrencies': {
                # OKEX refers to ERC20 version of Aeternity(AEToken)
                'AE': 'AET',  # https://github.com/ccxt/ccxt/issues/4981
                'BOX': 'DefiBox',
                'HOT': 'Hydro Protocol',
                'HSR': 'HC',
                'MAG': 'Maggie',
                'SBTC': 'Super Bitcoin',
                'TRADE': 'Unitrade',
                'YOYO': 'YOYOW',
                'WIN': 'WinToken',  # https://github.com/ccxt/ccxt/issues/5701
            },
        })

    async def fetch_time(self, params={}):
        """
        fetches the current integer timestamp in milliseconds from the exchange server
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns int: the current integer timestamp in milliseconds from the exchange server
        """
        response = await self.generalGetTime(params)
        #
        #     {
        #         "iso": "2015-01-07T23:47:25.201Z",
        #         "epoch": 1420674445.201
        #     }
        #
        return self.parse8601(self.safe_string(response, 'iso'))

    async def fetch_markets(self, params={}):
        """
        retrieves data on all markets for okcoin
        :param dict params: extra parameters specific to the exchange api endpoint
        :returns [dict]: an array of objects representing market data
        """
        types = self.safe_value(self.options, 'fetchMarkets')
        result = []
        for i in range(0, len(types)):
            markets = await self.fetch_markets_by_type(types[i], params)
            result = self.array_concat(result, markets)
        return result

    def parse_markets(self, markets):
        result = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    def parse_market(self, market):
        #
        # spot markets
        #
        #     {
        #         base_currency: "EOS",
        #         instrument_id: "EOS-OKB",
        #         min_size: "0.01",
        #         quote_currency: "OKB",
        #         size_increment: "0.000001",
        #         tick_size: "0.0001"
        #     }
        #
        # futures markets
        #
        #     {
        #         instrument_id: "XRP-USD-200320",
        #         underlying_index: "XRP",
        #         quote_currency: "USD",
        #         tick_size: "0.0001",
        #         contract_val: "10",
        #         listing: "2020-03-06",
        #         delivery: "2020-03-20",
        #         trade_increment: "1",
        #         alias: "self_week",
        #         underlying: "XRP-USD",
        #         base_currency: "XRP",
        #         settlement_currency: "XRP",
        #         is_inverse: "true",
        #         contract_val_currency: "USD",
        #     }
        #
        # swap markets
        #
        #     {
        #         instrument_id: "BSV-USD-SWAP",
        #         underlying_index: "BSV",
        #         quote_currency: "USD",
        #         coin: "BSV",
        #         contract_val: "10",
        #         listing: "2018-12-21T07:53:47.000Z",
        #         delivery: "2020-03-14T08:00:00.000Z",
        #         size_increment: "1",
        #         tick_size: "0.01",
        #         base_currency: "BSV",
        #         underlying: "BSV-USD",
        #         settlement_currency: "BSV",
        #         is_inverse: "true",
        #         contract_val_currency: "USD"
        #     }
        #
        # options markets
        #
        #     {
        #         instrument_id: 'BTC-USD-200327-4000-C',
        #         underlying: 'BTC-USD',
        #         settlement_currency: 'BTC',
        #         contract_val: '0.1000',
        #         option_type: 'C',
        #         strike: '4000',
        #         tick_size: '0.0005',
        #         lot_size: '1.0000',
        #         listing: '2019-12-25T08:30:36.302Z',
        #         delivery: '2020-03-27T08:00:00.000Z',
        #         state: '2',
        #         trading_start_time: '2019-12-25T08:30:36.302Z',
        #         timestamp: '2020-03-13T08:05:09.456Z',
        #     }
        #
        id = self.safe_string(market, 'instrument_id')
        optionType = self.safe_value(market, 'option_type')
        contractVal = self.safe_number(market, 'contract_val')
        contract = contractVal is not None
        futuresAlias = self.safe_string(market, 'alias')
        marketType = 'spot'
        spot = not contract
        option = (optionType is not None)
        future = not option and (futuresAlias is not None)
        swap = contract and not future and not option
        baseId = self.safe_string(market, 'base_currency')
        quoteId = self.safe_string(market, 'quote_currency')
        settleId = self.safe_string(market, 'settlement_currency')
        if option:
            underlying = self.safe_string(market, 'underlying')
            parts = underlying.split('-')
            baseId = self.safe_string(parts, 0)
            quoteId = self.safe_string(parts, 1)
            marketType = 'option'
        elif future:
            baseId = self.safe_string(market, 'underlying_index')
            marketType = 'futures'
        elif swap:
            marketType = 'swap'
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        settle = self.safe_currency_code(settleId)
        symbol = base + '/' + quote
        expiryDatetime = self.safe_string(market, 'delivery')
        expiry = None
        strike = self.safe_value(market, 'strike')
        if contract:
            symbol = symbol + ':' + settle
            if future or option:
                if future:
                    expiryDatetime += 'T00:00:00Z'
                expiry = self.parse8601(expiryDatetime)
                symbol = symbol + '-' + self.yymmdd(expiry)
                if option:
                    symbol = symbol + ':' + strike + ':' + optionType
                    optionType = 'call' if (optionType == 'C') else 'put'
        lotSize = self.safe_number_2(market, 'lot_size', 'trade_increment')
        minPrice = self.safe_string(market, 'tick_size')
        minAmountString = self.safe_string_2(market, 'min_size', 'base_min_size')
        minAmount = self.parse_number(minAmountString)
        minCost = None
        if (minAmount is not None) and (minPrice is not None):
            minCost = self.parse_number(Precise.string_mul(minPrice, minAmountString))
        fees = self.safe_value_2(self.fees, marketType, 'trading', {})
        maxLeverageString = self.safe_string(market, 'max_leverage', '1')
        maxLeverage = self.parse_number(Precise.string_max(maxLeverageString, '1'))
        precisionPrice = self.parse_number(minPrice)
        return self.extend(fees, {
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'settle': settle,
            'baseId': baseId,
            'quoteId': quoteId,
            'settleId': settleId,
            'type': marketType,
            'spot': spot,
            'margin': False,
            'swap': swap,
            'future': future,
            'futures': future,  # deprecated
            'option': option,
            'active': True,
            'contract': contract,
            'linear': (quote == settle) if contract else None,
            'inverse': (base == settle) if contract else None,
            'contractSize': contractVal,
            'expiry': expiry,
            'expiryDatetime': self.iso8601(expiry),
            'strike': strike,
            'optionType': optionType,
            'precision': {
                'amount': self.safe_number(market, 'size_increment', lotSize),
                'price': precisionPrice,
            },
            'limits': {
                'leverage': {
                    'min': self.parse_number('1'),
                    'max': self.parse_number(maxLeverage),
                },
                'amount': {
                    'min': minAmount,
                    'max': None,
                },
                'price': {
                    'min': precisionPrice,
                    'max': None,
                },
                'cost': {
                    'min': minCost,
                    'max': None,
                },
            },
            'info': market,
        })

    async def fetch_markets_by_type(self, type, params={}):
        if type == 'option':
            underlying = await self.optionGetUnderlying(params)
            result = []
            for i in range(0, len(underlying)):
                response = await self.optionGetInstrumentsUnderlying({
                    'underlying': underlying[i],
                })
                #
                # options markets
                #
                #     [
                #         {
                #             instrument_id: 'BTC-USD-200327-4000-C',
                #             underlying: 'BTC-USD',
                #             settlement_currency: 'BTC',
                #             contract_val: '0.1000',
                #             option_type: 'C',
                #             strike: '4000',
                #             tick_size: '0.0005',
                #             lot_size: '1.0000',
                #             listing: '2019-12-25T08:30:36.302Z',
                #             delivery: '2020-03-27T08:00:00.000Z',
                #             state: '2',
                #             trading_start_time: '2019-12-25T08:30:36.302Z',
                #             timestamp: '2020-03-13T08:05:09.456Z',
                #         },
                #     ]
                #
                result = self.array_concat(result, response)
            return self.parse_markets(result)
        elif (type == 'spot') or (type == 'futures') or (type == 'swap'):
            method = type + 'GetInstruments'
            response = await getattr(self, method)(params)
            #
            # spot markets
            #
            #     [
            #         {
            #             base_currency: "EOS",
            #             instrument_id: "EOS-OKB",
            #             min_size: "0.01",
            #             quote_currency: "OKB",
            #             size_increment: "0.000001",
            #             tick_size: "0.0001"
            #         }
            #     ]
            #
            # futures markets
            #
            #     [
            #         {
            #             instrument_id: "XRP-USD-200320",
            #             underlying_index: "XRP",
            #             quote_currency: "USD",
            #             tick_size: "0.0001",
            #             contract_val: "10",
            #             listing: "2020-03-06",
            #             delivery: "2020-03-20",
            #             trade_increment: "1",
            #             alias: "self_week",
            #             underlying: "XRP-USD",
            #             base_currency: "XRP",
            #             settlement_currency: "XRP",
            #             is_inverse: "true",
            #             contract_val_currency: "USD",
            #         }
            #     ]
            #
            # swap markets
            #
            #     [
            #         {
            #             instrument_id: "BSV-USD-SWAP",
            #             underlying_index: "BSV",
            #             quote_currency: "USD",
            #             coin: "BSV",
            #             contract_val: "10",
            #             listing: "2018-12-21T07:53:47.000Z",
            #             delivery: "2020-03-14T08:00:00.000Z",
            #             size_increment: "1",
            #             tick_size: "0.01",
            #             base_currency: "BSV",
            #             underlying: "BSV-USD",
            #             settlement_currency: "BSV",
            #             is_inverse: "true",
            #             contract_val_currency: "USD"
            #         }
            #     ]
            #
            return self.parse_markets(response)
        else:
            raise NotSupported(self.id + ' fetchMarketsByType() does not support market type ' + type)

    async def fetch_currencies(self, params={}):
        """
        fetches all available currencies on an exchange
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: an associative dictionary of currencies
        """
        # despite that their docs say these endpoints are public:
        #     https://www.okex.com/api/account/v3/withdrawal/fee
        #     https://www.okex.com/api/account/v3/currencies
        # it will still reply with {"code":30001, "message": "OK-ACCESS-KEY header is required"}
        # if you attempt to access it without authentication
        if not self.check_required_credentials(False):
            if self.options['warnOnFetchCurrenciesWithoutAuthorization']:
                raise ExchangeError(self.id + ' fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options["warnOnFetchCurrenciesWithoutAuthorization"] = False to suppress self warning message.')
            return None
        else:
            response = await self.accountGetCurrencies(params)
            #
            #     [
            #         {
            #             name: '',
            #             currency: 'BTC',
            #             can_withdraw: '1',
            #             can_deposit: '1',
            #             min_withdrawal: '0.0100000000000000'
            #         },
            #     ]
            #
            result = {}
            for i in range(0, len(response)):
                currency = response[i]
                id = self.safe_string(currency, 'currency')
                code = self.safe_currency_code(id)
                name = self.safe_string(currency, 'name')
                canDeposit = self.safe_integer(currency, 'can_deposit')
                canWithdraw = self.safe_integer(currency, 'can_withdraw')
                depositEnabled = (canDeposit == 1)
                withdrawEnabled = (canWithdraw == 1)
                active = True if (canDeposit and canWithdraw) else False
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'type': None,
                    'name': name,
                    'active': active,
                    'deposit': depositEnabled,
                    'withdraw': withdrawEnabled,
                    'fee': None,  # todo: redesign
                    'precision': self.parse_number('0.00000001'),
                    'limits': {
                        'amount': {'min': None, 'max': None},
                        'withdraw': {
                            'min': self.safe_number(currency, 'min_withdrawal'),
                            'max': None,
                        },
                    },
                }
            return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentId'
        method += 'Depth' if (market['type'] == 'swap') else 'Book'
        request = {
            'instrument_id': market['id'],
        }
        if limit is not None:
            request['size'] = limit  # max 200
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot
        #
        #     {     asks: [["0.02685268", "0.242571", "1"],
        #                    ["0.02685493", "0.164085", "1"],
        #                    ...
        #                    ["0.02779", "1.039", "1"],
        #                    ["0.027813", "0.0876", "1"]        ],
        #            bids: [["0.02684052", "10.371849", "1"],
        #                    ["0.02684051", "3.707", "4"],
        #                    ...
        #                    ["0.02634963", "0.132934", "1"],
        #                    ["0.02634962", "0.264838", "2"]    ],
        #       timestamp:   "2018-12-17T20:24:16.159Z"            }
        #
        # swap
        #
        #     {
        #         "asks":[
        #             ["916.21","94","0","1"]
        #         ],
        #         "bids":[
        #             ["916.1","15","0","1"]
        #         ],
        #         "time":"2021-04-16T02:04:48.282Z"
        #     }
        #
        timestamp = self.parse8601(self.safe_string_2(response, 'timestamp', 'time'))
        return self.parse_order_book(response, symbol, timestamp)

    def parse_ticker(self, ticker, market=None):
        #
        #     {        best_ask: "0.02665472",
        #               best_bid: "0.02665221",
        #          instrument_id: "ETH-BTC",
        #             product_id: "ETH-BTC",
        #                   last: "0.02665472",
        #                    ask: "0.02665472",  # missing in the docs
        #                    bid: "0.02665221",  # not mentioned in the docs
        #               open_24h: "0.02645482",
        #               high_24h: "0.02714633",
        #                low_24h: "0.02614109",
        #        base_volume_24h: "572298.901923",
        #              timestamp: "2018-12-17T21:20:07.856Z",
        #       quote_volume_24h: "15094.86831261"            }
        #
        timestamp = self.parse8601(self.safe_string(ticker, 'timestamp'))
        marketId = self.safe_string(ticker, 'instrument_id')
        market = self.safe_market(marketId, market, '-')
        symbol = market['symbol']
        last = self.safe_string(ticker, 'last')
        open = self.safe_string(ticker, 'open_24h')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'high_24h'),
            'low': self.safe_string(ticker, 'low_24h'),
            'bid': self.safe_string(ticker, 'best_bid'),
            'bidVolume': self.safe_string(ticker, 'best_bid_size'),
            'ask': self.safe_string(ticker, 'best_ask'),
            'askVolume': self.safe_string(ticker, 'best_ask_size'),
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_string(ticker, 'base_volume_24h'),
            'quoteVolume': self.safe_string(ticker, 'quote_volume_24h'),
            'info': ticker,
        }, market)

    async def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdTicker'
        request = {
            'instrument_id': market['id'],
        }
        response = await getattr(self, method)(self.extend(request, params))
        #
        #     {        best_ask: "0.02665472",
        #               best_bid: "0.02665221",
        #          instrument_id: "ETH-BTC",
        #             product_id: "ETH-BTC",
        #                   last: "0.02665472",
        #                    ask: "0.02665472",
        #                    bid: "0.02665221",
        #               open_24h: "0.02645482",
        #               high_24h: "0.02714633",
        #                low_24h: "0.02614109",
        #        base_volume_24h: "572298.901923",
        #              timestamp: "2018-12-17T21:20:07.856Z",
        #       quote_volume_24h: "15094.86831261"            }
        #
        return self.parse_ticker(response)

    async def fetch_tickers_by_type(self, type, symbols=None, params={}):
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        method = type + 'GetInstrumentsTicker'
        response = await getattr(self, method)(params)
        result = {}
        for i in range(0, len(response)):
            ticker = self.parse_ticker(response[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return self.filter_by_array(result, 'symbol', symbols)

    async def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: an array of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        symbols = self.market_symbols(symbols)
        first = self.safe_string(symbols, 0)
        market = None
        if first is not None:
            market = self.market(first)
        type = None
        type, params = self.handle_market_type_and_params('fetchTickers', market, params)
        return await self.fetch_tickers_by_type(type, symbols, self.omit(params, 'type'))

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #     spot trades
        #
        #         {
        #             time: "2018-12-17T23:31:08.268Z",
        #             timestamp: "2018-12-17T23:31:08.268Z",
        #             trade_id: "409687906",
        #             price: "0.02677805",
        #             size: "0.923467",
        #             side: "sell"
        #         }
        #
        #     futures trades, swap trades
        #
        #         {
        #             trade_id: "1989230840021013",
        #             side: "buy",
        #             price: "92.42",
        #             qty: "184",  # missing in swap markets
        #             size: "5",  # missing in futures markets
        #             timestamp: "2018-12-17T23:26:04.613Z"
        #         }
        #
        # fetchOrderTrades(private)
        #
        #     spot trades
        #
        #         {
        #             "created_at":"2019-03-15T02:52:56.000Z",
        #             "exec_type":"T",  # whether the order is taker or maker
        #             "fee":"0.00000082",
        #             "instrument_id":"BTC-USDT",
        #             "ledger_id":"3963052721",
        #             "liquidity":"T",  # whether the order is taker or maker
        #             "order_id":"2482659399697408",
        #             "price":"3888.6",
        #             "product_id":"BTC-USDT",
        #             "side":"buy",
        #             "size":"0.00055306",
        #             "timestamp":"2019-03-15T02:52:56.000Z"
        #         },
        #
        #     futures trades, swap trades
        #
        #         {
        #             "trade_id":"197429674631450625",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "order_id":"6a-7-54d663a28-0",
        #             "price":"3.633",
        #             "order_qty":"1.0000",
        #             "fee":"-0.000551",
        #             "created_at":"2019-03-21T04:41:58.0Z",  # missing in swap trades
        #             "timestamp":"2019-03-25T05:56:31.287Z",  # missing in futures trades
        #             "exec_type":"M",  # whether the order is taker or maker
        #             "side":"short",  # "buy" in futures trades
        #         }
        #
        marketId = self.safe_string(trade, 'instrument_id')
        market = self.safe_market(marketId, market, '-')
        symbol = market['symbol']
        timestamp = self.parse8601(self.safe_string_2(trade, 'timestamp', 'created_at'))
        priceString = self.safe_string(trade, 'price')
        amountString = self.safe_string_2(trade, 'size', 'qty')
        amountString = self.safe_string(trade, 'order_qty', amountString)
        takerOrMaker = self.safe_string_2(trade, 'exec_type', 'liquidity')
        if takerOrMaker == 'M':
            takerOrMaker = 'maker'
        elif takerOrMaker == 'T':
            takerOrMaker = 'taker'
        side = self.safe_string(trade, 'side')
        feeCostString = self.safe_string(trade, 'fee')
        fee = None
        if feeCostString is not None:
            feeCurrency = market['base'] if (side == 'buy') else market['quote']
            fee = {
                # fee is either a positive number(invitation rebate)
                # or a negative number(transaction fee deduction)
                # therefore we need to invert the fee
                # more about it https://github.com/ccxt/ccxt/issues/5909
                'cost': Precise.string_neg(feeCostString),
                'currency': feeCurrency,
            }
        orderId = self.safe_string(trade, 'order_id')
        return self.safe_trade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': self.safe_string_2(trade, 'trade_id', 'ledger_id'),
            'order': orderId,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': priceString,
            'amount': amountString,
            'cost': None,
            'fee': fee,
        }, market)

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        await self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdTrades'
        if (limit is None) or (limit > 100):
            limit = 100  # maximum = default = 100
        request = {
            'instrument_id': market['id'],
            'limit': limit,
            # from: 'id',
            # to: 'id',
        }
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot markets
        #
        #     [
        #         {
        #             time: "2018-12-17T23:31:08.268Z",
        #             timestamp: "2018-12-17T23:31:08.268Z",
        #             trade_id: "409687906",
        #             price: "0.02677805",
        #             size: "0.923467",
        #             side: "sell"
        #         }
        #     ]
        #
        # futures markets, swap markets
        #
        #     [
        #         {
        #             trade_id: "1989230840021013",
        #             side: "buy",
        #             price: "92.42",
        #             qty: "184",  # missing in swap markets
        #             size: "5",  # missing in futures markets
        #             timestamp: "2018-12-17T23:26:04.613Z"
        #         }
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        #
        # spot markets
        #
        #     {
        #         close: "0.02684545",
        #         high: "0.02685084",
        #         low: "0.02683312",
        #         open: "0.02683894",
        #         time: "2018-12-17T20:28:00.000Z",
        #         volume: "101.457222"
        #     }
        #
        # futures markets
        #
        #     [
        #         1545072720000,
        #         0.3159,
        #         0.3161,
        #         0.3144,
        #         0.3149,
        #         22886,
        #         725179.26172331,
        #     ]
        #
        if isinstance(ohlcv, list):
            numElements = len(ohlcv)
            volumeIndex = 6 if (numElements > 6) else 5
            timestamp = self.safe_value(ohlcv, 0)
            if isinstance(timestamp, str):
                timestamp = self.parse8601(timestamp)
            return [
                timestamp,  # timestamp
                self.safe_number(ohlcv, 1),            # Open
                self.safe_number(ohlcv, 2),            # High
                self.safe_number(ohlcv, 3),            # Low
                self.safe_number(ohlcv, 4),            # Close
                # self.safe_number(ohlcv, 5),         # Quote Volume
                # self.safe_number(ohlcv, 6),         # Base Volume
                self.safe_number(ohlcv, volumeIndex),  # Volume, okex will return base volume in the 7th element for future markets
            ]
        else:
            return [
                self.parse8601(self.safe_string(ohlcv, 'time')),
                self.safe_number(ohlcv, 'open'),    # Open
                self.safe_number(ohlcv, 'high'),    # High
                self.safe_number(ohlcv, 'low'),     # Low
                self.safe_number(ohlcv, 'close'),   # Close
                self.safe_number(ohlcv, 'volume'),  # Base Volume
            ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int|None since: timestamp in ms of the earliest candle to fetch
        :param int|None limit: the maximum amount of candles to fetch
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [[int]]: A list of candles ordered as timestamp, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        duration = self.parse_timeframe(timeframe)
        request = {
            'instrument_id': market['id'],
            'granularity': self.timeframes[timeframe],
        }
        options = self.safe_value(self.options, 'fetchOHLCV', {})
        defaultType = self.safe_string(options, 'type', 'Candles')  # Candles or HistoryCandles
        type = self.safe_string(params, 'type', defaultType)
        params = self.omit(params, 'type')
        method = market['type'] + 'GetInstrumentsInstrumentId' + type
        if type == 'Candles':
            if since is not None:
                if limit is not None:
                    request['end'] = self.iso8601(self.sum(since, limit * duration * 1000))
                request['start'] = self.iso8601(since)
            else:
                if limit is not None:
                    now = self.milliseconds()
                    request['start'] = self.iso8601(now - limit * duration * 1000)
                    request['end'] = self.iso8601(now)
        elif type == 'HistoryCandles':
            if market['option']:
                raise NotSupported(self.id + ' fetchOHLCV() does not have ' + type + ' for ' + market['type'] + ' markets')
            if since is not None:
                if limit is None:
                    limit = 300  # default
                request['start'] = self.iso8601(self.sum(since, limit * duration * 1000))
                request['end'] = self.iso8601(since)
            else:
                if limit is not None:
                    now = self.milliseconds()
                    request['end'] = self.iso8601(now - limit * duration * 1000)
                    request['start'] = self.iso8601(now)
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot markets
        #
        #     [
        #         {
        #             close: "0.02683401",
        #             high: "0.02683401",
        #             low: "0.02683401",
        #             open: "0.02683401",
        #             time: "2018-12-17T23:47:00.000Z",
        #             volume: "0"
        #         },
        #         {
        #             close: "0.02684545",
        #             high: "0.02685084",
        #             low: "0.02683312",
        #             open: "0.02683894",
        #             time: "2018-12-17T20:28:00.000Z",
        #             volume: "101.457222"
        #         }
        #     ]
        #
        # futures
        #
        #     [
        #         [
        #             1545090660000,
        #             0.3171,
        #             0.3174,
        #             0.3171,
        #             0.3173,
        #             1648,
        #             51930.38579450868
        #         ],
        #         [
        #             1545072720000,
        #             0.3159,
        #             0.3161,
        #             0.3144,
        #             0.3149,
        #             22886,
        #             725179.26172331
        #         ]
        #     ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_account_balance(self, response):
        #
        # account
        #
        #     [
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "BTC",
        #             hold:  0
        #         },
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "ETH",
        #             hold:  0
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "BTC",
        #             balance: "0.0000000497717339",
        #             available: "0.0000000497717339",
        #             holds: "0"
        #         },
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "ICN",
        #             balance: "0.00000000925",
        #             available: "0.00000000925",
        #             holds: "0"
        #         }
        #     ]
        #
        result = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        for i in range(0, len(response)):
            balance = response[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['total'] = self.safe_string(balance, 'balance')
            account['used'] = self.safe_string(balance, 'hold')
            account['free'] = self.safe_string(balance, 'available')
            result[code] = account
        return self.safe_balance(result)

    def parse_futures_balance(self, response):
        #
        #     {
        #         "info":{
        #             "eos":{
        #                 "auto_margin":"0",
        #                 "contracts": [
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"0",
        #                         "instrument_id":"EOS-USD-190329",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"0",
        #                         "realized_pnl":"0",
        #                         "unrealized_pnl":"0"
        #                     },
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"14.54895721",
        #                         "instrument_id":"EOS-USD-190628",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"10.64042157",
        #                         "realized_pnl":"-3.90853564",
        #                         "unrealized_pnl":"-0.259"
        #                     },
        #                 ],
        #                 "equity":"50.75220665",
        #                 "margin_mode":"fixed",
        #                 "total_avail_balance":"40.37069445"
        #             },
        #         }
        #     }
        #
        # their root field name is "info", so our info will contain their info
        result = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        info = self.safe_value(response, 'info', {})
        ids = list(info.keys())
        for i in range(0, len(ids)):
            id = ids[i]
            code = self.safe_currency_code(id)
            balance = self.safe_value(info, id, {})
            account = self.account()
            totalAvailBalance = self.safe_string(balance, 'total_avail_balance')
            if self.safe_string(balance, 'margin_mode') == 'fixed':
                contracts = self.safe_value(balance, 'contracts', [])
                free = totalAvailBalance
                for i in range(0, len(contracts)):
                    contract = contracts[i]
                    fixedBalance = self.safe_string(contract, 'fixed_balance')
                    realizedPnl = self.safe_string(contract, 'realized_pnl')
                    marginFrozen = self.safe_string(contract, 'margin_frozen')
                    marginForUnfilled = self.safe_string(contract, 'margin_for_unfilled')
                    margin = Precise.string_sub(Precise.string_sub(Precise.string_add(fixedBalance, realizedPnl), marginFrozen), marginForUnfilled)
                    free = Precise.string_add(free, margin)
                account['free'] = free
            else:
                realizedPnl = self.safe_string(balance, 'realized_pnl')
                unrealizedPnl = self.safe_string(balance, 'unrealized_pnl')
                marginFrozen = self.safe_string(balance, 'margin_frozen')
                marginForUnfilled = self.safe_string(balance, 'margin_for_unfilled')
                positive = Precise.string_add(Precise.string_add(totalAvailBalance, realizedPnl), unrealizedPnl)
                account['free'] = Precise.string_sub(Precise.string_sub(positive, marginFrozen), marginForUnfilled)
            # it may be incorrect to use total, free and used for swap accounts
            account['total'] = self.safe_string(balance, 'equity')
            result[code] = account
        return self.safe_balance(result)

    def parse_swap_balance(self, response):
        #
        #     {
        #         "info": [
        #             {
        #                 "equity":"3.0139",
        #                 "fixed_balance":"0.0000",
        #                 "instrument_id":"EOS-USD-SWAP",
        #                 "margin":"0.5523",
        #                 "margin_frozen":"0.0000",
        #                 "margin_mode":"crossed",
        #                 "margin_ratio":"1.0913",
        #                 "realized_pnl":"-0.0006",
        #                 "timestamp":"2019-03-25T03:46:10.336Z",
        #                 "total_avail_balance":"3.0000",
        #                 "unrealized_pnl":"0.0145"
        #             }
        #         ]
        #     }
        #
        # their root field name is "info", so our info will contain their info
        result = {'info': response}
        timestamp = None
        info = self.safe_value(response, 'info', [])
        for i in range(0, len(info)):
            balance = info[i]
            marketId = self.safe_string(balance, 'instrument_id')
            symbol = self.safe_symbol(marketId)
            balanceTimestamp = self.parse8601(self.safe_string(balance, 'timestamp'))
            timestamp = balanceTimestamp if (timestamp is None) else max(timestamp, balanceTimestamp)
            account = self.account()
            # it may be incorrect to use total, free and used for swap accounts
            account['total'] = self.safe_string(balance, 'equity')
            account['free'] = self.safe_string(balance, 'total_avail_balance')
            result[symbol] = account
        result['timestamp'] = timestamp
        result['datetime'] = self.iso8601(timestamp)
        return self.safe_balance(result)

    async def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        defaultType = self.safe_string_2(self.options, 'fetchBalance', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " fetchBalance() requires a type parameter(one of 'account', 'spot', 'futures', 'swap')")
        await self.load_markets()
        suffix = 'Wallet' if (type == 'account') else 'Accounts'
        method = type + 'Get' + suffix
        query = self.omit(params, 'type')
        response = await getattr(self, method)(query)
        #
        # account
        #
        #     [
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "BTC",
        #             hold:  0
        #         },
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "ETH",
        #             hold:  0
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "BTC",
        #             balance: "0.0000000497717339",
        #             available: "0.0000000497717339",
        #             holds: "0"
        #         },
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "ICN",
        #             balance: "0.00000000925",
        #             available: "0.00000000925",
        #             holds: "0"
        #         }
        #     ]
        #
        #
        # futures
        #
        #     {
        #         "info":{
        #             "eos":{
        #                 "auto_margin":"0",
        #                 "contracts": [
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"0",
        #                         "instrument_id":"EOS-USD-190329",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"0",
        #                         "realized_pnl":"0",
        #                         "unrealized_pnl":"0"
        #                     },
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"14.54895721",
        #                         "instrument_id":"EOS-USD-190628",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"10.64042157",
        #                         "realized_pnl":"-3.90853564",
        #                         "unrealized_pnl":"-0.259"
        #                     },
        #                 ],
        #                 "equity":"50.75220665",
        #                 "margin_mode":"fixed",
        #                 "total_avail_balance":"40.37069445"
        #             },
        #         }
        #     }
        #
        # swap
        #
        #     {
        #         "info": [
        #             {
        #                 "equity":"3.0139",
        #                 "fixed_balance":"0.0000",
        #                 "instrument_id":"EOS-USD-SWAP",
        #                 "margin":"0.5523",
        #                 "margin_frozen":"0.0000",
        #                 "margin_mode":"crossed",
        #                 "margin_ratio":"1.0913",
        #                 "realized_pnl":"-0.0006",
        #                 "timestamp":"2019-03-25T03:46:10.336Z",
        #                 "total_avail_balance":"3.0000",
        #                 "unrealized_pnl":"0.0145"
        #             }
        #         ]
        #     }
        #
        return self.parse_balance_by_type(type, response)

    def parse_balance_by_type(self, type, response):
        if (type == 'account') or (type == 'spot'):
            return self.parse_account_balance(response)
        elif type == 'futures':
            return self.parse_futures_balance(response)
        elif type == 'swap':
            return self.parse_swap_balance(response)
        raise NotSupported(self.id + " fetchBalance does not support the '" + type + "' type(the type must be one of 'account', 'spot', 'futures', 'swap')")

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
        create a trade order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'instrument_id': market['id'],
            # 'client_oid': 'abcdef1234567890',  # [a-z0-9]{1,32}
            # 'order_type': '0',  # 0 = Normal limit order, 1 = Post only, 2 = Fill Or Kill, 3 = Immediatel Or Cancel, 4 = Market for futures only
        }
        clientOrderId = self.safe_string_2(params, 'client_oid', 'clientOrderId')
        if clientOrderId is not None:
            request['client_oid'] = clientOrderId
            params = self.omit(params, ['client_oid', 'clientOrderId'])
        method = None
        if market['futures'] or market['swap']:
            size = self.number_to_string(amount) if market['futures'] else self.amount_to_precision(symbol, amount)
            request = self.extend(request, {
                'type': type,  # 1:open long 2:open short 3:close long 4:close short for futures
                'size': size,
                # 'match_price': '0',  # Order at best counter party price?(0:no 1:yes). The default is 0. If it is set as 1, the price parameter will be ignored. When posting orders at best bid price, order_type can only be 0(regular order).
            })
            orderType = self.safe_string(params, 'order_type')
            # order_type == '4' means a market order
            isMarketOrder = (type == 'market') or (orderType == '4')
            if isMarketOrder:
                request['order_type'] = '4'
            else:
                request['price'] = self.price_to_precision(symbol, price)
            if market['futures']:
                request['leverage'] = '10'  # or '20'
            method = market['type'] + 'PostOrder'
        else:
            request = self.extend(request, {
                'side': side,
                'type': type,  # limit/market
            })
            if type == 'limit':
                request['price'] = self.price_to_precision(symbol, price)
                request['size'] = self.amount_to_precision(symbol, amount)
            elif type == 'market':
                # for market buy it requires the amount of quote currency to spend
                if side == 'buy':
                    notional = self.safe_number(params, 'notional')
                    createMarketBuyOrderRequiresPrice = self.safe_value(self.options, 'createMarketBuyOrderRequiresPrice', True)
                    if createMarketBuyOrderRequiresPrice:
                        if price is not None:
                            if notional is None:
                                notional = amount * price
                        elif notional is None:
                            raise InvalidOrder(self.id + " createOrder() requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = False and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter(the exchange-specific behaviour)")
                    else:
                        notional = amount if (notional is None) else notional
                    request['notional'] = self.cost_to_precision(symbol, notional)
                else:
                    request['size'] = self.amount_to_precision(symbol, amount)
            method = 'spotPostOrders'
        response = await getattr(self, method)(self.extend(request, params))
        #
        #     {
        #         "client_oid":"oktspot79",
        #         "error_code":"",
        #         "error_message":"",
        #         "order_id":"2510789768709120",
        #         "result":true
        #     }
        #
        order = self.parse_order(response, market)
        return self.extend(order, {
            'type': type,
            'side': side,
        })

    async def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        type = None
        if market['futures'] or market['swap']:
            type = market['type']
        else:
            defaultType = self.safe_string_2(self.options, 'cancelOrder', 'defaultType', market['type'])
            type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " cancelOrder() requires a type parameter(one of 'spot', 'futures', 'swap').")
        method = type + 'PostCancelOrder'
        request = {
            'instrument_id': market['id'],
        }
        if market['futures'] or market['swap']:
            method += 'InstrumentId'
        else:
            method += 's'
        clientOrderId = self.safe_string_2(params, 'client_oid', 'clientOrderId')
        if clientOrderId is not None:
            method += 'ClientOid'
            request['client_oid'] = clientOrderId
        else:
            method += 'OrderId'
            request['order_id'] = id
        query = self.omit(params, ['type', 'client_oid', 'clientOrderId'])
        response = await getattr(self, method)(self.extend(request, query))
        result = response if ('result' in response) else self.safe_value(response, market['id'], {})
        #
        # spot
        #
        #     {
        #         "btc-usdt": [
        #             {
        #                 "result":true,
        #                 "client_oid":"a123",
        #                 "order_id": "2510832677225473"
        #             }
        #         ]
        #     }
        #
        # futures, swap
        #
        #     {
        #         "result": True,
        #         "client_oid": "oktfuture10",  # missing if requested by order_id
        #         "order_id": "2517535534836736",
        #         "instrument_id": "EOS-USD-190628"
        #     }
        #
        return self.parse_order(result, market)

    def parse_order_status(self, status):
        statuses = {
            '-2': 'failed',
            '-1': 'canceled',
            '0': 'open',
            '1': 'open',
            '2': 'closed',
            '3': 'open',
            '4': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def parse_order_side(self, side):
        sides = {
            '1': 'buy',  # open long
            '2': 'sell',  # open short
            '3': 'sell',  # close long
            '4': 'buy',  # close short
        }
        return self.safe_string(sides, side, side)

    def parse_order(self, order, market=None):
        #
        # createOrder
        #
        #     {
        #         "client_oid":"oktspot79",
        #         "error_code":"",
        #         "error_message":"",
        #         "order_id":"2510789768709120",
        #         "result":true
        #     }
        #
        # cancelOrder
        #
        #     {
        #         "result": True,
        #         "client_oid": "oktfuture10",  # missing if requested by order_id
        #         "order_id": "2517535534836736",
        #         # instrument_id is missing for spot/margin orders
        #         # available in futures and swap orders only
        #         "instrument_id": "EOS-USD-190628",
        #     }
        #
        # fetchOrder, fetchOrdersByState, fetchOpenOrders, fetchClosedOrders
        #
        #     # spot orders
        #
        #     {
        #         "client_oid":"oktspot76",
        #         "created_at":"2019-03-18T07:26:49.000Z",
        #         "filled_notional":"3.9734",
        #         "filled_size":"0.001",  # filled_qty in futures and swap orders
        #         "funds":"",  # self is most likely the same as notional
        #         "instrument_id":"BTC-USDT",
        #         "notional":"",
        #         "order_id":"2500723297813504",
        #         "order_type":"0",
        #         "price":"4013",
        #         "product_id":"BTC-USDT",  # missing in futures and swap orders
        #         "side":"buy",
        #         "size":"0.001",
        #         "status":"filled",
        #         "state": "2",
        #         "timestamp":"2019-03-18T07:26:49.000Z",
        #         "type":"limit"
        #     }
        #
        #     # futures and swap orders
        #
        #     {
        #         "instrument_id":"EOS-USD-190628",
        #         "size":"10",
        #         "timestamp":"2019-03-20T10:04:55.000Z",
        #         "filled_qty":"10",  # filled_size in spot orders
        #         "fee":"-0.00841043",
        #         "order_id":"2512669605501952",
        #         "price":"3.668",
        #         "price_avg":"3.567",  # missing in spot orders
        #         "status":"2",
        #         "state": "2",
        #         "type":"4",
        #         "contract_val":"10",
        #         "leverage":"10",  # missing in swap, spot orders
        #         "client_oid":"",
        #         "pnl":"1.09510794",  # missing in swap, spot orders
        #         "order_type":"0"
        #     }
        #
        id = self.safe_string(order, 'order_id')
        timestamp = self.parse8601(self.safe_string(order, 'timestamp'))
        side = self.safe_string(order, 'side')
        type = self.safe_string(order, 'type')
        if (side != 'buy') and (side != 'sell'):
            side = self.parse_order_side(type)
        marketId = self.safe_string(order, 'instrument_id')
        market = self.safe_market(marketId, market)
        amount = self.safe_string(order, 'size')
        filled = self.safe_string_2(order, 'filled_size', 'filled_qty')
        remaining = None
        if amount is not None:
            if filled is not None:
                amount = Precise.string_max(amount, filled)
                remaining = Precise.string_max('0', Precise.string_sub(amount, filled))
        if type == 'market':
            remaining = '0'
        cost = self.safe_string_2(order, 'filled_notional', 'funds')
        price = self.safe_string(order, 'price')
        average = self.safe_string(order, 'price_avg')
        if cost is None:
            if filled is not None and average is not None:
                cost = Precise.string_mul(average, filled)
        else:
            if (average is None) and (filled is not None) and Precise.string_gt(filled, '0'):
                average = Precise.string_div(cost, filled)
        status = self.parse_order_status(self.safe_string(order, 'state'))
        feeCost = self.safe_number(order, 'fee')
        fee = None
        if feeCost is not None:
            feeCurrency = None
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        clientOrderId = self.safe_string(order, 'client_oid')
        if (clientOrderId is not None) and (len(clientOrderId) < 1):
            clientOrderId = None  # fix empty clientOrderId string
        stopPrice = self.safe_number(order, 'trigger_price')
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': market['symbol'],
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': stopPrice,
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': None,
        }, market)

    async def fetch_order(self, id, symbol=None, params={}):
        """
        fetches information on an order made by the user
        :param str symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        defaultType = self.safe_string_2(self.options, 'fetchOrder', 'defaultType', market['type'])
        type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " fetchOrder() requires a type parameter(one of 'spot', 'futures', 'swap').")
        instrumentId = 'InstrumentId' if (market['futures'] or market['swap']) else ''
        method = type + 'GetOrders' + instrumentId
        request = {
            'instrument_id': market['id'],
            # 'client_oid': 'abcdef12345',  # optional, [a-z0-9]{1,32}
            # 'order_id': id,
        }
        clientOid = self.safe_string(params, 'client_oid')
        if clientOid is not None:
            method += 'ClientOid'
            request['client_oid'] = clientOid
        else:
            method += 'OrderId'
            request['order_id'] = id
        query = self.omit(params, 'type')
        response = await getattr(self, method)(self.extend(request, query))
        #
        # spot
        #
        #     {
        #         "client_oid":"oktspot70",
        #         "created_at":"2019-03-15T02:52:56.000Z",
        #         "filled_notional":"3.8886",
        #         "filled_size":"0.001",
        #         "funds":"",
        #         "instrument_id":"BTC-USDT",
        #         "notional":"",
        #         "order_id":"2482659399697408",
        #         "order_type":"0",
        #         "price":"3927.3",
        #         "product_id":"BTC-USDT",
        #         "side":"buy",
        #         "size":"0.001",
        #         "status":"filled",
        #         "state": "2",
        #         "timestamp":"2019-03-15T02:52:56.000Z",
        #         "type":"limit"
        #     }
        #
        # futures, swap
        #
        #     {
        #         "instrument_id":"EOS-USD-190628",
        #         "size":"10",
        #         "timestamp":"2019-03-20T02:46:38.000Z",
        #         "filled_qty":"10",
        #         "fee":"-0.0080819",
        #         "order_id":"2510946213248000",
        #         "price":"3.712",
        #         "price_avg":"3.712",
        #         "status":"2",
        #         "state": "2",
        #         "type":"2",
        #         "contract_val":"10",
        #         "leverage":"10",
        #         "client_oid":"",  # missing in swap orders
        #         "pnl":"0",  # missing in swap orders
        #         "order_type":"0"
        #     }
        #
        return self.parse_order(response)

    async def fetch_orders_by_state(self, state, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrdersByState() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        type = None
        if market['futures'] or market['swap']:
            type = market['type']
        else:
            defaultType = self.safe_string_2(self.options, 'fetchOrder', 'defaultType', market['type'])
            type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " fetchOrdersByState() requires a type parameter(one of 'spot', 'futures', 'swap').")
        request = {
            'instrument_id': market['id'],
            # '-2': failed,
            # '-1': cancelled,
            #  '0': open ,
            #  '1': partially filled,
            #  '2': fully filled,
            #  '3': submitting,
            #  '4': cancelling,
            #  '6': incomplete（open+partially filled),
            #  '7': complete（cancelled+fully filled),
            'state': state,
        }
        method = type + 'GetOrders'
        if market['futures'] or market['swap']:
            method += 'InstrumentId'
        query = self.omit(params, 'type')
        response = await getattr(self, method)(self.extend(request, query))
        #
        # spot
        #
        #     [
        #         # in fact, self documented API response does not correspond
        #         # to their actual API response for spot markets
        #         # OKEX v3 API returns a plain array of orders(see below)
        #         [
        #             {
        #                 "client_oid":"oktspot76",
        #                 "created_at":"2019-03-18T07:26:49.000Z",
        #                 "filled_notional":"3.9734",
        #                 "filled_size":"0.001",
        #                 "funds":"",
        #                 "instrument_id":"BTC-USDT",
        #                 "notional":"",
        #                 "order_id":"2500723297813504",
        #                 "order_type":"0",
        #                 "price":"4013",
        #                 "product_id":"BTC-USDT",
        #                 "side":"buy",
        #                 "size":"0.001",
        #                 "status":"filled",
        #                 "state": "2",
        #                 "timestamp":"2019-03-18T07:26:49.000Z",
        #                 "type":"limit"
        #             },
        #         ],
        #         {
        #             "before":"2500723297813504",
        #             "after":"2500650881647616"
        #         }
        #     ]
        #
        # futures, swap
        #
        #     {
        #         "result":true,  # missing in swap orders
        #         "order_info": [
        #             {
        #                 "instrument_id":"EOS-USD-190628",
        #                 "size":"10",
        #                 "timestamp":"2019-03-20T10:04:55.000Z",
        #                 "filled_qty":"10",
        #                 "fee":"-0.00841043",
        #                 "order_id":"2512669605501952",
        #                 "price":"3.668",
        #                 "price_avg":"3.567",
        #                 "status":"2",
        #                 "state": "2",
        #                 "type":"4",
        #                 "contract_val":"10",
        #                 "leverage":"10",  # missing in swap orders
        #                 "client_oid":"",
        #                 "pnl":"1.09510794",  # missing in swap orders
        #                 "order_type":"0"
        #             },
        #         ]
        #     }
        #
        orders = None
        if market['swap'] or market['futures']:
            orders = self.safe_value(response, 'order_info', [])
        else:
            orders = response
            responseLength = len(response)
            if responseLength < 1:
                return []
            # in fact, self documented API response does not correspond
            # to their actual API response for spot markets
            # OKEX v3 API returns a plain array of orders
            if responseLength > 1:
                before = self.safe_value(response[1], 'before')
                if before is not None:
                    orders = response[0]
        return self.parse_orders(orders, market, since, limit)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all unfilled currently open orders
        :param str symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch open orders for
        :param int|None limit: the maximum number of  open orders structures to retrieve
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        # '-2': failed,
        # '-1': cancelled,
        #  '0': open ,
        #  '1': partially filled,
        #  '2': fully filled,
        #  '3': submitting,
        #  '4': cancelling,
        #  '6': incomplete（open+partially filled),
        #  '7': complete（cancelled+fully filled),
        return await self.fetch_orders_by_state('6', symbol, since, limit, params)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple closed orders made by the user
        :param str symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        # '-2': failed,
        # '-1': cancelled,
        #  '0': open ,
        #  '1': partially filled,
        #  '2': fully filled,
        #  '3': submitting,
        #  '4': cancelling,
        #  '6': incomplete（open+partially filled),
        #  '7': complete（cancelled+fully filled),
        return await self.fetch_orders_by_state('7', symbol, since, limit, params)

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        #         currency: 'eth'
        #         tag: 'abcde12345',  # will be missing if the token does not require a deposit tag
        #         payment_id: 'abcde12345',  # will not be returned if the token does not require a payment_id
        #         # can_deposit: 1,  # 0 or 1, documented but missing
        #         # can_withdraw: 1,  # 0 or 1, documented but missing
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string_2(depositAddress, 'tag', 'payment_id')
        tag = self.safe_string_2(depositAddress, 'memo', 'Memo', tag)
        currencyId = self.safe_string(depositAddress, 'currency')
        code = self.safe_currency_code(currencyId)
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': depositAddress,
        }

    async def fetch_deposit_address(self, code, params={}):
        """
        fetch the deposit address for a currency associated with self account
        :param str code: unified currency code
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: an `address structure <https://docs.ccxt.com/en/latest/manual.html#address-structure>`
        """
        await self.load_markets()
        parts = code.split('-')
        currency = self.currency(parts[0])
        request = {
            'currency': currency['id'],
        }
        response = await self.accountGetDepositAddress(self.extend(request, params))
        #
        #     [
        #         {
        #             address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        #             currency: 'eth'
        #         }
        #     ]
        #
        addressesByCode = self.parse_deposit_addresses(response)
        address = self.safe_value(addressesByCode, code)
        if address is None:
            raise InvalidAddress(self.id + ' fetchDepositAddress() cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first')
        return address

    async def transfer(self, code, amount, fromAccount, toAccount, params={}):
        """
        transfer currency internally between wallets on the same account
        :param str code: unified currency code
        :param float amount: amount to transfer
        :param str fromAccount: account to transfer from
        :param str toAccount: account to transfer to
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: a `transfer structure <https://docs.ccxt.com/en/latest/manual.html#transfer-structure>`
        """
        await self.load_markets()
        currency = self.currency(code)
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        fromId = self.safe_string(accountsByType, fromAccount, fromAccount)
        toId = self.safe_string(accountsByType, toAccount, toAccount)
        request = {
            'amount': self.currency_to_precision(code, amount),
            'currency': currency['id'],
            'from': fromId,  # 1 spot, 6 funding
            'to': toId,  # 1 spot, 6 funding
            'type': '0',  # 0 Transfer between accounts in the main account/sub_account, 1 main account to sub_account, 2 sub_account to main account
        }
        if fromId == 'main':
            request['type'] = '1'
            request['sub_account'] = toId
            request['to'] = '0'
        elif toId == 'main':
            request['type'] = '2'
            request['sub_account'] = fromId
            request['from'] = '0'
            request['to'] = '6'
        response = await self.accountPostTransfer(self.extend(request, params))
        #
        #      {
        #          "transfer_id": "754147",
        #          "currency": "ETC",
        #          "from": "6",
        #          "amount": "0.1",
        #          "to": "1",
        #          "result": True
        #      }
        #
        return self.parse_transfer(response, currency)

    def parse_transfer(self, transfer, currency=None):
        #
        #      {
        #          "transfer_id": "754147",
        #          "currency": "ETC",
        #          "from": "6",
        #          "amount": "0.1",
        #          "to": "1",
        #          "result": True
        #      }
        #
        accountsById = self.safe_value(self.options, 'accountsById', {})
        return {
            'info': transfer,
            'id': self.safe_string(transfer, 'transfer_id'),
            'timestamp': None,
            'datetime': None,
            'currency': self.safe_currency_code(self.safe_string(transfer, 'currency'), currency),
            'amount': self.safe_number(transfer, 'amount'),
            'fromAccount': self.safe_string(accountsById, self.safe_string(transfer, 'from')),
            'toAccount': self.safe_string(accountsById, self.safe_string(transfer, 'to')),
            'status': self.parse_transfer_status(self.safe_string(transfer, 'result')),
        }

    def parse_transfer_status(self, status):
        statuses = {
            'true': 'ok',
        }
        return self.safe_string(statuses, status, 'failed')

    async def withdraw(self, code, amount, address, tag=None, params={}):
        """
        make a withdrawal
        :param str code: unified currency code
        :param float amount: the amount to withdraw
        :param str address: the address to withdraw to
        :param str|None tag:
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: a `transaction structure <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        tag, params = self.handle_withdraw_tag_and_params(tag, params)
        self.check_address(address)
        await self.load_markets()
        currency = self.currency(code)
        if tag:
            address = address + ':' + tag
        fee = self.safe_string(params, 'fee')
        if fee is None:
            raise ArgumentsRequired(self.id + " withdraw() requires a 'fee' string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.")
        request = {
            'currency': currency['id'],
            'to_address': address,
            'destination': '4',  # 2 = OKCoin International, 3 = OKEx 4 = others
            'amount': self.number_to_string(amount),
            'fee': fee,  # str. Network transaction fee ≥ 0. Withdrawals to OKCoin or OKEx are fee-free, please set as 0. Withdrawal to external digital asset address requires network transaction fee.
        }
        if 'password' in params:
            request['trade_pwd'] = params['password']
        elif 'trade_pwd' in params:
            request['trade_pwd'] = params['trade_pwd']
        elif self.password:
            request['trade_pwd'] = self.password
        query = self.omit(params, ['fee', 'password', 'trade_pwd'])
        if not ('trade_pwd' in request):
            raise ExchangeError(self.id + ' withdraw() requires self.password set on the exchange instance or a password / trade_pwd parameter')
        response = await self.accountPostWithdrawal(self.extend(request, query))
        #
        #     {
        #         "amount":"0.1",
        #         "withdrawal_id":"67485",
        #         "currency":"btc",
        #         "result":true
        #     }
        #
        return self.parse_transaction(response, currency)

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        """
        fetch all deposits made to an account
        :param str|None code: unified currency code
        :param int|None since: the earliest time in ms to fetch deposits for
        :param int|None limit: the maximum number of deposits structures to retrieve
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        await self.load_markets()
        request = {}
        method = 'accountGetDepositHistory'
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
            method += 'Currency'
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit, params)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        """
        fetch all withdrawals made from an account
        :param str|None code: unified currency code
        :param int|None since: the earliest time in ms to fetch withdrawals for
        :param int|None limit: the maximum number of withdrawals structures to retrieve
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `transaction structures <https://docs.ccxt.com/en/latest/manual.html#transaction-structure>`
        """
        await self.load_markets()
        request = {}
        method = 'accountGetWithdrawalHistory'
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
            method += 'Currency'
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit, params)

    def parse_transaction_status(self, status):
        #
        # deposit statuses
        #
        #     {
        #         '0': 'waiting for confirmation',
        #         '1': 'confirmation account',
        #         '2': 'recharge success'
        #     }
        #
        # withdrawal statues
        #
        #     {
        #        '-3': 'pending cancel',
        #        '-2': 'cancelled',
        #        '-1': 'failed',
        #         '0': 'pending',
        #         '1': 'sending',
        #         '2': 'sent',
        #         '3': 'email confirmation',
        #         '4': 'manual confirmation',
        #         '5': 'awaiting identity confirmation'
        #     }
        #
        statuses = {
            '-3': 'pending',
            '-2': 'canceled',
            '-1': 'failed',
            '0': 'pending',
            '1': 'pending',
            '2': 'ok',
            '3': 'pending',
            '4': 'pending',
            '5': 'pending',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # withdraw
        #
        #     {
        #         "amount":"0.1",
        #         "withdrawal_id":"67485",
        #         "currency":"btc",
        #         "result":true
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #         amount: "4.72100000",
        #         withdrawal_id: "1729116",
        #         fee: "0.01000000eth",
        #         txid: "0xf653125bbf090bcfe4b5e8e7b8f586a9d87aa7de94598702758c0802b…",
        #         currency: "ETH",
        #         from: "7147338839",
        #         to: "0x26a3CB49578F07000575405a57888681249c35Fd",
        #         timestamp: "2018-08-17T07:03:42.000Z",
        #         status: "2"
        #     }
        #
        # fetchDeposits
        #
        #     {
        #         "amount": "4.19511659",
        #         "txid": "14c9a8c925647cdb7e5b2937ea9aefe2b29b2c273150ad3f44b3b8a4635ed437",
        #         "currency": "XMR",
        #         "from": "",
        #         "to": "48PjH3ksv1fiXniKvKvyH5UtFs5WhfS2Vf7U3TwzdRJtCc7HJWvCQe56dRahyhQyTAViXZ8Nzk4gQg6o4BJBMUoxNy8y8g7",
        #         "tag": "1234567",
        #         "deposit_id": 11571659, <-- we can use self
        #         "timestamp": "2019-10-01T14:54:19.000Z",
        #         "status": "2"
        #     }
        #
        type = None
        id = None
        address = None
        withdrawalId = self.safe_string(transaction, 'withdrawal_id')
        addressFrom = self.safe_string(transaction, 'from')
        addressTo = self.safe_string(transaction, 'to')
        tagTo = self.safe_string(transaction, 'tag')
        if withdrawalId is not None:
            type = 'withdrawal'
            id = withdrawalId
            address = addressTo
        else:
            # the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = self.safe_string_2(transaction, 'payment_id', 'deposit_id')
            type = 'deposit'
            address = addressTo
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId)
        amount = self.safe_number(transaction, 'amount')
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        txid = self.safe_string(transaction, 'txid')
        timestamp = self.parse8601(self.safe_string(transaction, 'timestamp'))
        feeCost = None
        if type == 'deposit':
            feeCost = 0
        else:
            if currencyId is not None:
                feeWithCurrencyId = self.safe_string(transaction, 'fee')
                if feeWithCurrencyId is not None:
                    # https://github.com/ccxt/ccxt/pull/5748
                    lowercaseCurrencyId = currencyId.lower()
                    feeWithoutCurrencyId = feeWithCurrencyId.replace(lowercaseCurrencyId, '')
                    feeCost = float(feeWithoutCurrencyId)
        # todo parse tags
        return {
            'info': transaction,
            'id': id,
            'currency': code,
            'amount': amount,
            'network': None,
            'addressFrom': addressFrom,
            'addressTo': addressTo,
            'address': address,
            'tagFrom': None,
            'tagTo': tagTo,
            'tag': tagTo,
            'status': status,
            'type': type,
            'updated': None,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def parse_my_trade(self, pair, market=None):
        # check that trading symbols match in both entries
        userTrade = self.safe_value(pair, 1)
        otherTrade = self.safe_value(pair, 0)
        firstMarketId = self.safe_string(otherTrade, 'instrument_id')
        secondMarketId = self.safe_string(userTrade, 'instrument_id')
        if firstMarketId != secondMarketId:
            raise NotSupported(self.id + ' parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help')
        marketId = firstMarketId
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        quoteId = market['quoteId']
        side = None
        amountString = None
        costString = None
        receivedCurrencyId = self.safe_string(userTrade, 'currency')
        feeCurrencyId = None
        if receivedCurrencyId == quoteId:
            side = self.safe_string(otherTrade, 'side')
            amountString = self.safe_string(otherTrade, 'size')
            costString = self.safe_string(userTrade, 'size')
            feeCurrencyId = self.safe_string(otherTrade, 'currency')
        else:
            side = self.safe_string(userTrade, 'side')
            amountString = self.safe_string(userTrade, 'size')
            costString = self.safe_string(otherTrade, 'size')
            feeCurrencyId = self.safe_string(userTrade, 'currency')
        id = self.safe_string(userTrade, 'trade_id')
        priceString = self.safe_string(userTrade, 'price')
        feeCostFirstString = self.safe_string(otherTrade, 'fee')
        feeCostSecondString = self.safe_string(userTrade, 'fee')
        feeCurrencyCodeFirst = self.safe_currency_code(self.safe_string(otherTrade, 'currency'))
        feeCurrencyCodeSecond = self.safe_currency_code(self.safe_string(userTrade, 'currency'))
        fee = None
        fees = None
        # fee is either a positive number(invitation rebate)
        # or a negative number(transaction fee deduction)
        # therefore we need to invert the fee
        # more about it https://github.com/ccxt/ccxt/issues/5909
        if (feeCostFirstString is not None) and not Precise.string_equals(feeCostFirstString, '0'):
            if (feeCostSecondString is not None) and not Precise.string_equals(feeCostSecondString, '0'):
                fees = [
                    {
                        'cost': Precise.string_neg(feeCostFirstString),
                        'currency': feeCurrencyCodeFirst,
                    },
                    {
                        'cost': Precise.string_neg(feeCostSecondString),
                        'currency': feeCurrencyCodeSecond,
                    },
                ]
            else:
                fee = {
                    'cost': Precise.string_neg(feeCostFirstString),
                    'currency': feeCurrencyCodeFirst,
                }
        elif (feeCostSecondString is not None) and not Precise.string_equals(feeCostSecondString, '0'):
            fee = {
                'cost': Precise.string_neg(feeCostSecondString),
                'currency': feeCurrencyCodeSecond,
            }
        else:
            fee = {
                'cost': '0',
                'currency': self.safe_currency_code(feeCurrencyId),
            }
        #
        # simplified structures to show the underlying semantics
        #
        #     # market/limit sell
        #
        #     {
        #         "currency":"USDT",
        #         "fee":"-0.04647925",  # ←--- fee in received quote currency
        #         "price":"129.13",  # ←------ price
        #         "size":"30.98616393",  # ←-- cost
        #     },
        #     {
        #         "currency":"ETH",
        #         "fee":"0",
        #         "price":"129.13",
        #         "size":"0.23996099",  # ←--- amount
        #     },
        #
        #     # market/limit buy
        #
        #     {
        #         "currency":"ETH",
        #         "fee":"-0.00036049",  # ←--- fee in received base currency
        #         "price":"129.16",  # ←------ price
        #         "size":"0.240322",  # ←----- amount
        #     },
        #     {
        #         "currency":"USDT",
        #         "fee":"0",
        #         "price":"129.16",
        #         "size":"31.03998952",  # ←-- cost
        #     }
        #
        timestamp = self.parse8601(self.safe_string_2(userTrade, 'timestamp', 'created_at'))
        takerOrMaker = self.safe_string_2(userTrade, 'exec_type', 'liquidity')
        if takerOrMaker == 'M':
            takerOrMaker = 'maker'
        elif takerOrMaker == 'T':
            takerOrMaker = 'taker'
        orderId = self.safe_string(userTrade, 'order_id')
        return self.safe_trade({
            'info': pair,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': orderId,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': priceString,
            'amount': amountString,
            'cost': costString,
            'fee': fee,
            'fees': fees,
        }, market)

    def parse_my_trades(self, trades, market=None, since=None, limit=None, params={}):
        grouped = self.group_by(trades, 'trade_id')
        tradeIds = list(grouped.keys())
        result = []
        for i in range(0, len(tradeIds)):
            tradeId = tradeIds[i]
            pair = grouped[tradeId]
            # make sure it has exactly 2 trades, no more, no less
            numTradesInPair = len(pair)
            if numTradesInPair == 2:
                trade = self.parse_my_trade(pair)
                result.append(trade)
        market = self.safe_market(None, market)
        return self.filter_by_symbol_since_limit(result, market['symbol'], since, limit)

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all trades made by the user
        :param str symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html#trade-structure>`
        """
        # okex actually returns ledger entries instead of fills here, so each fill in the order
        # is represented by two trades with opposite buy/sell sides, not one :\
        # self aspect renders the 'fills' endpoint unusable for fetchOrderTrades
        # until either OKEX fixes the API or we workaround self on our side somehow
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        if (limit is not None) and (limit > 100):
            limit = 100
        request = {
            'instrument_id': market['id'],
            # 'order_id': id,  # string
            # 'after': '1',  # pagination of data to return records earlier than the requested ledger_id
            # 'before': '1',  # P=pagination of data to return records newer than the requested ledger_id
            # 'limit': limit,  # optional, number of results per request, default = maximum = 100
        }
        defaultType = self.safe_string_2(self.options, 'fetchMyTrades', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        query = self.omit(params, 'type')
        method = type + 'GetFills'
        response = await getattr(self, method)(self.extend(request, query))
        #
        #     [
        #         # sell
        #         {
        #             "created_at":"2020-03-29T11:55:25.000Z",
        #             "currency":"USDT",
        #             "exec_type":"T",
        #             "fee":"-0.04647925",
        #             "instrument_id":"ETH-USDT",
        #             "ledger_id":"10562924353",
        #             "liquidity":"T",
        #             "order_id":"4636470489136128",
        #             "price":"129.13",
        #             "product_id":"ETH-USDT",
        #             "side":"buy",
        #             "size":"30.98616393",
        #             "timestamp":"2020-03-29T11:55:25.000Z",
        #             "trade_id":"18551601"
        #         },
        #         {
        #             "created_at":"2020-03-29T11:55:25.000Z",
        #             "currency":"ETH",
        #             "exec_type":"T",
        #             "fee":"0",
        #             "instrument_id":"ETH-USDT",
        #             "ledger_id":"10562924352",
        #             "liquidity":"T",
        #             "order_id":"4636470489136128",
        #             "price":"129.13",
        #             "product_id":"ETH-USDT",
        #             "side":"sell",
        #             "size":"0.23996099",
        #             "timestamp":"2020-03-29T11:55:25.000Z",
        #             "trade_id":"18551601"
        #         },
        #         # buy
        #         {
        #             "created_at":"2020-03-29T11:55:16.000Z",
        #             "currency":"ETH",
        #             "exec_type":"T",
        #             "fee":"-0.00036049",
        #             "instrument_id":"ETH-USDT",
        #             "ledger_id":"10562922669",
        #             "liquidity":"T",
        #             "order_id": "4636469894136832",
        #             "price":"129.16",
        #             "product_id":"ETH-USDT",
        #             "side":"buy",
        #             "size":"0.240322",
        #             "timestamp":"2020-03-29T11:55:16.000Z",
        #             "trade_id":"18551600"
        #         },
        #         {
        #             "created_at":"2020-03-29T11:55:16.000Z",
        #             "currency":"USDT",
        #             "exec_type":"T",
        #             "fee":"0",
        #             "instrument_id":"ETH-USDT",
        #             "ledger_id":"10562922668",
        #             "liquidity":"T",
        #             "order_id":"4636469894136832",
        #             "price":"129.16",
        #             "product_id":"ETH-USDT",
        #             "side":"sell",
        #             "size":"31.03998952",
        #             "timestamp":"2020-03-29T11:55:16.000Z",
        #             "trade_id":"18551600"
        #         }
        #     ]
        #
        return self.parse_my_trades(response, market, since, limit, params)

    async def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        """
        fetch all the trades made from a single order
        :param str id: order id
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades to retrieve
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html#trade-structure>`
        """
        request = {
            # 'instrument_id': market['id'],
            'order_id': id,
            # 'after': '1',  # return the page after the specified page number
            # 'before': '1',  # return the page before the specified page number
            # 'limit': limit,  # optional, number of results per request, default = maximum = 100
        }
        return await self.fetch_my_trades(symbol, since, limit, self.extend(request, params))

    async def fetch_position(self, symbol, params={}):
        """
        fetch data on a single open contract trade position
        :param str symbol: unified market symbol of the market the position is held in, default is None
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: a `position structure <https://docs.ccxt.com/en/latest/manual.html#position-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        method = None
        request = {
            'instrument_id': market['id'],
            # 'order_id': id,  # string
            # 'after': '1',  # pagination of data to return records earlier than the requested ledger_id
            # 'before': '1',  # P=pagination of data to return records newer than the requested ledger_id
            # 'limit': limit,  # optional, number of results per request, default = maximum = 100
        }
        type = market['type']
        if (type == 'futures') or (type == 'swap'):
            method = type + 'GetInstrumentIdPosition'
        elif type == 'option':
            underlying = self.safe_string(params, 'underlying')
            if underlying is None:
                raise ArgumentsRequired(self.id + ' fetchPosition() requires an underlying parameter for ' + type + ' market ' + symbol)
            method = type + 'GetUnderlyingPosition'
        else:
            raise NotSupported(self.id + ' fetchPosition() does not support ' + type + ' market ' + symbol + ', supported market types are futures, swap or option')
        response = await getattr(self, method)(self.extend(request, params))
        #
        # futures
        #
        #     crossed margin mode
        #
        #     {
        #         "result": True,
        #         "holding": [
        #             {
        #                 "long_qty": "2",
        #                 "long_avail_qty": "2",
        #                 "long_avg_cost": "8260",
        #                 "long_settlement_price": "8260",
        #                 "realised_pnl": "0.00020928",
        #                 "short_qty": "2",
        #                 "short_avail_qty": "2",
        #                 "short_avg_cost": "8259.99",
        #                 "short_settlement_price": "8259.99",
        #                 "liquidation_price": "113.81",
        #                 "instrument_id": "BTC-USD-191227",
        #                 "leverage": "10",
        #                 "created_at": "2019-09-25T07:58:42.129Z",
        #                 "updated_at": "2019-10-08T14:02:51.029Z",
        #                 "margin_mode": "crossed",
        #                 "short_margin": "0.00242197",
        #                 "short_pnl": "6.63E-6",
        #                 "short_pnl_ratio": "0.002477997",
        #                 "short_unrealised_pnl": "6.63E-6",
        #                 "long_margin": "0.00242197",
        #                 "long_pnl": "-6.65E-6",
        #                 "long_pnl_ratio": "-0.002478",
        #                 "long_unrealised_pnl": "-6.65E-6",
        #                 "long_settled_pnl": "0",
        #                 "short_settled_pnl": "0",
        #                 "last": "8257.57"
        #             }
        #         ],
        #         "margin_mode": "crossed"
        #     }
        #
        #     fixed margin mode
        #
        #     {
        #         "result": True,
        #         "holding": [
        #             {
        #                 "long_qty": "4",
        #                 "long_avail_qty": "4",
        #                 "long_margin": "0.00323844",
        #                 "long_liqui_price": "7762.09",
        #                 "long_pnl_ratio": "0.06052306",
        #                 "long_avg_cost": "8234.43",
        #                 "long_settlement_price": "8234.43",
        #                 "realised_pnl": "-0.00000296",
        #                 "short_qty": "2",
        #                 "short_avail_qty": "2",
        #                 "short_margin": "0.00241105",
        #                 "short_liqui_price": "9166.74",
        #                 "short_pnl_ratio": "0.03318052",
        #                 "short_avg_cost": "8295.13",
        #                 "short_settlement_price": "8295.13",
        #                 "instrument_id": "BTC-USD-191227",
        #                 "long_leverage": "15",
        #                 "short_leverage": "10",
        #                 "created_at": "2019-09-25T07:58:42.129Z",
        #                 "updated_at": "2019-10-08T13:12:09.438Z",
        #                 "margin_mode": "fixed",
        #                 "short_margin_ratio": "0.10292507",
        #                 "short_maint_margin_ratio": "0.005",
        #                 "short_pnl": "7.853E-5",
        #                 "short_unrealised_pnl": "7.853E-5",
        #                 "long_margin_ratio": "0.07103743",
        #                 "long_maint_margin_ratio": "0.005",
        #                 "long_pnl": "1.9841E-4",
        #                 "long_unrealised_pnl": "1.9841E-4",
        #                 "long_settled_pnl": "0",
        #                 "short_settled_pnl": "0",
        #                 "last": "8266.99"
        #             }
        #         ],
        #         "margin_mode": "fixed"
        #     }
        #
        # swap
        #
        #     crossed margin mode
        #
        #     {
        #         "margin_mode": "crossed",
        #         "timestamp": "2019-09-27T03:49:02.018Z",
        #         "holding": [
        #             {
        #                 "avail_position": "3",
        #                 "avg_cost": "59.49",
        #                 "instrument_id": "LTC-USD-SWAP",
        #                 "last": "55.98",
        #                 "leverage": "10.00",
        #                 "liquidation_price": "4.37",
        #                 "maint_margin_ratio": "0.0100",
        #                 "margin": "0.0536",
        #                 "position": "3",
        #                 "realized_pnl": "0.0000",
        #                 "unrealized_pnl": "0",
        #                 "settled_pnl": "-0.0330",
        #                 "settlement_price": "55.84",
        #                 "side": "long",
        #                 "timestamp": "2019-09-27T03:49:02.018Z"
        #             },
        #         ]
        #     }
        #
        #     fixed margin mode
        #
        #     {
        #         "margin_mode": "fixed",
        #         "timestamp": "2019-09-27T03:47:37.230Z",
        #         "holding": [
        #             {
        #                 "avail_position": "20",
        #                 "avg_cost": "8025.0",
        #                 "instrument_id": "BTC-USD-SWAP",
        #                 "last": "8113.1",
        #                 "leverage": "15.00",
        #                 "liquidation_price": "7002.6",
        #                 "maint_margin_ratio": "0.0050",
        #                 "margin": "0.0454",
        #                 "position": "20",
        #                 "realized_pnl": "-0.0001",
        #                 "unrealized_pnl": "0",
        #                 "settled_pnl": "0.0076",
        #                 "settlement_price": "8279.2",
        #                 "side": "long",
        #                 "timestamp": "2019-09-27T03:47:37.230Z"
        #             }
        #         ]
        #     }
        #
        # option
        #
        #     {
        #         "holding":[
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-C",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.017",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             },
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-P",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.019",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             }
        #         ]
        #     }
        #
        # todo unify parsePosition/parsePositions
        return response

    async def fetch_positions(self, symbols=None, params={}):
        """
        fetch all open positions
        :param [str]|None symbols: not used by okcoin fetchPositions
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns [dict]: a list of `position structure <https://docs.ccxt.com/en/latest/manual.html#position-structure>`
        """
        await self.load_markets()
        method = None
        defaultType = self.safe_string_2(self.options, 'fetchPositions', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        if (type == 'futures') or (type == 'swap'):
            method = type + 'GetPosition'
        elif type == 'option':
            underlying = self.safe_string(params, 'underlying')
            if underlying is None:
                raise ArgumentsRequired(self.id + ' fetchPositions() requires an underlying parameter for ' + type + ' markets')
            method = type + 'GetUnderlyingPosition'
        else:
            raise NotSupported(self.id + ' fetchPositions() does not support ' + type + ' markets, supported market types are futures, swap or option')
        params = self.omit(params, 'type')
        response = await getattr(self, method)(params)
        #
        # futures
        #
        #     ...
        #
        #
        # swap
        #
        #     ...
        #
        # option
        #
        #     {
        #         "holding":[
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-C",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.017",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             },
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-P",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.019",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             }
        #         ]
        #     }
        #
        # todo unify parsePosition/parsePositions
        return response

    async def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        """
        fetch the history of changes, actions done by the user or operations that altered balance of the user
        :param str|None code: unified currency code, default is None
        :param int|None since: timestamp in ms of the earliest ledger entry, default is None
        :param int|None limit: max number of ledger entrys to return, default is None
        :param dict params: extra parameters specific to the okcoin api endpoint
        :returns dict: a `ledger structure <https://docs.ccxt.com/en/latest/manual.html#ledger-structure>`
        """
        await self.load_markets()
        defaultType = self.safe_string_2(self.options, 'fetchLedger', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        query = self.omit(params, 'type')
        suffix = '' if (type == 'account') else 'Accounts'
        argument = ''
        request = {
            # 'from': 'id',
            # 'to': 'id',
        }
        if limit is not None:
            request['limit'] = limit
        currency = None
        if type == 'spot':
            if code is None:
                raise ArgumentsRequired(self.id + " fetchLedger() requires a currency code argument for '" + type + "' markets")
            argument = 'Currency'
            currency = self.currency(code)
            request['currency'] = currency['id']
        elif type == 'futures':
            if code is None:
                raise ArgumentsRequired(self.id + " fetchLedger() requires an underlying symbol for '" + type + "' markets")
            argument = 'Underlying'
            market = self.market(code)  # we intentionally put a market inside here for the swap ledgers
            marketInfo = self.safe_value(market, 'info', {})
            settlementCurrencyId = self.safe_string(marketInfo, 'settlement_currency')
            settlementCurrencyCode = self.safe_currency_code(settlementCurrencyId)
            currency = self.currency(settlementCurrencyCode)
            underlyingId = self.safe_string(marketInfo, 'underlying')
            request['underlying'] = underlyingId
        elif type == 'swap':
            if code is None:
                raise ArgumentsRequired(self.id + " fetchLedger() requires a code argument(a market symbol) for '" + type + "' markets")
            argument = 'InstrumentId'
            market = self.market(code)  # we intentionally put a market inside here for the swap ledgers
            currency = self.currency(market['base'])
            request['instrument_id'] = market['id']
            #
            #     if type == 'margin':
            #         #
            #         #      3. Borrow
            #         #      4. Repayment
            #         #      5. Interest
            #         #      7. Buy
            #         #      8. Sell
            #         #      9. From capital account
            #         #     10. From C2C
            #         #     11. From Futures
            #         #     12. From Spot
            #         #     13. From ETT
            #         #     14. To capital account
            #         #     15. To C2C
            #         #     16. To Spot
            #         #     17. To Futures
            #         #     18. To ETT
            #         #     19. Mandatory Repayment
            #         #     20. From Piggybank
            #         #     21. To Piggybank
            #         #     22. From Perpetual
            #         #     23. To Perpetual
            #         #     24. Liquidation Fee
            #         #     54. Clawback
            #         #     59. Airdrop Return.
            #         #
            #         request['type'] = 'number'  # All types will be returned if self filed is left blank
            #     }
            #
        elif type == 'account':
            if code is not None:
                currency = self.currency(code)
                request['currency'] = currency['id']
            #
            #     #
            #     #      1. deposit
            #     #      2. withdrawal
            #     #     13. cancel withdrawal
            #     #     18. into futures account
            #     #     19. out of futures account
            #     #     20. into sub account
            #     #     21. out of sub account
            #     #     28. claim
            #     #     29. into ETT account
            #     #     30. out of ETT account
            #     #     31. into C2C account
            #     #     32. out of C2C account
            #     #     33. into margin account
            #     #     34. out of margin account
            #     #     37. into spot account
            #     #     38. out of spot account
            #     #
            #     request['type'] = 'number'
            #
        else:
            raise NotSupported(self.id + " fetchLedger does not support the '" + type + "' type(the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")
        method = type + 'Get' + suffix + argument + 'Ledger'
        response = await getattr(self, method)(self.extend(request, query))
        #
        # transfer     funds transfer in/out
        # trade        funds moved as a result of a trade, spot accounts only
        # rebate       fee rebate as per fee schedule, spot accounts only
        # match        open long/open short/close long/close short(futures) or a change in the amount because of trades(swap)
        # fee          fee, futures only
        # settlement   settlement/clawback/settle long/settle short
        # liquidation  force close long/force close short/deliver close long/deliver close short
        # funding      funding fee, swap only
        # margin       a change in the amount after adjusting margin, swap only
        #
        # account
        #
        #     [
        #         {
        #             "amount":0.00051843,
        #             "balance":0.00100941,
        #             "currency":"BTC",
        #             "fee":0,
        #             "ledger_id":8987285,
        #             "timestamp":"2018-10-12T11:01:14.000Z",
        #             "typename":"Get from activity"
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             "timestamp":"2019-03-18T07:08:25.000Z",
        #             "ledger_id":"3995334780",
        #             "created_at":"2019-03-18T07:08:25.000Z",
        #             "currency":"BTC",
        #             "amount":"0.0009985",
        #             "balance":"0.0029955",
        #             "type":"trade",
        #             "details":{
        #                 "instrument_id":"BTC-USDT",
        #                 "order_id":"2500650881647616",
        #                 "product_id":"BTC-USDT"
        #             }
        #         }
        #     ]
        #
        # futures
        #
        #     [
        #         {
        #             "ledger_id":"2508090544914461",
        #             "timestamp":"2019-03-19T14:40:24.000Z",
        #             "amount":"-0.00529521",
        #             "balance":"0",
        #             "currency":"EOS",
        #             "type":"fee",
        #             "details":{
        #                 "order_id":"2506982456445952",
        #                 "instrument_id":"EOS-USD-190628"
        #             }
        #         }
        #     ]
        #
        # swap
        #
        #     [
        #         {
        #             "amount":"0.004742",
        #             "fee":"-0.000551",
        #             "type":"match",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "ledger_id":"197429674941902848",
        #             "timestamp":"2019-03-25T05:56:31.286Z"
        #         },
        #     ]
        #
        responseLength = len(response)
        if responseLength < 1:
            return []
        if type == 'swap':
            ledgerEntries = self.parse_ledger(response)
            return self.filter_by_symbol_since_limit(ledgerEntries, code, since, limit)
        return self.parse_ledger(response, currency, since, limit)

    def parse_ledger_entry_type(self, type):
        types = {
            'transfer': 'transfer',  # funds transfer in/out
            'trade': 'trade',  # funds moved as a result of a trade, spot accounts only
            'rebate': 'rebate',  # fee rebate as per fee schedule, spot accounts only
            'match': 'trade',  # open long/open short/close long/close short(futures) or a change in the amount because of trades(swap)
            'fee': 'fee',  # fee, futures only
            'settlement': 'trade',  # settlement/clawback/settle long/settle short
            'liquidation': 'trade',  # force close long/force close short/deliver close long/deliver close short
            'funding': 'fee',  # funding fee, swap only
            'margin': 'margin',  # a change in the amount after adjusting margin, swap only
        }
        return self.safe_string(types, type, type)

    def parse_ledger_entry(self, item, currency=None):
        #
        #
        # account
        #
        #     {
        #         "amount":0.00051843,
        #         "balance":0.00100941,
        #         "currency":"BTC",
        #         "fee":0,
        #         "ledger_id":8987285,
        #         "timestamp":"2018-10-12T11:01:14.000Z",
        #         "typename":"Get from activity"
        #     }
        #
        # spot
        #
        #     {
        #         "timestamp":"2019-03-18T07:08:25.000Z",
        #         "ledger_id":"3995334780",
        #         "created_at":"2019-03-18T07:08:25.000Z",
        #         "currency":"BTC",
        #         "amount":"0.0009985",
        #         "balance":"0.0029955",
        #         "type":"trade",
        #         "details":{
        #             "instrument_id":"BTC-USDT",
        #             "order_id":"2500650881647616",
        #             "product_id":"BTC-USDT"
        #         }
        #     }
        #
        # futures
        #
        #     {
        #         "ledger_id":"2508090544914461",
        #         "timestamp":"2019-03-19T14:40:24.000Z",
        #         "amount":"-0.00529521",
        #         "balance":"0",
        #         "currency":"EOS",
        #         "type":"fee",
        #         "details":{
        #             "order_id":"2506982456445952",
        #             "instrument_id":"EOS-USD-190628"
        #         }
        #     }
        #
        # swap
        #
        #     {
        #         "amount":"0.004742",
        #         "fee":"-0.000551",
        #         "type":"match",
        #         "instrument_id":"EOS-USD-SWAP",
        #         "ledger_id":"197429674941902848",
        #         "timestamp":"2019-03-25T05:56:31.286Z"
        #     },
        #
        id = self.safe_string(item, 'ledger_id')
        account = None
        details = self.safe_value(item, 'details', {})
        referenceId = self.safe_string(details, 'order_id')
        referenceAccount = None
        type = self.parse_ledger_entry_type(self.safe_string(item, 'type'))
        code = self.safe_currency_code(self.safe_string(item, 'currency'), currency)
        amount = self.safe_number(item, 'amount')
        timestamp = self.parse8601(self.safe_string(item, 'timestamp'))
        fee = {
            'cost': self.safe_number(item, 'fee'),
            'currency': code,
        }
        before = None
        after = self.safe_number(item, 'balance')
        status = 'ok'
        marketId = self.safe_string(item, 'instrument_id')
        symbol = self.safe_symbol(marketId)
        return {
            'info': item,
            'id': id,
            'account': account,
            'referenceId': referenceId,
            'referenceAccount': referenceAccount,
            'type': type,
            'currency': code,
            'symbol': symbol,
            'amount': amount,
            'before': before,  # balance before
            'after': after,  # balance after
            'status': status,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': fee,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        isArray = isinstance(params, list)
        request = '/api/' + api + '/' + self.version + '/'
        request += path if isArray else self.implode_params(path, params)
        query = params if isArray else self.omit(params, self.extract_params(path))
        url = self.implode_hostname(self.urls['api']['rest']) + request
        type = self.get_path_authentication_type(path)
        if (type == 'public') or (type == 'information'):
            if query:
                url += '?' + self.urlencode(query)
        elif type == 'private':
            self.check_required_credentials()
            timestamp = self.iso8601(self.milliseconds())
            headers = {
                'OK-ACCESS-KEY': self.apiKey,
                'OK-ACCESS-PASSPHRASE': self.password,
                'OK-ACCESS-TIMESTAMP': timestamp,
                # 'OK-FROM': '',
                # 'OK-TO': '',
                # 'OK-LIMIT': '',
            }
            auth = timestamp + method + request
            if method == 'GET':
                if query:
                    urlencodedQuery = '?' + self.urlencode(query)
                    url += urlencodedQuery
                    auth += urlencodedQuery
            else:
                if isArray or query:
                    body = self.json(query)
                    auth += body
                headers['Content-Type'] = 'application/json'
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            headers['OK-ACCESS-SIGN'] = signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def get_path_authentication_type(self, path):
        # https://github.com/ccxt/ccxt/issues/6651
        # a special case to handle the optionGetUnderlying interefering with
        # other endpoints containing self keyword
        if path == 'underlying':
            return 'public'
        auth = self.safe_value(self.options, 'auth', {})
        key = self.find_broadly_matched_key(auth, path)
        return self.safe_string(auth, key, 'private')

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        feedback = self.id + ' ' + body
        if code == 503:
            # {"message":"name resolution failed"}
            raise ExchangeNotAvailable(feedback)
        #
        #     {"error_message":"Order does not exist","result":"true","error_code":"35029","order_id":"-1"}
        #
        message = self.safe_string(response, 'message')
        errorCode = self.safe_string_2(response, 'code', 'error_code')
        nonEmptyMessage = ((message is not None) and (message != ''))
        nonZeroErrorCode = (errorCode is not None) and (errorCode != '0')
        if nonEmptyMessage:
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
        if nonZeroErrorCode:
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
        if nonZeroErrorCode or nonEmptyMessage:
            raise ExchangeError(feedback)  # unknown message
