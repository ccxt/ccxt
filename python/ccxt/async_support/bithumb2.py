# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.bithumb2 import ImplicitAPI
from ccxt.base.types import Any, Balances, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Str, Ticker, Trade
from typing import List
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS


class bithumb2(Exchange, ImplicitAPI):

    def describe(self) -> Any:
        return self.deep_extend(super(bithumb2, self).describe(), {
            'id': 'bithumb2',
            'name': 'Bithumb v2',
            'countries': ['KR'],  # South Korea
            'rateLimit': 500,
            'pro': True,
            'has': {
                'CORS': True,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'cancelOrder': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchMarkets': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'withdraw': True,
            },
            'hostname': 'bithumb.com',
            'urls': {
                'logo': 'https://github.com/user-attachments/assets/c9e0eefb-4777-46b9-8f09-9d7f7c4af82d',
                'api': {
                    'public': 'https://api.bithumb.com/v1',
                    'private': 'https://api.bithumb.com/v1',
                    'order': 'https://api.bithumb.com/v2',
                },
                'www': 'https://www.bithumb.com',
                'doc': 'https://apidocs.bithumb.com',
                'fees': 'https://en.bithumb.com/customer_support/info_fee',
            },
            'api': {
                'public': {
                    'get': [
                        'market/all',
                        'ticker',
                        'orderbook',
                        'trades/recent',
                        'candlestick/{market}/{interval}',
                    ],
                },
                'private': {
                    'get': [
                        'accounts',
                        'orders/chance',
                        'order',
                        'orders',
                    ],
                    'post': [
                        'orders',
                    ],
                    'delete': [
                        'order',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': self.parse_number('0.0025'),
                    'taker': self.parse_number('0.0025'),
                },
            },
            'precisionMode': SIGNIFICANT_DIGITS,
            'exceptions': {
                'Bad Request(SSL)': BadRequest,
                'Bad Request(Bad Method)': BadRequest,
                'Bad Request.(Auth Data)': AuthenticationError,
                'Not Member': AuthenticationError,
                'Invalid Apikey': AuthenticationError,
                'Method Not Allowed.(Access IP)': PermissionDenied,
                'Method Not Allowed.(BTC Adress)': InvalidAddress,
                'Method Not Allowed.(Access)': PermissionDenied,
                'Database Fail': ExchangeNotAvailable,
                'Invalid Parameter': BadRequest,
                'Unknown Error': ExchangeError,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '10m': '10m',
                '30m': '30m',
                '1h': '1h',
                '6h': '6h',
                '12h': '12h',
                '1d': '24h',
            },
        })

    async def fetch_markets(self, params={}) -> List[Market]:
        response = await self.publicGetMarketAll(params)
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "korean_name": "비트코인",
        #            "english_name": "Bitcoin",
        #            "market_warning": "NONE"
        #        },
        #        ...
        #    ]
        #
        result = []
        for i in range(0, len(response)):
            entry = response[i]
            marketId = self.safe_string(entry, 'market')
            quoteId, baseId = marketId.split('-')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            result.append({
                'id': marketId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'active': True,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDateTime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': int('4'),
                    'price': int('4'),
                },
                'limits': {
                    'leverage': {'min': None, 'max': None},
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                },
                'info': entry,
            })
        return result

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'markets': market['id'],
        }
        response = await self.publicGetTicker(self.extend(request, params))
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "trade_date": "20231024",
        #            "trade_time": "063544",
        #            "trade_date_kts": "20231024",
        #            "trade_time_kts": "153544",
        #            "trade_timestamp": 1698125744000,
        #            "opening_price": 41531000,
        #            "high_price": 46473000,
        #            "low_price": 41511000,
        #            "trade_price": 45831000,
        #            "prev_closing_price": 41519000,
        #            "change": "RISE",
        #            "change_price": 4312000,
        #            "change_rate": 0.1038560659,
        #            "signed_change_price": 4312000,
        #            "signed_change_rate": 0.1038560659,
        #            "trade_volume": 0.0094943,
        #            "acc_trade_price": 315426173010.59125,
        #            "acc_trade_price_24h": 366228795843.045,
        #            "acc_trade_volume": 7248.51469502,
        #            "acc_trade_volume_24h": 8464.71765997,
        #            "highest_52_week_price": 46473000,
        #            "highest_52_week_date": "2023-10-24",
        #            "lowest_52_week_price": 20458000,
        #            "lowest_52_week_date": "2022-12-30",
        #            "timestamp": 1698125744837
        #        }
        #    ]
        #
        return self.parse_ticker(response[0], market)

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        timestamp = self.safe_integer(ticker, 'timestamp')
        symbol = self.safe_symbol(None, market)
        open = self.safe_string(ticker, 'opening_price')
        close = self.safe_string(ticker, 'trade_price')
        high = self.safe_string(ticker, 'high_price')
        low = self.safe_string(ticker, 'low_price')
        baseVolume = self.safe_string(ticker, 'acc_trade_volume_24h')
        quoteVolume = self.safe_string(ticker, 'acc_trade_price_24h')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': high,
            'low': low,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': close,
            'last': close,
            'previousClose': self.safe_string(ticker, 'prev_closing_price'),
            'change': self.safe_string(ticker, 'change_price'),
            'percentage': self.safe_string(ticker, 'change_rate'),
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }, market)

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'markets': market['id'],
        }
        response = await self.publicGetOrderbook(self.extend(request, params))
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "timestamp": 1698125744837,
        #            "total_ask_size": 12.345,
        #            "total_bid_size": 23.456,
        #            "orderbook_units": [
        #                {
        #                    "ask_price": 45831000,
        #                    "bid_price": 45830000,
        #                    "ask_size": 0.123,
        #                    "bid_size": 0.234
        #                },
        #                ...
        #            ]
        #        }
        #    ]
        #
        data = response[0]
        timestamp = self.safe_integer(data, 'timestamp')
        return self.parse_order_book(data, symbol, timestamp, 'bid_price', 'ask_price', 'bid_size', 'ask_size', 'orderbook_units')

    def parse_order_book(self, orderbook, symbol, timestamp=None, bidKey='price', askKey='price', bidAmountKey='amount', askAmountKey='amount', marketKey='orderbook_units'):
        units = self.safe_value(orderbook, marketKey, [])
        bids = []
        asks = []
        for i in range(0, len(units)):
            unit = units[i]
            bids.append([self.safe_number(unit, 'bid_price'), self.safe_number(unit, 'bid_size')])
            asks.append([self.safe_number(unit, 'ask_price'), self.safe_number(unit, 'ask_size')])
        return {
            'symbol': symbol,
            'bids': self.sort_by(bids, 0, True),
            'asks': self.sort_by(asks, 0),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'nonce': None,
        }

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        if limit is not None:
            request['count'] = limit
        response = await self.publicGetTradesRecent(self.extend(request, params))
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "trade_date_utc": "2023-10-24",
        #            "trade_time_utc": "06:35:44",
        #            "timestamp": 1698125744000,
        #            "trade_price": 45831000,
        #            "trade_volume": 0.0094943,
        #            "prev_closing_price": 41519000,
        #            "change_price": 4312000,
        #            "ask_bid": "ASK",
        #            "sequential_id": 1698125744000001
        #        },
        #        ...
        #    ]
        #
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        timestamp = self.safe_integer(trade, 'timestamp')
        side = self.safe_string_lower(trade, 'ask_bid') == 'sell' if 'ask' else 'buy'
        price = self.safe_string(trade, 'trade_price')
        amount = self.safe_string(trade, 'trade_volume')
        id = self.safe_string(trade, 'sequential_id')
        symbol = self.safe_symbol(None, market)
        return self.safe_trade({
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': None,
            'type': None,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': None,
        }, market)

    async def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
            'interval': self.safe_string(self.timeframes, timeframe, timeframe),
        }
        if limit is not None:
            request['count'] = limit
        response = await self.publicGetCandlestickMarketInterval(self.extend(request, params))
        #
        #    [
        #        {
        #            "market": "KRW-BTC",
        #            "candle_date_time_utc": "2023-10-24T06:35:00",
        #            "candle_date_time_kts": "2023-10-24T15:35:00",
        #            "opening_price": 45831000,
        #            "high_price": 45831000,
        #            "low_price": 45831000,
        #            "trade_price": 45831000,
        #            "timestamp": 1698125700000,
        #            "candle_acc_trade_price": 435133614.99125,
        #            "candle_acc_trade_volume": 9.4943,
        #            "unit": 1
        #        },
        #        ...
        #    ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        return [
            self.safe_integer(ohlcv, 'timestamp'),
            self.safe_number(ohlcv, 'opening_price'),
            self.safe_number(ohlcv, 'high_price'),
            self.safe_number(ohlcv, 'low_price'),
            self.safe_number(ohlcv, 'trade_price'),
            self.safe_number(ohlcv, 'candle_acc_trade_volume'),
        ]

    async def fetch_balance(self, params={}) -> Balances:
        await self.load_markets()
        response = await self.privateGetAccounts(params)
        #
        #    [
        #        {
        #            "currency": "KRW",
        #            "balance": "1000000.0",
        #            "locked": "0.0",
        #            "avg_buy_price": "0",
        #            "avg_buy_price_modified": False,
        #            "unit_currency": "KRW"
        #        },
        #        ...
        #    ]
        #
        result = {'info': response}
        for i in range(0, len(response)):
            entry = response[i]
            currencyId = self.safe_string(entry, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_string(entry, 'balance')
            account['used'] = self.safe_string(entry, 'locked')
            result[code] = account
        return self.safe_balance(result)

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'market': market['id'],
            'side': 'bid' if (side == 'buy') else 'ask',
            'volume': self.amount_to_precision(symbol, amount),
            'ord_type': 'limit' if (type == 'limit') else 'price',  # price is market buy/sell
        }
        if type == 'limit':
            request['price'] = self.price_to_precision(symbol, price)
        response = await self.privatePostOrders(self.extend(request, params))
        #
        #    {
        #        "uuid": "whpnd-...",
        #        "side": "bid",
        #        "ord_type": "limit",
        #        "price": "45831000",
        #        "state": "wait",
        #        "market": "KRW-BTC",
        #        "created_at": "2023-10-24T06:35:44",
        #        "volume": "0.0094943",
        #        "remaining_volume": "0.0094943",
        #        "reserved_fee": "0.0",
        #        "remaining_fee": "100.0",
        #        "paid_fee": "0.0",
        #        "locked": "435133614.99125",
        #        "executed_volume": "0.0",
        #        "trades_count": 0
        #    }
        #
        return self.parse_order(response, market)

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        request = {
            'uuid': id,
        }
        response = await self.privateDeleteOrder(self.extend(request, params))
        return self.parse_order(response)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        timestamp = self.parse8601(self.safe_string(order, 'created_at'))
        status = self.parse_order_status(self.safe_string(order, 'state'))
        symbol = self.safe_symbol(self.safe_string(order, 'market'), market)
        side = self.safe_string_lower(order, 'side') == 'buy' if 'bid' else 'sell'
        type = self.safe_string_lower(order, 'ord_type')
        price = self.safe_string(order, 'price')
        amount = self.safe_string(order, 'volume')
        remaining = self.safe_string(order, 'remaining_volume')
        filled = self.safe_string(order, 'executed_volume')
        id = self.safe_string(order, 'uuid')
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'triggerPrice': None,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'cost': None,
            'trades': None,
            'fee': {
                'currency': None,
                'cost': self.safe_string(order, 'paid_fee'),
            },
            'info': order,
        }, market)

    def parse_order_status(self, status: Str):
        statuses: dict = {
            'wait': 'open',
            'done': 'closed',
            'cancel': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api] + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            nonce = self.uuid()
            timestamp = self.milliseconds()
            payload: dict = {
                'access_key': self.apiKey,
                'nonce': nonce,
                'timestamp': timestamp,
            }
            if query:
                if method == 'GET' or method == 'DELETE':
                    queryString = self.urlencode(query)
                    url += '?' + queryString
                    payload['query_hash'] = self.hash(self.encode(queryString), 'sha512')
                else:
                    body = self.json(query)
                    payload['query_hash'] = self.hash(self.encode(self.urlencode(query)), 'sha512')
            token = self.jwt(payload, self.encode(self.secret), 'sha256')
            headers = {
                'Authorization': 'Bearer ' + token,
            }
            if method == 'POST':
                headers['Content-Type'] = 'application/json'
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
