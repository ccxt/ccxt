# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InvalidOrder
from ccxt.base.decimal_to_precision import SIGNIFICANT_DIGITS


class tprexchange(Exchange):

    def describe(self):
        return self.deep_extend(super(tprexchange, self).describe(), {
            'id': 'tprexchange',
            'name': 'TPR Exchange',
            # 'countries': ['US'],
            # 'rateLimit': 500,
            'version': 'v1',
            'certified': False,
            'has': {
                'loadMarkets': False,
                'cancelAllOrders': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'CORS': False,
                'createDepositAddress': False,
                'createLimitOrder': False,
                'createMarketOrder': False,
                'createOrder': True,
                'deposit': False,
                'editOrder': 'emulated',
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': 'emulated',
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': False,
                'fetchOrderBooks': False,
                'fetchOrders': True,
                'fetchOrderTrades': False,
                'fetchStatus': 'emulated',
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': False,
                'fetchTransactions': False,
                'fetchWithdrawals': False,
                'privateAPI': True,
                'publicAPI': False,
                'signIn': True,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '1h': '60',
                '4h': '240',
                '1d': '1440',
                '1w': '10080',
            },
            'urls': {
                'logo': '',
                'api': '{hostname}',
                'www': '',
                'doc': '',
                'fees': '',
                'referral': '',
            },
            'api': {
                'private': {
                    'get': [
                    ],
                    'post': [
                        'uc/api-login',
                        'uc/balance',
                        'exchange/order/add',
                        'exchange/order/find',
                        'exchange/order/all',
                        'exchange/order/apicancel',
                    ],
                    'delete': [
                    ],
                },
                'feed': {
                    'get': [
                    ],
                },
            },
            'fees': {
                'trading': {
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'uid': False,
            },
            'precisionMode': SIGNIFICANT_DIGITS,
            'options': {
                'createMarketBuyOrderRequiresPrice': False,
            },
            'exceptions': {
                'exact': {
                    'Invalid cost': InvalidOrder,  # {"message":"Invalid cost","_links":{"self":{"href":"/orders","templated":false}}}
                    'Invalid order ID': InvalidOrder,  # {"message":"Invalid order ID","_links":{"self":{"href":"/orders/4a151805-d594-4a96-9d64-e3984f2441f7","templated":false}}}
                    'Invalid market !': BadSymbol,  # {"message":"Invalid market !","_links":{"self":{"href":"/markets/300/order-book","templated":false}}}
                },
                'broad': {
                    'Failed to convert argument': BadRequest,
                },
            },
        })

    async def fetch_markets(self, params={}):
        return [
            {
                'id': 'TPR',
                'symbol': 'TPR/USD',
                'base': 'TPR',
                'quote': 'USD',
                'baseId': 'TPR',
                'quoteId': 'USD',
                'type': 'spot',
                'active': True,
                'precision': {
                    'amount': None,
                    'price': None,
                },
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                },
                'taker': '0.005',
                'maker': '0.0025',
                'info': 'TPR Market',
            },
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=1000, params={}):
        return []

    async def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        # Check existance of authentication token
        # Just use empy one in case of an application is not signed in yet
        authToken = ''
        if 'token' in self.options:
            authToken = self.options['token']
        # Get URL
        url = self.implode_params(self.urls['api'], {'hostname': self.hostname}) + '/' + path
        # Calculate body and content type depending on method type: GET or POST
        keys = list(params.keys())
        keysLength = len(keys)
        # In case of body is still not assigned just make it empty string
        if body is None:
            body = ''
        # Prepare line for hashing
        # This hash sum is checked on backend side to verify API user
        # POST params should not be added as body
        query = method + ' /' + path + ' ' + self.urlencode(params) + ' ' + authToken + '\n' + body
        signed = self.hmac(self.encode(query), self.encode(self.secret))
        contentType = None
        if method == 'POST':
            contentType = 'application/x-www-form-urlencoded'
            if keysLength > 0:
                body = self.urlencode(params)
        else:
            if keysLength > 0:
                url += '?' + self.urlencode(params)
        headers = {
            'x-auth-sign': signed,
            'x-auth-token': authToken,
        }
        if authToken != '':
            headers['access-auth-token'] = authToken
        if contentType is not None:
            headers['Content-Type'] = contentType
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def sign_in(self, params={}):
        params = {
            'key': self.key,
            'token': self.token,
        }
        response = await self.privatePostUcApiLogin(params)
        loginData = response['data']
        self.options['token'] = self.safe_string(loginData, 'token')
        memberId = self.safe_string(loginData, 'id')
        return memberId

    async def fetch_order(self, id, symbol=None, params={}):
        request = {
            'orderId': id,
        }
        response = await self.privatePostExchangeOrderFind(request)
        return self.parse_order(response)

    async def parse_order(self, order, market=None):
        # {
        #   'orderId':'E161183624377614',
        #   'memberId':2,
        #   'type':'LIMIT_PRICE',
        #   'amount':1000.0,
        #   'symbol':'BCH/USDT',
        #   'tradedAmount':1000.0,
        #   'turnover':1080.0,
        #   'coinSymbol':'BCH',
        #   'baseSymbol':'USDT',
        #   'status':'COMPLETED',
        #   'direction':'SELL',
        #   'price':1.0,
        #   'time':1611836243776,
        #   'completedTime':1611836256242,
        # },
        type = 'market'
        if order['type'] == 'LIMIT_PRICE':
            type = 'limit'
        side = order['direction'].lower()
        remaining = order['amount'] - order['tradedAmount']
        status = order['status']
        if status == 'COMPLETED':
            status = 'closed'
        elif status == 'TRADING':
            status = 'open'
        else:
            status = 'canceled'
        cost = order['tradedAmount'] * order['price']
        result = {
            'info': order,
            'id': order['orderId'],
            'clientOrderId': order['memberId'],
            'timestamp': order['time'],
            'datetime': self.iso8601(order['time']),
            'lastTradeTimestamp': None,
            'symbol': order['symbol'],
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': order['price'],
            'stopPrice': None,
            'cost': cost,
            'average': None,
            'amount': order['amount'],
            'filled': order['tradedAmount'],
            'remaining': remaining,
            'status': status,
            'fee': None,
            'trades': None,
        }
        return result

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        params['symbol'] = symbol
        params['price'] = price
        params['amount'] = amount
        if side == 'buy':
            params['direction'] = 'BUY'
        else:
            params['direction'] = 'SELL'
        if type == 'market':
            params['type'] = 'MARKET_PRICE'
        else:
            params['type'] = 'LIMIT_PRICE'
        params['useDiscount'] = '0'
        response = await self.privatePostExchangeOrderAdd(params)
        orderId = self.safe_string(response, 'data')
        return await self.fetch_order(orderId)

    async def cancel_order(self, id, symbol=None, params={}):
        request = {
            'orderId': id,
        }
        response = await self.privatePostExchangeOrderApicancel(self.extend(request, params))
        return await self.parse_order(response['data'])

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        # Request structure
        # {
        #   'symbol': Parameter from method arguments
        #   'since': Timestamp of first order in list in Unix epoch format
        #   'limit': Response list size
        #   'memberId': May be set in params. May be not set
        #   'status': one of TRADING COMPLETED CANCELED OVERTIMED. May be set in params
        #   'page': for pagination. In self case limit is size of every page. May be set in params
        # }
        if 'page' in params:
            params['pageNo'] = self.safe_string(params, 'page')
        else:
            params['pageNo'] = 1
        request = {
            'symbol': symbol,
            'since': since,
            'pageSize': limit,
        }
        fullRequest = self.extend(request, params)
        response = self.privatePostExchangeOrderAll(fullRequest)
        # {
        #     'content': [
        #         {
        #             'orderId':'E161183624377614',
        #             'memberId':2,
        #             'type':'LIMIT_PRICE',
        #             'amount':1000.0,
        #             'symbol':'BCH/USDT',
        #             'tradedAmount':1000.0,
        #             'turnover':1080.0,
        #             'coinSymbol':'BCH',
        #             'baseSymbol':'USDT',
        #             'status':'COMPLETED',
        #             'direction':'SELL',
        #             'price':1.0,
        #             'time':1611836243776,
        #             'completedTime':1611836256242,
        #         },
        #         ...
        #     ],
        #     'totalElements':41,
        #     'totalPages':3,
        #     'last':False,
        #     'size':20,
        #     'number':1,
        #     'first':False,
        #     'numberOfElements':20,
        #     'sort': [
        #         {
        #             'direction':'DESC',
        #             'property':'time',
        #             'ignoreCase':False,
        #             'nullHandling':'NATIVE',
        #             'ascending':False,
        #             'descending':True,
        #         }
        #     ]
        # }
        return self.parse_orders(response['content'])

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        # Request structure
        # {
        #   'symbol': Parameter from method arguments
        #   'since': Timestamp of first order in list in Unix epoch format
        #   'limit': Response list size
        #   'memberId': May be set in params. May be not set
        #   'status': one of TRADING COMPLETED CANCELED OVERTIMED. May be set in params
        #   'page': for pagination. In self case limit is size of every page. May be set in params
        # }
        params['status'] = 'TRADING'
        if 'page' in params:
            params['pageNo'] = self.safe_string(params, 'page')
        else:
            params['pageNo'] = 1
        request = {
            'symbol': symbol,
            'since': since,
            'pageSize': limit,
        }
        fullRequest = self.extend(request, params)
        response = self.privatePostExchangeOrderAll(fullRequest)
        # {
        #     'content': [
        #         {
        #             'orderId':'E161183624377614',
        #             'memberId':2,
        #             'type':'LIMIT_PRICE',
        #             'amount':1000.0,
        #             'symbol':'BCH/USDT',
        #             'tradedAmount':1000.0,
        #             'turnover':1080.0,
        #             'coinSymbol':'BCH',
        #             'baseSymbol':'USDT',
        #             'status':'COMPLETED',
        #             'direction':'SELL',
        #             'price':1.0,
        #             'time':1611836243776,
        #             'completedTime':1611836256242,
        #         },
        #         ...
        #     ],
        #     'totalElements':41,
        #     'totalPages':3,
        #     'last':False,
        #     'size':20,
        #     'number':1,
        #     'first':False,
        #     'numberOfElements':20,
        #     'sort': [
        #         {
        #             'direction':'DESC',
        #             'property':'time',
        #             'ignoreCase':False,
        #             'nullHandling':'NATIVE',
        #             'ascending':False,
        #             'descending':True,
        #         }
        #     ]
        # }
        return self.parse_orders(response['content'])

    def parse_balance(self, balance):
        return {
            'info': balance,
        }

    async def fetch_balance(self, params={}):
        response = await self.privatePostUcBalance(params)
        return self.parse_balance(response)

    def parse_trade(self, trade, market=None):
        timestamp = 0
        fee = {
            'cost': None,
            'currency': None,
        }
        return {
            'info': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': None,
            'id': None,
            'order': None,
            'type': None,
            'side': None,
            'takerOrMaker': None,
            'price': None,
            'amount': None,
            'cost': None,
            'fee': fee,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        market = None
        trades = self.privatePostExchangeTrades(params)
        return self.parse_trades(trades, market, since, limit, params)

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        market = None
        trades = self.privatePostExchangeTrades(params)
        return self.parse_trades(trades, market, since, limit, params)

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if httpCode == 200:
            if 'code' in response:
                if response['code'] == 0:
                    return
            else:
                return
        # {
        #     "message": "Error text in case when HTTP code is not 200",
        #     ...
        # }
        message = self.safe_string(response, 'message')
        if message is not None:
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message
