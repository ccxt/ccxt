# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import math
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import NotSupported


class gooplex(Exchange):

    def describe(self):
        return self.deep_extend(super(gooplex, self).describe(), {
            'id': 'gooplex',
            'name': 'Gooplex',
            'countries': ['BR'],  # US
            'certified': False,
            'pro': False,
            'has': {
                'cancelAllOrders': 'emulated',
                'cancelOrder': True,
                'CORS': False,
                'createOrder': True,
                'fetchBalance': True,
                'fetchBidsAsks': True,
                'fetchClosedOrders': 'emulated',
                'fetchDepositAddress': True,
                'fetchDeposits': True,
                'fetchFundingFees': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOrderBook': True,
                'fetchStatus': 'emulated',
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFee': 'emulated',
                'fetchTradingFees': 'emulated',
                'fetchTransactions': False,
                'fetchWithdrawals': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'doc': 'https://www.gooplex.com.br/apidocs/#api-document-description',
                'fees': 'https://gooplex.zendesk.com/hc/pt/articles/360049326131-O-que-s%C3%A3o-taxas-de-negocia%C3%A7%C3%A3o-',
                'logo': 'https://user-images.githubusercontent.com/228850/93481157-a0a2cb00-f8d4-11ea-8608-d56dd916a9ed.jpg',
                'referral': 'https://www.gooplex.com.br/account/signup?ref=H8QQ57WT',
                'www': 'https://www.gooplex.com.br',
                # API
                'api': {
                    'open': 'https://www.gooplex.com.br/open/v1',
                    'signed': 'https://www.gooplex.com.br/open/v1',
                    'api': 'https://api.binance.com/api',
                    'public': 'https://api.binance.com/api/v3',
                },
            },
            'api': {
                'open': {              # public
                    'get': [
                        'common/time',
                        'common/symbols',
                        'market/depth',
                    ],
                },
                'signed': {            # private
                    'get': [
                        'orders',
                        'orders/detail',
                        'orders/trades',
                        'account/spot',
                        'deposits',
                        'deposits/address',
                        'withdraws',
                    ],
                    'post': [
                        'orders',
                        'orders/cancel',
                        'withdraws',
                    ],
                },
                'api': {
                    'get': [
                        'v3/depth',
                        'v3/trades',
                        'v3/aggTrades',
                    ],
                },
                'public': {
                    'get': [
                        'ping',
                        'time',
                        'depth',
                        'trades',
                        'aggTrades',
                        'historicalTrades',
                        'klines',
                        'ticker/24hr',
                        'ticker/price',
                        'ticker/bookTicker',
                        'exchangeInfo',
                    ],
                    'put': ['userDataStream'],
                    'post': ['userDataStream'],
                    'delete': ['userDataStream'],
                },
            },
            'orderlimits': [
                5,
                10,
                20,
                50,
                100,
                500,
            ],
            'sides': {
                'buy': 0,
                'sell': 1,
            },
            'types': {
                'limit': 1,
                'market': 2,
                'stop_loss': 3,
                'stop_loss_limit': 4,
                'take_profit': 5,
                'take_profit_limit': 6,
                'limit_maker': 7,
            },
            'fees': {
                'trading': {
                    'taker': 0.0022,  # 0.22% trading fee
                    'maker': 0.0022,  # 0.22% trading fee
                },
            },
        })

    def sign(self, path, api='open', method='GET', params={}, headers=None, body=None):
        if not (api in self.urls['api']):
            raise NotSupported(self.id + ' does not have a testnet/sandbox URL for ' + api + ' endpoints')
        url = self.urls['api'][api]
        url += '/' + path
        if api == 'signed':
            self.check_required_credentials()
            headers = {
                'X-MBX-APIKEY': self.apiKey,
            }
            recvWindow = self.safe_integer(self.options, 'recvWindow', 5000)
            query = None
            query = self.urlencode_with_array_repeat(self.extend({
                'timestamp': self.nonce(),
                'recvWindow': recvWindow,
            }, params))
            signature = self.hmac(self.encode(query), self.encode(self.secret))
            query += '&signature=' + signature
            url += '?' + query
        else:
            if method == 'GET':
                if params:
                    url += '?' + self.urlencode(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def get_fees(self):
        feesKey = 'fees'
        fees = getattr(self, feesKey)
        return self.safe_value(fees, 'trading')

    def symbol_display(self, originalSymbol):
        return originalSymbol.replace('_', '/')

    def symbol_original(self, displaySymbol):
        marketId = self.market_id(displaySymbol)
        return marketId

    def symbol_binance(self, displaySymbol):
        return displaySymbol.replace('/', '')

    def convert_symbol(self, market):
        trading_fees = self.get_fees()
        symbol = self.safe_string(market, 'symbol')
        entry = {
            'id': symbol,
            'symbol': self.symbol_display(symbol),
            'base': self.safe_currency_code(self.safe_value(market, 'baseAsset')),
            'quote': self.safe_currency_code(self.safe_value(market, 'quoteAsset')),
            'active': True,
            'taker': self.safe_float(trading_fees, 'taker'),
            'maker': self.safe_float(trading_fees, 'maker'),
            'percetage': True,
            'tierBase': False,
            'precision': {
                'price': self.safe_integer(market, 'quotePrecision'),
                'amount': self.safe_integer(market, 'basePrecision'),
                'cost': self.safe_integer(market, 'basePrecision'),
            },
            'limits': {
                'amount': {
                    'min': None,
                    'max': None,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
            'info': market,
        }
        return entry

    def convert_trade(self, symbol, trade):
        id = self.safe_string(trade, 'id')
        timestamp = self.safe_timestamp(trade, 'time') / 1000
        datetime = self.iso8601(timestamp)
        fee = None
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'qty')
        order = ''
        type = 'limit'
        side = 'buy'
        cost = 0.00
        takerOrMaker = None
        if self.safe_value(trade, 'isBuyerMaker'):
            takerOrMaker = 'maker'
        else:
            takerOrMaker = 'taker'
        info = {
            'M': trade['isBestMatch'],
            'T': trade['time'],
            'a': trade['id'],
            'f': None,
            'l': None,
            'm': trade['isBuyerMaker'],
            'p': trade['price'],
            'q': trade['qty'],
        }
        entry = {
            'info': info,
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'fee': fee,
            'symbol': symbol,
            'order': order,
            'type': type,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
        }
        return entry

    async def fetch_time(self, params={}):
        method = 'openGetCommonTime'
        response = await getattr(self, method)(params)
        return self.safe_integer(response, 'timestamp')

    async def fetch_status(self, params={}):
        status = 'ok'
        self.status = self.extend(self.status, {
            'status': status,
            'updated': self.milliseconds(),
        })
        return self.status

    async def fetch_markets(self, params={}):
        method = 'openGetCommonSymbols'
        response = await getattr(self, method)(params)
        data = self.safe_value(response, 'data')
        markets = self.safe_value(data, 'list')
        marketType = 'spot'
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            future = False
            delivery = False
            tierBased = False
            spot = not (future or delivery)
            conversion = self.convert_symbol(market)
            id = conversion['id']
            lowercaseId = self.safe_string_lower(conversion, 'id')
            baseId = self.safe_string(market, 'baseAsset')
            quoteId = self.safe_string(market, 'quoteAsset')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = id if delivery else (base + '/' + quote)
            precision = {
                'base': self.safe_integer(market, 'basePrecision'),
                'quote': self.safe_integer(market, 'quotePrecision'),
                'amount': self.safe_integer(market, 'basePrecision'),
                'price': self.safe_integer(market, 'quotePrecision'),
            }
            if 'maintMarginPercent' in market:
                delivery = ('marginAsset' in market)
                future = not delivery
                marketType = 'delivery' if delivery else 'future'
            status = self.safe_string_2(market, 'status', 'contractStatus')
            active = (status == 'TRADING')
            margin = self.safe_value(market, 'isMarginTradingAllowed', future or delivery)
            entry = {
                'id': id,
                'lowercaseId': lowercaseId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'type': marketType,
                'spot': spot,
                'margin': margin,
                'future': future,
                'delivery': delivery,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision['amount']),
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'market': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'tierBased': tierBased,
            }
            result.append(entry)
        return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrderBook requires a symbol argument')
        method = 'openGetMarketDepth'
        request = {
            'symbol': self.symbol_original(symbol),
        }
        if limit is not None:
            request['limit'] = limit
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_order_book(response)

    def convert_order(self, order):
        timestamp = order['createTime']
        side = order['side']
        type = order['type']
        return {
            'info': order,
            'id': order['orderId'],
            'clientOrderId': order['orderId'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': self.symbol_display(order['symbol']),
            'type': type,
            'timeInForce': order['timeInForce'],
            'postOnly': '',
            'side': side,
            'price': order['price'],
            'stopPrice': order['stopPrice'],
            'amount': order['origQty'],
            'cost': '',
            'average': '',
            'filled': '',
            'remaining': '',
            'status': order['status'],
            'fee': '',
            'trades': '',
        }

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrders requires a symbol argument')
        method = 'signedGetOrders'
        request = {
            'symbol': self.symbol_original(symbol),
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = await getattr(self, method)(self.extend(request, params))
        data = self.safe_value(response, 'data')
        list = self.safe_value(data, 'list')
        result = []
        for i in range(0, len(list)):
            order = list[i]
            result.append(self.convert_order(order))
        return result

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        requestSide = None
        requestType = None
        if symbol is None:
            raise ArgumentsRequired('createOrder requires a symbol argument')
        if side in self.sides:
            requestSide = self.sides[side]
        else:
            raise NotSupported('Side ' + side + ' not supported')
        if type in self.types:
            requestType = self.types[type]
        else:
            raise NotSupported('Type ' + type + ' not supported.')
        method = 'signedPostOrders'
        request = {
            'symbol': self.symbol_original(symbol),
            'side': requestSide,
            'type': requestType,
            'quantity': amount,
        }
        if price is not None:
            request['price'] = price
        response = await getattr(self, method)(self.extend(request, params))
        data = self.safe_value(response, 'data')
        return self.convert_order(data)

    async def fetch_order(self, id, symbol=None, params={}):
        method = 'signedGetOrdersDetail'
        request = {
            'orderId': id,
        }
        response = await getattr(self, method)(self.extend(request, params))
        return self.convert_order(self.safe_value(response, 'data'))

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchClosedOrders requires a symbol argument')
        orders = await self.fetch_orders(symbol, since, limit, params)
        code = str(orders['code'])
        if code == '3701':
            raise PermissionDenied('fetchClosedOrders Invalid API-key, IP, or permissions for action.')
        return self.filter_by(orders, 'status', 'closed')

    def parse_transaction_status_by_type(self, status, type=None):
        statusesByType = {
            'deposit': {
                '0': 'pending',
                '1': 'ok',
            },
            'withdrawal': {
                '0': 'pending',  # Email Sent
                '1': 'canceled',  # Cancelled(different from 1 = ok in deposits)
                '2': 'pending',  # Awaiting Approval
                '3': 'failed',  # Rejected
                '4': 'pending',  # Processing
                '5': 'failed',  # Failure
                '6': 'ok',  # Completed
            },
        }
        statuses = self.safe_value(statusesByType, type, {})
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        id = self.safe_string(transaction, 'id')
        address = self.safe_string(transaction, 'address')
        tag = self.safe_string(transaction, 'addressTag')  # set but unused
        if tag is not None:
            if len(tag) < 1:
                tag = None
        txid = self.safe_string(transaction, 'txId')
        currencyId = self.safe_string(transaction, 'asset')
        code = self.safe_currency_code(currencyId, currency)
        timestamp = None
        insertTime = self.safe_integer(transaction, 'insertTime')
        applyTime = self.safe_integer(transaction, 'applyTime')
        type = self.safe_string(transaction, 'type')
        if type is None:
            if (insertTime is not None) and (applyTime is None):
                type = 'deposit'
                timestamp = insertTime
            elif (insertTime is None) and (applyTime is not None):
                type = 'withdrawal'
                timestamp = applyTime
        status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'status'), type)
        amount = self.safe_float(transaction, 'amount')
        feeCost = self.safe_float(transaction, 'transactionFee')
        fee = None
        transactions = {
            'address': address,
            'addressTag': tag,
            'amount': amount,
            'asset': currencyId,
            'creator': id,
            'insertTime': insertTime,
            'status': transaction['status'],
            'txId': txid,
        }
        if feeCost is not None:
            fee = {'currency': code, 'cost': feeCost}
        return {
            'info': transactions,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'tag': tag,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': fee,
        }

    async def fetch_deposit_address(self, code, params={}):
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'asset': currency['id'],
        }
        response = await self.signedGetDepositsAddress(self.extend(request, params))
        success = self.safe_value(response, 'msg')
        if success != 'Success':
            raise InvalidAddress(self.id + ' fetchDepositAddress returned an empty response â€“ create the deposit address in the user settings first.')
        address = self.safe_string(response['data'], 'address')
        tag = self.safe_string(response['data'], 'addressTag')
        status = int(response['data']['status'])
        response_status = False
        if status == 1:
            response_status = True
        else:
            response_status = False
        info = {
            'address': response['data']['address'],
            'addressTag': response['data']['addressTag'],
            'asset': response['data']['asset'],
            'success': response_status,
            'url': 'https://blockchair.com/bitcoin/address/' + address,
        }
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': info,
        }

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        currency = None
        request = {}
        if code is not None:
            currency = self.currency(code)
            request['asset'] = currency['id']
        if since is not None:
            request['startTime'] = since
            # max 3 months range https://github.com/ccxt/ccxt/issues/6495
            request['endTime'] = self.sum(since, 7776000000)
        response = await self.signedGetDeposits(self.extend(request, params))
        return self.parse_transactions(response['data']['list'], currency, since, limit)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        currency = None
        request = {}
        if code is not None:
            currency = self.currency(code)
            request['asset'] = currency['id']
        if since is not None:
            request['startTime'] = since
            # max 3 months range https://github.com/ccxt/ccxt/issues/6495
            request['endTime'] = self.sum(since, 7776000000)
        response = await self.signedGetWithdraws(self.extend(request, params))
        return self.parse_transactions(response['data']['list'], currency, since, limit)

    async def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        await self.load_markets()
        currency = self.currency(code)
        # name is optional, can be overrided via params
        name = address[0:20]
        request = {
            'asset': currency['id'],
            'address': address,
            'amount': float(amount),
            'name': name,  # name is optional, can be overrided via params
        }
        if tag is not None:
            request['addressTag'] = tag
        response = await self.signedPostWithdraws(self.extend(request, params))
        return {
            'info': response,
            'id': self.safe_string(response, 'id'),
        }

    def parse_trading_fee(self, fee, market=None):
        marketId = self.safe_string(fee, 'symbol')
        symbol = self.safe_symbol(marketId)
        return {
            'info': fee,
            'symbol': symbol,
            'maker': self.safe_float(fee, 'maker'),
            'taker': self.safe_float(fee, 'taker'),
        }

    async def fetch_trading_fee(self, symbol, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchTradingFee requires a symbol argument')
        fees = self.get_fees()
        response = self.convert_trading_fees(symbol, fees['maker'], fees['taker'])
        return response

    def convert_trading_fees(self, symbol, maker, taker):
        return {
            'info': {
                'maker': maker,
                'symbol': self.symbol_original(symbol),
                'taker': taker,
            },
            'maker': maker,
            'symbol': symbol,
            'taker': taker,
        }

    async def fetch_trading_fees(self, params={}):
        await self.load_markets()
        markets = self.fetch_markets()
        fees = self.get_fees()
        response = {}
        for index in range(0, len(markets)):
            symbol = markets[index]['symbol']
            response[symbol] = (self.convert_trading_fees(symbol, fees['maker'], fees['taker']))
        return response

    async def cancel_order(self, id, symbol=None, params={}):
        if id is None:
            raise ArgumentsRequired('cancelOrder requires a id argument')
        method = 'signedPostOrdersCancel'
        request = {
            'orderId': id,
        }
        response = await getattr(self, method)(self.extend(request, params))
        return response                        # map

    async def cancel_all_orders(self, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('cancelAllOrders requires a symbol argument')
        orders = self.fetch_orders(symbol)
        method = 'signedPostOrdersCancel'
        response = []
        for index in range(0, len(orders)):
            order = orders[index]
            request = {
                'orderId': order['id'],
                'timestamp': self.nonce(),
            }
            data = await getattr(self, method)(self.extend(request))
            response.append(data)
        return response

    async def fetch_balance(self, params={}):
        method = 'signedGetAccountSpot'
        response = await getattr(self, method)(params)
        balance = response['data']['accountAssets']
        if balance is None:
            raise BadRequest('This operation is not supported')
        data = {}
        exp_free = []
        exp_used = []
        exp_total = []
        pre_permitidos = []
        pre_permitidos.append('SPOT')
        exp_balances = []
        timestamp = response['timestamp']
        buyerCommission = float(response['data']['buyerCommission'])
        makerCommission = float(response['data']['makerCommission'])
        takerCommission = float(response['data']['takerCommission'])
        sellerCommission = float(response['data']['sellerCommission'])
        canDeposit = response['data']['canDeposit']
        canTrade = response['data']['canTrade']
        canWithdraw = response['data']['canWithdraw']
        dict_free = {'free': {}}
        dict_total = {'total': {}}
        dict_used = {'used': {}}
        for i in range(0, len(balance)):
            ativo = balance[i]['asset']
            free = float(balance[i]['free'])
            locked = float(balance[i]['locked'])
            total = free + locked
            exp_free.append([ativo, free])
            dict_free[ativo] = free
            dict_total[ativo] = total
            dict_used[ativo] = locked
            exp_total.append([ativo, total])
            exp_used.append([ativo, locked])
            pre_balance = {}
            pre_balance['asset'] = ativo
            pre_balance['free'] = str(free)
            pre_balance['locked'] = str(locked)
            exp_balances.append(pre_balance)
            pre_data_dict = {}
            pre_data_dict['free'] = free
            pre_data_dict['total'] = free
            pre_data_dict['used'] = locked
            data[ativo] = pre_data_dict
        info = {
            'accountType': 'SPOT',
            'balances': exp_balances,
            'permissions': pre_permitidos,
            'buyerCommission': buyerCommission,
            'canDeposit': canDeposit is True if 1 else False,
            'canTrade': canTrade is True if 1 else False,
            'canWithdraw': canWithdraw is True if 1 else False,
            'makerCommission': makerCommission,
            'sellerCommission': sellerCommission,
            'takerCommission': takerCommission,
            'updateTime': timestamp,
        }
        data['free'] = dict_free
        data['info'] = info
        data['total'] = dict_total
        data['used'] = dict_used
        return data

    async def fetch_bids_asks(self, symbols=None, params={}):
        await self.load_markets()
        query = self.omit(params, 'type')
        method = 'publicGetTickerBookTicker'
        response = await getattr(self, method)(query)
        return self.parse_tickers(response, symbols)

    def parse_ticker(self, ticker, market=None):
        timestamp = self.safe_integer(ticker, 'closeTime')
        marketId = self.safe_string(ticker, 'symbol')
        symbol = self.safe_symbol(marketId, market)
        last = self.safe_float(ticker, 'lastPrice')
        return {
            'symbol': self.symbol_display(symbol),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'highPrice'),
            'low': self.safe_float(ticker, 'lowPrice'),
            'bid': self.safe_float(ticker, 'bidPrice'),
            'bidVolume': self.safe_float(ticker, 'bidQty'),
            'ask': self.safe_float(ticker, 'askPrice'),
            'askVolume': self.safe_float(ticker, 'askQty'),
            'vwap': self.safe_float(ticker, 'weightedAvgPrice'),
            'open': self.safe_float(ticker, 'openPrice'),
            'close': last,
            'last': last,
            'previousClose': self.safe_float(ticker, 'prevClosePrice'),  # previous day close
            'change': self.safe_float(ticker, 'priceChange'),
            'percentage': self.safe_float(ticker, 'priceChangePercent'),
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume'),
            'quoteVolume': self.safe_float(ticker, 'quoteVolume'),
            'info': ticker,
        }

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': self.symbol_binance(symbol),
        }
        method = 'publicGetTicker24hr'
        response = await getattr(self, method)(self.extend(request, params))
        if isinstance(response, list):
            firstTicker = self.safe_value(response, 0, {})
            return self.parse_ticker(firstTicker, market)
        return self.parse_ticker(response, market)

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        query = self.omit(params, 'type')
        defaultMethod = 'publicGetTicker24hr'
        method = self.safe_string(self.options, 'fetchTickersMethod', defaultMethod)
        response = await getattr(self, method)(query)
        return self.parse_tickers(response, symbols)

    def parse_ohlcv(self, ohlcv, market=None):
        return [
            self.safe_integer(ohlcv, 0),
            self.safe_float(ohlcv, 1),
            self.safe_float(ohlcv, 2),
            self.safe_float(ohlcv, 3),
            self.safe_float(ohlcv, 4),
            self.safe_float(ohlcv, 5),
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': self.symbol_binance(symbol),
            'interval': self.timeframes[timeframe],
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit  # default == max == 500
        method = 'publicGetKlines'
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOpenOrders requires a symbol argument')
        orders = await self.fetch_orders(symbol, since, limit, params)
        code = str(orders['code'])
        if code == '3701':
            raise PermissionDenied('fetchOpenOrders Invalid API-key, IP, or permissions for action.')
        return self.filter_by(orders, 'status', 'open')

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        method = 'apiGetV3Trades'
        request = {
            'symbol': self.symbol_binance(symbol),
        }
        if limit is not None:
            request['limit'] = limit
        response = await getattr(self, method)(self.extend(request, params))
        result = []
        for i in range(0, len(response)):
            result.append(self.convert_trade(symbol, response[i]))
        return result

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrders requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        method = 'signedGetOrdersTrades'
        request = {
            'symbol': self.symbol_original(symbol),
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = await getattr(self, method)(self.extend(request, params))
        response = response['data']['list']
        return self.parse_trades(response, market, since, limit)

    def parse_l2(self, entry):
        timestamp = self.safe_timestamp(entry, 'T')
        datetime = self.iso8601(timestamp / 1000)
        return {
            'tradeId': self.safe_integer(entry, 'a'),
            'price': self.safe_float(entry, 'p'),
            'quantity': self.safe_float(entry, 'q'),
            'firstTradeId': self.safe_integer(entry, 'f'),
            'lastTradeId': self.safe_integer(entry, 'l'),
            'timestamp': timestamp,
            'datetime': datetime,
            'maker': self.safe_value(entry, 'm'),
            'bestPriceMatch': self.safe_value(entry, 'M'),
        }

    async def fetch_agg_trades(self, symbol, limit=None, params={}):
        method = 'apiGetV3AggTrades'
        request = {
            'symbol': self.symbol_binance(symbol),
        }
        if limit is not None:
            request['limit'] = limit
        response = await getattr(self, method)(self.extend(request, params))
        result = []
        for i in range(0, len(response)):
            result.append(self.parse_l2(response[i]))
        return result
