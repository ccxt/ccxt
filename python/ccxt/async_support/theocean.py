# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import hashlib
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import OrderImmediatelyFillable
from ccxt.base.errors import OrderNotFillable
from ccxt.base.errors import NotSupported
from ccxt.base.errors import ExchangeNotAvailable


class theocean (Exchange):

    def describe(self):
        self.check_required_dependencies()
        return self.deep_extend(super(theocean, self).describe(), {
            'id': 'theocean',
            'name': 'The Ocean',
            'countries': ['US'],
            'rateLimit': 3000,
            'version': 'v0',
            'certified': True,
            'requiresWeb3': True,
            # add GET https://api.staging.theocean.trade/api/v0/candlesticks/intervals to fetchMarkets
            'timeframes': {
                '5m': '300',
                '15m': '900',
                '1h': '3600',
                '6h': '21600',
                '1d': '86400',
            },
            'has': {
                'CORS': False,  # ?
                'fetchTickers': True,
                'fetchOHLCV': False,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/43103756-d56613ce-8ed7-11e8-924e-68f9d4bcacab.jpg',
                'api': 'https://api.theocean.trade/api',
                'www': 'https://theocean.trade',
                'doc': 'https://docs.theocean.trade',
                'fees': 'https://theocean.trade/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'fee_components',
                        'token_pairs',
                        'ticker',
                        'tickers',
                        'candlesticks',
                        'candlesticks/intervals',
                        'trade_history',
                        'order_book',
                        'order/{orderHash}',
                    ],
                },
                'private': {
                    'get': [
                        'balance',
                        'available_balance',
                        'user_history',
                    ],
                    'post': [
                        'limit_order/reserve',
                        'limit_order/place',
                        'market_order/reserve',
                        'market_order/place',
                    ],
                    'delete': [
                        'order/{orderHash}',
                        'orders',
                    ],
                },
            },
            'exceptions': {
                'exact': {
                    # "Schema validation failed for 'query'": ExchangeError,  # {"message": "Schema validation failed for 'query'", "errors": ...}
                    # "Logic validation failed for 'query'": ExchangeError,  # {"message": "Logic validation failed for 'query'", "errors": ...}
                    # "Schema validation failed for 'body'": ExchangeError,  # {"message": "Schema validation failed for 'body'", "errors": ...}
                    # "Logic validation failed for 'body'": ExchangeError,  # {"message": "Logic validation failed for 'body'", "errors": ...}
                    'Order not found': OrderNotFound,  # {"message":"Order not found","errors":...}
                },
                'broad': {
                    "Price can't exceed 8 digits in precision.": InvalidOrder,  # {"message":"Price can't exceed 8 digits in precision.","type":"paramPrice"}
                    'Order cannot be canceled': InvalidOrder,  # {"message":"Order cannot be canceled","type":"General error"}
                    'Greater than available wallet balance.': InsufficientFunds,
                    'Orderbook exhausted for intent': OrderNotFillable,  # {"message":"Orderbook exhausted for intent MARKET_INTENT:8yjjzd8b0e8yjjzd8b0fjjzd8b0g"}
                    'Fillable amount under minimum': InvalidOrder,  # {"message":"Fillable amount under minimum WETH trade size.","type":"paramQuoteTokenAmount"}
                    'Fillable amount over maximum': InvalidOrder,  # {"message":"Fillable amount over maximum TUSD trade size.","type":"paramQuoteTokenAmount"}
                    "Schema validation failed for 'params'": BadRequest,  # # {"message":"Schema validation failed for 'params'"}
                    'Service Temporarily Unavailable': ExchangeNotAvailable,
                },
            },
            'options': {
                'decimals': {},
                'fetchOrderMethod': 'fetch_order_from_history',
            },
        })

    def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        market = self.markets[symbol]
        key = 'quote'
        rate = market[takerOrMaker]
        cost = float(self.cost_to_precision(symbol, amount * rate))
        if side == 'sell':
            cost *= price
        else:
            key = 'base'
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': cost,
        }

    async def fetch_markets(self, params={}):
        markets = await self.publicGetTokenPairs()
        #
        #     [
        #       {
        #         "baseToken": {
        #           "address": "0xa8e9fa8f91e5ae138c74648c9c304f1c75003a8d",
        #           "symbol": "ZRX",
        #           "decimals": "18",
        #           "minAmount": "1000000000000000000",
        #           "maxAmount": "100000000000000000000000",
        #           "precision": "18"
        #         },
        #         "quoteToken": {
        #           "address": "0xc00fd9820cd2898cc4c054b7bf142de637ad129a",
        #           "symbol": "WETH",
        #           "decimals": "18",
        #           "minAmount": "5000000000000000",
        #           "maxAmount": "100000000000000000000",
        #           "precision": "18"
        #         }
        #       }
        #     ]
        #
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            baseToken = market['baseToken']
            quoteToken = market['quoteToken']
            baseId = baseToken['address']
            quoteId = quoteToken['address']
            base = baseToken['symbol']
            quote = quoteToken['symbol']
            base = self.common_currency_code(base)
            quote = self.common_currency_code(quote)
            symbol = base + '/' + quote
            id = baseId + '/' + quoteId
            baseDecimals = self.safe_integer(baseToken, 'decimals')
            quoteDecimals = self.safe_integer(quoteToken, 'decimals')
            self.options['decimals'][base] = baseDecimals
            self.options['decimals'][quote] = quoteDecimals
            precision = {
                'amount': -int(baseToken['precision']),
                'price': -int(quoteToken['precision']),
            }
            amountLimits = {
                'min': self.fromWei(self.safe_string(baseToken, 'minAmount'), 'ether', baseDecimals),
                'max': self.fromWei(self.safe_string(baseToken, 'maxAmount'), 'ether', baseDecimals),
            }
            priceLimits = {
                'min': None,
                'max': None,
            }
            costLimits = {
                'min': self.fromWei(self.safe_string(quoteToken, 'minAmount'), 'ether', quoteDecimals),
                'max': self.fromWei(self.safe_string(quoteToken, 'maxAmount'), 'ether', quoteDecimals),
            }
            limits = {
                'amount': amountLimits,
                'price': priceLimits,
                'cost': costLimits,
            }
            active = True
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    def parse_ohlcv(self, ohlcv, market=None, timeframe='5m', since=None, limit=None):
        baseDecimals = self.safe_integer(self.options['decimals'], market['base'], 18)
        return [
            self.safe_integer(ohlcv, 'startTime') * 1000,
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            self.fromWei(self.safe_string(ohlcv, 'baseVolume'), 'ether', baseDecimals),
            # self.safe_string(ohlcv, 'quoteVolume'),
        ]

    async def fetch_ohlcv(self, symbol, timeframe='5m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'baseTokenAddress': market['baseId'],
            'quoteTokenAddress': market['quoteId'],
            'interval': self.timeframes[timeframe],
            # 'endTime': endTime,  #(optional) Snapshot end time
        }
        if since is None:
            raise ExchangeError(self.id + ' fetchOHLCV requires a since argument')
        request['startTime'] = int(since / 1000)
        response = await self.publicGetCandlesticks(self.extend(request, params))
        #
        #   [
        #     {
        #         "high": "100.52",
        #         "low": "97.23",
        #         "open": "98.45",
        #         "close": "99.23",
        #         "baseVolume": "2400000000000000000000",
        #         "quoteVolume": "1200000000000000000000",
        #         "startTime": "1512929323784"
        #     },
        #     {
        #         "high": "100.52",
        #         "low": "97.23",
        #         "open": "98.45",
        #         "close": "99.23",
        #         "volume": "2400000000000000000000",
        #         "startTime": "1512929198980"
        #     }
        #   ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    async def fetch_balance_by_code(self, code, params={}):
        if not self.walletAddress or (self.walletAddress.find('0x') != 0):
            raise InvalidAddress(self.id + ' fetchBalanceByCode() requires the .walletAddress to be a "0x"-prefixed hexstring like "0xbF2d65B3b2907214EEA3562f21B80f6Ed7220377"')
        await self.load_markets()
        currency = self.currency(code)
        request = {
            'walletAddress': self.walletAddress.lower(),
            'tokenAddress': currency['id'],
        }
        response = await self.privateGetBalance(self.extend(request, params))
        #
        #     {"available":"0","committed":"0","total":"0"}
        #
        decimals = self.safe_integer(self.options['decimals'], code, 18)
        free = self.fromWei(self.safe_string(response, 'available'), 'ether', decimals)
        used = self.fromWei(self.safe_string(response, 'committed'), 'ether', decimals)
        total = self.fromWei(self.safe_string(response, 'total'), 'ether', decimals)
        return {
            'free': free,
            'used': used,
            'total': total,
        }

    async def fetch_balance(self, params={}):
        if not self.walletAddress or (self.walletAddress.find('0x') != 0):
            raise InvalidAddress(self.id + ' fetchBalance() requires the .walletAddress to be a "0x"-prefixed hexstring like "0xbF2d65B3b2907214EEA3562f21B80f6Ed7220377"')
        codes = self.safe_value(self.options, 'fetchBalanceCurrencies')
        if codes is None:
            codes = self.safe_value(params, 'codes')
        if (codes is None) or (not isinstance(codes, list)):
            raise ExchangeError(self.id + ' fetchBalance() requires a `codes` parameter(an array of currency codes)')
        await self.load_markets()
        result = {}
        for i in range(0, len(codes)):
            code = codes[i]
            result[code] = await self.fetch_balance_by_code(code)
        return self.parse_balance(result)

    def parse_bid_ask(self, bidask, priceKey=0, amountKey=1, market=None):
        if market is None:
            raise ArgumentsRequired(self.id + ' parseBidAsk requires a market argument')
        price = float(bidask[priceKey])
        amountDecimals = self.safe_integer(self.options['decimals'], market['base'], 18)
        #
        # the following does not work with self bidask: {"orderHash":"0x8b5d8d34eded1cbf8519733401ae3ced8069089fd16d5431cb3d4b016d7788f2","price":"133.74013659","availableAmount":"4652691526891295598045.34542621578779823835103356911924523765168638519704923461215973053000214547556058831637954647252647510035865072314678676592576536328447541178082827906517347971793654011427890554542683570544867337525450220078254745116898401756810404232673589363421879924390066378804261951784","creationTimestamp":"1542743835","expirationTimestampInSec":"1545339435"}
        # therefore we apply a dirty string-based patch
        #
        # amount = self.fromWei(bidask[amountKey], 'ether', amountDecimals)
        #
        amountString = self.safe_string(bidask, amountKey)
        amountParts = amountString.split('.')
        numParts = len(amountParts)
        if numParts == 2:
            amountString = amountParts[0]
        amount = self.fromWei(amountString, 'ether', amountDecimals)
        # return [price, amount, bidask]
        return [price, amount]

    def parse_order_book(self, orderbook, timestamp=None, bidsKey='bids', asksKey='asks', priceKey=0, amountKey=1, market=None):
        result = {
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'nonce': None,
        }
        sides = [bidsKey, asksKey]
        for i in range(0, len(sides)):
            side = sides[i]
            orders = []
            bidasks = self.safe_value(orderbook, side)
            for k in range(0, len(bidasks)):
                orders.append(self.parse_bid_ask(bidasks[k], priceKey, amountKey, market))
            result[side] = orders
        result[bidsKey] = self.sort_by(result[bidsKey], 0, True)
        result[asksKey] = self.sort_by(result[asksKey], 0)
        return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'baseTokenAddress': market['baseId'],
            'quoteTokenAddress': market['quoteId'],
        }
        if limit is not None:
            request['depth'] = limit
        response = await self.publicGetOrderBook(self.extend(request, params))
        #
        #     {
        #       "bids": [
        #         {
        #           "orderHash": "0x94629386298dee69ae63cd3e414336ae153b3f02cffb9ffc53ad71e166615618",
        #           "price": "0.00050915",
        #           "availableAmount": "100000000000000000000",
        #           "creationTimestamp": "1512929327792",
        #           "expirationTimestampInSec": "1534449466"
        #         }
        #       ],
        #       "asks": [
        #         {
        #           "orderHash": "0x94629386298dee69ae63cd3e414336ae153b3f02cffb9ffc53ad71e166615618",
        #           "price": "0.00054134",
        #           "availableAmount": "100000000000000000000",
        #           "creationTimestamp": "1512929323784",
        #           "expirationTimestampInSec": "1534449466"
        #         }
        #       ]
        #     }
        #
        return self.parse_order_book(response, None, 'bids', 'asks', 'price', 'availableAmount', market)

    def parse_ticker(self, ticker, market=None):
        #
        #     {
        #         "bid": "0.00050915",
        #         "ask": "0.00054134",
        #         "last": "0.00052718",
        #         "volume": "3000000000000000000",
        #         "timestamp": "1512929327792"
        #     }
        #
        timestamp = int(self.safe_float(ticker, 'timestamp') / 1000)
        symbol = None
        base = None
        if market is not None:
            symbol = market['symbol']
            base = market['base']
        baseDecimals = self.safe_integer(self.options['decimals'], base, 18)
        baseVolume = self.fromWei(self.safe_string(ticker, 'volume'), 'ether', baseDecimals)
        last = self.safe_float(ticker, 'last')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': None,
            'low': None,
            'bid': self.safe_float(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'ask'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': self.safe_float(ticker, 'priceChange'),
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': None,
            'info': ticker,
        }

    async def fetch_tickers(self, symbols=None, params={}):
        await self.load_markets()
        tickers = await self.publicGetTickers(params)
        #
        #     [{
        #     "baseTokenAddress": "0xa8e9fa8f91e5ae138c74648c9c304f1c75003a8d",
        #     "quoteTokenAddress": "0xc00fd9820cd2898cc4c054b7bf142de637ad129a",
        #     "ticker": {
        #         "bid": "0.00050915",
        #         "ask": "0.00054134",
        #         "last": "0.00052718",
        #         "volume": "3000000000000000000",
        #         "timestamp": "1512929327792"
        #     }
        #     }]
        #
        result = {}
        for i in range(0, len(tickers)):
            ticker = tickers[i]
            baseId = self.safe_string(ticker, 'baseTokenAddress')
            quoteId = self.safe_string(ticker, 'quoteTokenAddress')
            marketId = baseId + '/' + quoteId
            market = None
            symbol = marketId
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
            result[symbol] = self.parse_ticker(ticker['ticker'], market)
        return result

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'baseTokenAddress': market['baseId'],
            'quoteTokenAddress': market['quoteId'],
        }
        response = await self.publicGetTicker(self.extend(request, params))
        return self.parse_ticker(response, market)

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades
        #
        #     {
        #         "id": "37212",
        #         "transactionHash": "0x5e6e75e1aa681b51b034296f62ac19be7460411a2ad94042dd8ba637e13eac0c",
        #         "amount": "300000000000000000",
        #         "price": "0.00052718",
        # ------- they also have a "confirmed" status here â†“ -----------------
        #         "status": "filled",  # filled | settled | failed
        #         "lastUpdated": "1520265048996"
        #     }
        #
        # parseOrder trades(timeline "actions", "fills")
        #
        #     {     action: "confirmed",
        #            amount: "1000000000000000000",
        #          intentID: "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl",
        #            txHash: "0x043488fdc3f995bf9e632a32424e41ed126de90f8cb340a1ff006c2a74ca8336",
        #       blockNumber: "8094822",
        #         timestamp: "1532261686"                                                          }
        #
        timestamp = self.safe_integer(trade, 'lastUpdated')
        if timestamp is None:
            timestamp = self.safe_integer(trade, 'timestamp')
        if timestamp is not None:
            # their timestamps are in seconds, mostly
            timestamp = timestamp * 1000
        price = self.safe_float(trade, 'price')
        orderId = self.safe_string(trade, 'order')
        id = self.safe_string(trade, 'id')
        if id is None:
            id = self.safe_string_2(trade, 'transactionHash', 'txHash')
        symbol = None
        base = None
        if market is not None:
            symbol = market['symbol']
            base = market['base']
        baseDecimals = self.safe_integer(self.options['decimals'], base, 18)
        amount = self.fromWei(self.safe_string(trade, 'amount'), 'ether', baseDecimals)
        cost = None
        if amount is not None:
            if price is not None:
                cost = amount * price
        takerOrMaker = 'taker'
        fee = None
        # fee = self.calculate_fee(symbol, type, side, amount, price, takerOrMaker)
        return {
            'id': id,
            'order': orderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': None,
            'side': None,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
            'info': trade,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'baseTokenAddress': market['baseId'],
            'quoteTokenAddress': market['quoteId'],
        }
        response = await self.publicGetTradeHistory(self.extend(request, params))
        #
        #     [
        #       {
        #         "id": "37212",
        #         "transactionHash": "0x5e6e75e1aa681b51b034296f62ac19be7460411a2ad94042dd8ba637e13eac0c",
        #         "amount": "300000000000000000",
        #         "price": "0.00052718",
        #         "status": "filled",  # filled | settled | failed
        #         "lastUpdated": "1520265048996"
        #       }
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        errorMessage = self.id + ' createOrder() requires `exchange.walletAddress` and `exchange.privateKey`. The .walletAddress should be a "0x"-prefixed hexstring like "0xbF2d65B3b2907214EEA3562f21B80f6Ed7220377". The .privateKey for that wallet should be a "0x"-prefixed hexstring like "0xe4f40d465efa94c98aec1a51f574329344c772c1bce33be07fa20a56795fdd09".'
        if not self.walletAddress or (self.walletAddress.find('0x') != 0):
            raise InvalidAddress(errorMessage)
        if not self.privateKey or (self.privateKey.find('0x') != 0):
            raise InvalidAddress(errorMessage)
        await self.load_markets()
        makerOrTaker = self.safe_string(params, 'makerOrTaker')
        isMarket = (type == 'market')
        isMakerOrTakerUndefined = (makerOrTaker is None)
        isTaker = (makerOrTaker == 'taker')
        isMaker = (makerOrTaker == 'maker')
        if isMarket and not isMakerOrTakerUndefined and not isTaker:
            raise InvalidOrder(self.id + ' createOrder() ' + type + ' order type cannot be a ' + makerOrTaker + '. The createOrder() method of ' + type + ' type can be used with taker orders only.')
        query = self.omit(params, 'makerOrTaker')
        timestamp = self.milliseconds()
        market = self.market(symbol)
        baseDecimals = self.safe_integer(self.options['decimals'], market['base'], 18)
        reserveRequest = {
            'walletAddress': self.walletAddress.lower(),  # Your Wallet Address
            'baseTokenAddress': market['baseId'],  # Base token address
            'quoteTokenAddress': market['quoteId'],  # Quote token address
            'side': side,  # "buy" or "sell"
            'orderAmount': self.toWei(self.amount_to_precision(symbol, amount), 'ether', baseDecimals),  # Base token amount in wei
            'feeOption': 'feeInNative',  # Fees can be paid in native currency("feeInNative"), or ZRX("feeInZRX")
        }
        if type == 'limit':
            reserveRequest['price'] = self.price_to_precision(symbol, price)  # Price denominated in quote tokens(limit orders only)
        method = 'privatePost' + self.capitalize(type) + 'Order'
        reserveMethod = method + 'Reserve'
        reserveResponse = await getattr(self, reserveMethod)(self.extend(reserveRequest, query))
        #
        # ---- market orders -------------------------------------------------
        #
        # reserveResponse =
        #     {      matchingOrderID:   "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl",
        #       unsignedMatchingOrder: {                     maker: "",
        #                                                     taker: "0x00ba938cc0df182c25108d7bf2ee3d37bce07513",
        #                                         makerTokenAddress: "0xd0a1e359811322d97991e03f863a0c30c2cf029c",
        #                                         takerTokenAddress: "0x6ff6c0ff1d68b964901f986d4c9fa3ac68346570",
        #                                          makerTokenAmount: "27100000000000000",
        #                                          takerTokenAmount: "874377028175459241",
        #                                                  makerFee: "0",
        #                                                  takerFee: "0",
        #                                expirationUnixTimestampSec: "1534809575",
        #                                              feeRecipient: "0x88a64b5e882e5ad851bea5e7a3c8ba7c523fecbe",
        #                                                      salt: "3610846705800197954038657082705100176266402776121341340841167002345284333867",
        #                                   exchangeContractAddress: "0x90fe2af704b34e0224bf2299c838e04d4dcf1364"                                    }}
        #
        # ---- limit orders --------------------------------------------------
        #
        # 1. if the order is completely fillable:
        #    + unsignedMatchingOrder will be present
        #    - unsignedTargetOrder will be missing
        # 2. if the order is partially fillable:
        #    + unsignedMatchingOrder and
        #    + unsignedTarget order will be present
        # 3. if the order is not fillable at the moment:
        #    + unsignedTargetOrder will be present
        #    - unsignedMatchingOrder will be missing
        # In other words, unsignedMatchingOrder is only present
        # if there is some fillable amount in the order book.
        #
        # Note: ecSignature is empty at self point and missing in the actual
        # response, there's no need for it here at self point anyway.
        #
        # reserveResponse =
        #     {unsignedTargetOrder: {                     maker: "",
        #                                                   taker: "0x00ba938cc0df182c25108d7bf2ee3d37bce07513",
        #                                       makerTokenAddress: "0xd0a1e359811322d97991e03f863a0c30c2cf029c",
        #                                       takerTokenAddress: "0x6ff6c0ff1d68b964901f986d4c9fa3ac68346570",
        #                                        makerTokenAmount: "2700000000000000",
        #                                        takerTokenAmount: "937912044575392743",
        #                                                makerFee: "0",
        #                                                takerFee: "0",
        #                              expirationUnixTimestampSec: "1534813319",
        #                                            feeRecipient: "0x88a64b5e882e5ad851bea5e7a3c8ba7c523fecbe",
        #                                                    salt: "54933934472162523007303314622614098849759889305199720392701919179357703099693",
        #                                 exchangeContractAddress: "0x90fe2af704b34e0224bf2299c838e04d4dcf1364"                                     }}
        #
        # reserveResponse =
        #     {
        #       "unsignedTargetOrder": {
        #         "exchangeContractAddress": "0x516bdc037df84d70672b2d140835833d3623e451",
        #         "maker": "",
        #         "taker": "0x00ba938cc0df182c25108d7bf2ee3d37bce07513",
        #         "makerTokenAddress": "0x7cc7fdd065cfa9c7f4f6a3c1bfc6dfcb1a3177aa",
        #         "takerTokenAddress": "0x17f15936ef3a2da5593033f84487cbe9e268f02f",
        #         "feeRecipient": "0x88a64b5e882e5ad851bea5e7a3c8ba7c523fecbe",
        #         "makerTokenAmount": "10000000000000000000",
        #         "takerTokenAmount": "10000000000000000000",
        #         "makerFee": "0",
        #         "takerFee": "0",
        #         "expirationUnixTimestampSec": "525600",
        #         "salt": "37800593840622773016017857006417214310534675667008850948421364357744823963318",
        #         "ecSignature": {
        #           "v": 0,
        #           "r": "",
        #           "s": ""
        #         }
        #       },
        #       "unsignedMatchingOrder": {
        #         "exchangeContractAddress": "0x516bdc037df84d70672b2d140835833d3623e451",
        #         "maker": "",
        #         "taker": "0x00ba938cc0df182c25108d7bf2ee3d37bce07513",
        #         "makerTokenAddress": "0x7cc7fdd065cfa9c7f4f6a3c1bfc6dfcb1a3177aa",
        #         "takerTokenAddress": "0x17f15936ef3a2da5593033f84487cbe9e268f02f",
        #         "feeRecipient": "0x88a64b5e882e5ad851bea5e7a3c8ba7c523fecbe",
        #         "makerTokenAmount": "10000000000000000000",
        #         "takerTokenAmount": "10000000000000000000",
        #         "makerFee": "0",
        #         "takerFee": "0",
        #         "expirationUnixTimestampSec": "525600",
        #         "salt": "37800593840622773016017857006417214310534675667008850948421364357744823963318",
        #         "ecSignature": {
        #           "v": 0,
        #           "r": "",
        #           "s": ""
        #         }
        #       },
        #       "matchingOrderID": "MARKET_INTENT:8ajjh92s1r8ajjh92s1sjjh92s1t"
        #     }
        #
        # --------------------------------------------------------------------
        unsignedMatchingOrder = self.safe_value(reserveResponse, 'unsignedMatchingOrder')
        unsignedTargetOrder = self.safe_value(reserveResponse, 'unsignedTargetOrder')
        isUnsignedMatchingOrderDefined = (unsignedMatchingOrder is not None)
        isUnsignedTargetOrderDefined = (unsignedTargetOrder is not None)
        makerAddress = {
            'maker': self.walletAddress.lower(),
        }
        placeRequest = {}
        signedMatchingOrder = None
        signedTargetOrder = None
        if isUnsignedMatchingOrderDefined and isUnsignedTargetOrderDefined:
            if isTaker:
                signedMatchingOrder = self.signZeroExOrder(self.extend(unsignedMatchingOrder, makerAddress), self.privateKey)
                placeRequest['signedMatchingOrder'] = signedMatchingOrder
                placeRequest['matchingOrderID'] = reserveResponse['matchingOrderID']
            elif isMaker:
                signedTargetOrder = self.signZeroExOrder(self.extend(unsignedTargetOrder, makerAddress), self.privateKey)
                placeRequest['signedTargetOrder'] = signedTargetOrder
            else:
                signedMatchingOrder = self.signZeroExOrder(self.extend(unsignedMatchingOrder, makerAddress), self.privateKey)
                placeRequest['signedMatchingOrder'] = signedMatchingOrder
                placeRequest['matchingOrderID'] = reserveResponse['matchingOrderID']
                signedTargetOrder = self.signZeroExOrder(self.extend(unsignedTargetOrder, makerAddress), self.privateKey)
                placeRequest['signedTargetOrder'] = signedTargetOrder
        elif isUnsignedMatchingOrderDefined:
            if isMaker:
                raise OrderImmediatelyFillable(self.id + ' createOrder() ' + type + ' order to ' + side + ' ' + symbol + ' is not fillable as a maker order')
            else:
                signedMatchingOrder = self.signZeroExOrder(self.extend(unsignedMatchingOrder, makerAddress), self.privateKey)
                placeRequest['signedMatchingOrder'] = signedMatchingOrder
                placeRequest['matchingOrderID'] = reserveResponse['matchingOrderID']
        elif isUnsignedTargetOrderDefined:
            if isTaker or isMarket:
                raise OrderNotFillable(self.id + ' createOrder() ' + type + ' order to ' + side + ' ' + symbol + ' is not fillable as a taker order')
            else:
                signedTargetOrder = self.signZeroExOrder(self.extend(unsignedTargetOrder, makerAddress), self.privateKey)
                placeRequest['signedTargetOrder'] = signedTargetOrder
        else:
            raise OrderNotFillable(self.id + ' ' + type + ' order to ' + side + ' ' + symbol + ' is not fillable at the moment')
        placeMethod = method + 'Place'
        placeResponse = await getattr(self, placeMethod)(self.extend(placeRequest, query))
        #
        # ---- market orders -------------------------------------------------
        #
        # placeResponse =
        #     {matchingOrder: {transactionHash: "0x043488fdc3f995bf9e632a32424e41ed126de90f8cb340a1ff006c2a74ca8336",
        #                                 amount: "1000000000000000000",
        #                              orderHash: "0xe815dc92933b68e7fc2b7102b8407ba7afb384e4080ac8d28ed42482933c5cf5"  },
        #            parentID:   "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl"                                              }
        #
        # ---- limit orders -------------------------------------------------
        #
        # placeResponse =
        #     {targetOrder: {   amount: "1000000000000000000",
        #                      orderHash: "0x517aef1ce5027328c40204833b624f04a54c913e93cffcdd500fe9252c535251"},
        #          parentID:   "MARKET_INTENT:90jjw50gpk90jjw50gpljjw50gpm"                                       }
        #
        # placeResponse =
        #     {
        #         "targetOrder": {
        #             "orderHash": "0x94629386298dee69ae63cd3e414336ae153b3f02cffb9ffc53ad71e166615618",
        #             "amount": "100000000000"
        #         },
        #         "matchingOrder": {
        #             "orderHash": "0x3d6b287c1dc79262d2391ae2ca9d050fdbbab2c8b3180e4a46f9f321a7f1d7a9",
        #             "transactionHash": "0x5e6e75e1aa681b51b034296f62ac19be7460411a2ad94042dd8ba637e13eac0c",
        #             "amount": "100000000000"
        #         }
        #     }
        #
        matchingOrder = self.safe_value(placeResponse, 'matchingOrder')
        targetOrder = self.safe_value(placeResponse, 'targetOrder')
        orderParams = {
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'price': price,
            'side': side,
            'filled': 0,
            'status': 'open',
        }
        taker = None
        maker = None
        if matchingOrder is not None:
            matchingOrder = self.extend(signedMatchingOrder, matchingOrder)
            taker = self.parse_order(matchingOrder, market)
            taker = self.extend(taker, {
                'type': 'market',
                'remaining': taker['amount'],
            }, orderParams)
            if isTaker:
                return taker
        if targetOrder is not None:
            targetOrder = self.extend(signedTargetOrder, targetOrder)
            maker = self.parse_order(targetOrder, market)
            maker = self.extend(maker, {
                'type': 'limit',
                'remaining': maker['amount'],
            }, orderParams)
            if isMaker:
                return maker
        return {
            'info': self.extend(reserveResponse, placeRequest, placeResponse),
            'maker': maker,
            'taker': taker,
        }

    async def cancel_order(self, id, symbol=None, params={}):
        await self.load_markets()
        request = {
            'orderHash': id,
        }
        response = await self.privateDeleteOrderOrderHash(self.extend(request, params))
        #
        #     {
        #       "canceledOrder": {
        #         "orderHash": "0x3d6b287c1dc79262d2391ae2ca9d050fdbbab2c8b3180e4a46f9f321a7f1d7a9",
        #         "amount": "100000000000"
        #       }
        #     }
        #
        market = None
        if symbol is not None:
            market = self.market(symbol)
        return self.extend(self.parse_order(response['canceledOrder'], market), {
            'status': 'canceled',
        })

    async def cancel_all_orders(self, symbols=None, params={}):
        response = await self.privateDeleteOrders(params)
        #
        #     [{
        #       "canceledOrder": {
        #         "orderHash": "0x3d6b287c1dc79262d2391ae2ca9d050fdbbab2c8b3180e4a46f9f321a7f1d7a9",
        #         "amount": "100000000000"
        #       }
        #     }]
        #
        return response

    def parse_order_status(self, status):
        statuses = {
            'placed': 'open',
            'reserved': 'open',
            'filled': 'closed',
            'settled': 'closed',
            'confirmed': 'closed',
            'returned': 'open',
            'canceled': 'canceled',
            'pruned': 'failed',
        }
        if status in statuses:
            return statuses[status]
        return status

    def parse_order(self, order, market=None):
        #
        # fetchOrder, fetchOrderBook
        #
        #     {
        #       "baseTokenAddress": "0x7cc7fdd065cfa9c7f4f6a3c1bfc6dfcb1a3177aa",
        #       "quoteTokenAddress": "0x17f15936ef3a2da5593033f84487cbe9e268f02f",
        #       "side": "buy",
        #       "amount": "10000000000000000000",
        #       "price": "1.000",
        #       "created": "1512929327792",
        #       "expires": "1512929897118",
        #       "zeroExOrder": {
        #         "exchangeContractAddress": "0x516bdc037df84d70672b2d140835833d3623e451",
        #         "maker": "0x006dc83e5b21854d4afc44c9b92a91e0349dda13",
        #         "taker": "0x00ba938cc0df182c25108d7bf2ee3d37bce07513",
        #         "makerTokenAddress": "0x7cc7fdd065cfa9c7f4f6a3c1bfc6dfcb1a3177aa",
        #         "takerTokenAddress": "0x17f15936ef3a2da5593033f84487cbe9e268f02f",
        #         "feeRecipient": "0x88a64b5e882e5ad851bea5e7a3c8ba7c523fecbe",
        #         "makerTokenAmount": "10000000000000000000",
        #         "takerTokenAmount": "10000000000000000000",
        #         "makerFee": "0",
        #         "takerFee": "0",
        #         "expirationUnixTimestampSec": "525600",
        #         "salt": "37800593840622773016017857006417214310534675667008850948421364357744823963318",
        #         "orderHash": "0x94629386298dee69ae63cd3e414336ae153b3f02cffb9ffc53ad71e166615618",
        #         "ecSignature": {
        #           "v": 28,
        #           "r": "0x5307b6a69e7cba8583e1de39efb93a9ae1afc11849e79d99f462e49c18c4d6e4",
        #           "s": "0x5950e82364227ccca95c70b47375e8911a2039d3040ba0684329634ebdced160"
        #         }
        #       }
        #     }
        #
        # fetchOrders
        #
        #     {             orderHash:   "0xe815dc92933b68e7fc2b7102b8407ba7afb384e4080ac8d28ed42482933c5cf5",
        #             baseTokenAddress:   "0x6ff6c0ff1d68b964901f986d4c9fa3ac68346570",
        #            quoteTokenAddress:   "0xd0a1e359811322d97991e03f863a0c30c2cf029c",
        #                         side:   "buy",
        #                        price:   "0.0271",
        #                   openAmount:   "0",
        #               reservedAmount:   "0",
        #                 filledAmount:   "0",
        #                settledAmount:   "0",
        #              confirmedAmount:   "1000000000000000000",
        #                 failedAmount:   "0",
        #                   deadAmount:   "0",
        #                 prunedAmount:   "0",
        #                    feeAmount:   "125622971824540759",
        #                    feeOption:   "feeInNative",
        #                     parentID:   "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl",
        #       siblingTargetOrderHash:    null,
        #                     timeline: [{     action: "filled",
        #                                        amount: "1000000000000000000",
        #                                      intentID: "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl",
        #                                        txHash:  null,
        #                                   blockNumber: "0",
        #                                     timestamp: "1532217579"                                  },
        #                                 {     action: "settled",
        #                                        amount: "1000000000000000000",
        #                                      intentID: "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl",
        #                                        txHash: "0x043488fdc3f995bf9e632a32424441ed126de90f8cb340a1ff006c2a74ca8336",
        #                                   blockNumber: "8094822",
        #                                     timestamp: "1532261671"                                                          },
        #                                 {     action: "confirmed",
        #                                        amount: "1000000000000000000",
        #                                      intentID: "MARKET_INTENT:90jjw2s7gj90jjw2s7gkjjw2s7gl",
        #                                        txHash: "0x043488fdc3f995bf9e632a32424441ed126de90f8cb340a1ff006c2a74ca8336",
        #                                   blockNumber: "8094822",
        #                                     timestamp: "1532261686"                                                          }  ]}
        #
        #
        #
        zeroExOrder = self.safe_value(order, 'zeroExOrder')
        id = self.safe_string(order, 'orderHash')
        if (id is None) and(zeroExOrder is not None):
            id = self.safe_string(zeroExOrder, 'orderHash')
        side = self.safe_string(order, 'side')
        type = self.safe_string(order, 'type')  # injected from outside
        timestamp = self.safe_integer(order, 'created')
        timestamp = timestamp * 1000 if (timestamp is not None) else timestamp
        symbol = None
        baseId = self.safe_string(order, 'baseTokenAddress')
        quoteId = self.safe_string(order, 'quoteTokenAddress')
        marketId = None
        if baseId is not None and quoteId is not None:
            marketId = baseId + '/' + quoteId
        market = self.safe_value(self.markets_by_id, marketId, market)
        base = None
        if market is not None:
            symbol = market['symbol']
            base = market['base']
        baseDecimals = self.safe_integer(self.options['decimals'], base, 18)
        price = self.safe_float(order, 'price')
        openAmount = self.fromWei(self.safe_string(order, 'openAmount'), 'ether', baseDecimals)
        reservedAmount = self.fromWei(self.safe_string(order, 'reservedAmount'), 'ether', baseDecimals)
        filledAmount = self.fromWei(self.safe_string(order, 'filledAmount'), 'ether', baseDecimals)
        settledAmount = self.fromWei(self.safe_string(order, 'settledAmount'), 'ether', baseDecimals)
        confirmedAmount = self.fromWei(self.safe_string(order, 'confirmedAmount'), 'ether', baseDecimals)
        failedAmount = self.fromWei(self.safe_string(order, 'failedAmount'), 'ether', baseDecimals)
        deadAmount = self.fromWei(self.safe_string(order, 'deadAmount'), 'ether', baseDecimals)
        prunedAmount = self.fromWei(self.safe_string(order, 'prunedAmount'), 'ether', baseDecimals)
        amount = self.fromWei(self.safe_string(order, 'amount'), 'ether', baseDecimals)
        if amount is None:
            amount = self.sum(openAmount, reservedAmount, filledAmount, settledAmount, confirmedAmount, failedAmount, deadAmount, prunedAmount)
        filled = self.sum(filledAmount, settledAmount, confirmedAmount)
        remaining = None
        lastTradeTimestamp = None
        timeline = self.safe_value(order, 'timeline')
        trades = None
        status = None
        if timeline is not None:
            numEvents = len(timeline)
            if numEvents > 0:
                # status = self.parse_order_status(self.safe_string(timeline[numEvents - 1], 'action'))
                timelineEventsGroupedByAction = self.group_by(timeline, 'action')
                if 'error' in timelineEventsGroupedByAction:
                    status = 'failed'
                if 'placed' in timelineEventsGroupedByAction:
                    placeEvents = self.safe_value(timelineEventsGroupedByAction, 'placed')
                    if amount is None:
                        amount = self.fromWei(self.safe_string(placeEvents[0], 'amount'), 'ether', baseDecimals)
                    timestamp = self.safe_integer(placeEvents[0], 'timestamp')
                    timestamp = timestamp * 1000 if (timestamp is not None) else timestamp
                else:
                    if 'filled' in timelineEventsGroupedByAction:
                        timestamp = self.safe_integer(timelineEventsGroupedByAction['filled'][0], 'timestamp')
                        timestamp = timestamp * 1000 if (timestamp is not None) else timestamp
                if 'filled' in timelineEventsGroupedByAction:
                    fillEvents = self.safe_value(timelineEventsGroupedByAction, 'filled')
                    numFillEvents = len(fillEvents)
                    if timestamp is None:
                        timestamp = self.safe_integer(fillEvents[0], 'timestamp')
                        timestamp = timestamp * 1000 if (timestamp is not None) else timestamp
                    lastTradeTimestamp = self.safe_integer(fillEvents[numFillEvents - 1], 'timestamp')
                    lastTradeTimestamp = lastTradeTimestamp * 1000 if (lastTradeTimestamp is not None) else lastTradeTimestamp
                    trades = []
                    for i in range(0, numFillEvents):
                        trade = self.parse_trade(self.extend(fillEvents[i], {
                            'price': price,
                        }), market)
                        trades.append(self.extend(trade, {
                            'order': id,
                            'type': type,
                            'side': side,
                        }))
        cost = None
        if filled is not None:
            if remaining is None:
                if amount is not None:
                    remaining = amount - filled
            if price is not None:
                cost = filled * price
        fee = None
        feeCost = self.safe_string(order, 'feeAmount')
        if feeCost is not None:
            feeOption = self.safe_string(order, 'feeOption')
            feeCurrency = None
            if feeOption == 'feeInNative':
                if market is not None:
                    feeCurrency = market['base']
            elif feeOption == 'feeInZRX':
                feeCurrency = 'ZRX'
            else:
                raise NotSupported(self.id + ' encountered an unsupported order fee option: ' + feeOption)
            feeDecimals = self.safe_integer(self.options['decimals'], feeCurrency, 18)
            fee = {
                'cost': self.fromWei(feeCost, 'ether', feeDecimals),
                'currency': feeCurrency,
            }
        amountPrecision = market['precision']['amount'] if market else 8
        if remaining is not None:
            if status is None:
                status = 'open'
                rest = remaining - failedAmount - deadAmount - prunedAmount
                if rest < math.pow(10, -amountPrecision):
                    status = 'canceled' if (filled < amount) else 'closed'
        result = {
            'info': order,
            'id': id,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'amount': amount,
            'remaining': remaining,
            'filled': filled,
            'status': status,
            'fee': fee,
            'trades': trades,
        }
        return result

    async def fetch_open_order(self, id, symbol=None, params={}):
        method = self.options['fetchOrderMethod']
        return await getattr(self, method)(id, symbol, self.extend({
            'openAmount': 1,
        }, params))

    async def fetch_closed_order(self, id, symbol=None, params={}):
        method = self.options['fetchOrderMethod']
        return await getattr(self, method)(id, symbol, self.extend(params))

    async def fetch_order_from_history(self, id, symbol=None, params={}):
        orders = await self.fetch_orders(symbol, None, None, self.extend({
            'orderHash': id,
        }, params))
        ordersById = self.index_by(orders, 'id')
        if id in ordersById:
            return ordersById[id]
        raise OrderNotFound(self.id + ' could not find order ' + id + ' in order history')

    async def fetch_order_by_id(self, id, symbol=None, params={}):
        await self.load_markets()
        request = {
            'orderHash': id,
        }
        response = await self.publicGetOrderOrderHash(self.extend(request, params))
        #
        #     {
        #       "baseTokenAddress": "0x7cc7fdd065cfa9c7f4f6a3c1bfc6dfcb1a3177aa",
        #       "quoteTokenAddress": "0x17f15936ef3a2da5593033f84487cbe9e268f02f",
        #       "side": "buy",
        #       "amount": "10000000000000000000",
        #       "price": "1.000",
        #       "created": "1512929327792",
        #       "expires": "1512929897118",
        #       "zeroExOrder": {
        #         "exchangeContractAddress": "0x516bdc037df84d70672b2d140835833d3623e451",
        #         "maker": "0x006dc83e5b21854d4afc44c9b92a91e0349dda13",
        #         "taker": "0x00ba938cc0df182c25108d7bf2ee3d37bce07513",
        #         "makerTokenAddress": "0x7cc7fdd065cfa9c7f4f6a3c1bfc6dfcb1a3177aa",
        #         "takerTokenAddress": "0x17f15936ef3a2da5593033f84487cbe9e268f02f",
        #         "feeRecipient": "0x88a64b5e882e5ad851bea5e7a3c8ba7c523fecbe",
        #         "makerTokenAmount": "10000000000000000000",
        #         "takerTokenAmount": "10000000000000000000",
        #         "makerFee": "0",
        #         "takerFee": "0",
        #         "expirationUnixTimestampSec": "525600",
        #         "salt": "37800593840622773016017857006417214310534675667008850948421364357744823963318",
        #         "orderHash": "0x94629386298dee69ae63cd3e414336ae153b3f02cffb9ffc53ad71e166615618",
        #         "ecSignature": {
        #           "v": 28,
        #           "r": "0x5307b6a69e7cba8583e1de39efb93a9ae1afc11849e79d99f462e49c18c4d6e4",
        #           "s": "0x5950e82364227ccca95c70b47375e8911a2039d3040ba0684329634ebdced160"
        #         }
        #       }
        #     }
        #
        return self.parse_order(response)

    async def fetch_order(self, id, symbol=None, params={}):
        request = {
            'orderHash': id,
        }
        orders = await self.fetch_orders(symbol, None, None, self.extend(request, params))
        numOrders = len(orders)
        if numOrders != 1:
            raise OrderNotFound(self.id + ' order ' + id + ' not found')
        return orders[0]

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {
            # openAmount(optional) Return orders with an openAmount greater than or equal to self value
            # reservedAmount(optional) Return orders with a reservedAmount greater than or equal to self value
            # filledAmount(optional) Return orders with a filledAmount greater than or equal to self value
            # confirmedAmount(optional) Return orders with a confirmedAmount greater than or equal to self value
            # deadAmount(optional) Return orders with a deadAmount greater than or equal to self value
            # baseTokenAddress(optional) Return orders with a baseTokenAddress equal to self value
            # quoteTokenAddress(optional) Return orders with a quoteTokenAddress equal to self value
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['baseTokenAddress'] = market['baseId']
            request['quoteTokenAddress'] = market['quoteId']
        if limit is not None:
            # request['start'] = 0  # the number of orders to offset from the end
            request['limit'] = limit
        response = await self.privateGetUserHistory(self.extend(request, params))
        #
        #     [
        #       {
        #         "orderHash": "0x94629386298dee69ae63cd3e414336ae153b3f02cffb9ffc53ad71e166615618",
        #         "baseTokenAddress": "0x323b5d4c32345ced77393b3530b1eed0f346429d",
        #         "quoteTokenAddress": "0xef7fff64389b814a946f3e92105513705ca6b990",
        #         "side": "buy",
        #         "openAmount": "10000000000000000000",
        #         "filledAmount": "0",
        #         "reservedAmount": "0",
        #         "settledAmount": "0",
        #         "confirmedAmount": "0",
        #         "deadAmount": "0",
        #         "price": "0.00050915",
        #         "timeline": [
        #           {
        #             "action": "placed",
        #             "amount": "10000000000000000000",
        #             "timestamp": "1512929327792"
        #           }
        #         ]
        #       }
        #     ]
        #
        return self.parse_orders(response, None, since, limit)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        return await self.fetch_orders(symbol, since, limit, self.extend({
            'openAmount': 1,  # returns open orders with remaining openAmount >= 1
        }, params))

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        return await self.fetch_orders(symbol, since, limit, self.extend({
            'openAmount': 0,  # returns closed orders with remaining openAmount == 0
        }, params))

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'] + '/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'private':
            self.check_required_credentials()
            timestamp = str(self.seconds())
            prehash = self.apiKey + timestamp + method
            if method == 'POST':
                body = self.json(query)
                prehash += body
            else:
                if query:
                    url += '?' + self.urlencode(query)
                prehash += self.json({})
            signature = self.hmac(self.encode(prehash), self.encode(self.secret), hashlib.sha256, 'base64')
            headers = {
                'TOX-ACCESS-KEY': self.apiKey,
                'TOX-ACCESS-SIGN': signature,
                'TOX-ACCESS-TIMESTAMP': timestamp,
                'Content-Type': 'application/json',
            }
        elif api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response):
        if not isinstance(body, basestring):
            return  # fallback to default error handler
        if len(body) < 2:
            return  # fallback to default error handler
        # code 401 and plain body 'Authentication failed'(with single quotes)
        # self error is sent if you do not submit a proper Content-Type
        if body == "'Authentication failed'":
            raise AuthenticationError(self.id + ' ' + body)
        if (body[0] == '{') or (body[0] == '['):
            message = self.safe_string(response, 'message')
            if message is not None:
                #
                # {"message":"Schema validation failed for 'query'","errors":[{"name":"required","argument":"startTime","message":"requires property \"startTime\"","instance":{"baseTokenAddress":"0x6ff6c0ff1d68b964901f986d4c9fa3ac68346570","quoteTokenAddress":"0xd0a1e359811322d97991e03f863a0c30c2cf029c","interval":"300"},"property":"instance"}]}
                # {"message":"Logic validation failed for 'query'","errors":[{"message":"startTime should be between 0 and current date","type":"startTime"}]}
                # {"message":"Order not found","errors":[]}
                # {"message":"Orderbook exhausted for intent MARKET_INTENT:8yjjzd8b0e8yjjzd8b0fjjzd8b0g"}
                # {"message":"Intent validation failed.","errors":[{"message":"Greater than available wallet balance.","type":"walletBaseTokenAmount"}]}
                # {"message":"Schema validation failed for 'body'","errors":[{"name":"anyOf","argument":["[subschema 0]","[subschema 1]","[subschema 2]"],"message":"is not any of [subschema 0],[subschema 1],[subschema 2]","instance":{"signedTargetOrder":{"error":{"message":"Unsigned target order validation failed.","errors":[{"message":"Greater than available wallet balance.","type":"walletBaseTokenAmount"}]},"maker":"0x1709c02cd7327d391a39a7671af8a91a1ef8a47b","orderHash":"0xda007ea8b5eca71ac96fe4072f7c1209bb151d898a9cc89bbeaa594f0491ee49","ecSignature":{"v":27,"r":"0xb23ce6c4a7b5d51d77e2d00f6d1d472a3b2e72d5b2be1510cfeb122f9366b79e","s":"0x07d274e6d7a00b65fc3026c2f9019215b1e47a5ac4d1f05e03f90550d27109be"}}},"property":"instance"}]}
                # {"message":"Schema validation failed for 'params'","errors":[{"name":"pattern","argument":"^0x[0-9a-fA-F]{64}$","message":"does not match pattern \"^0x[0-9a-fA-F]{64}$\"","instance":"1","property":"instance.orderHash"}]}
                #
                feedback = self.id + ' ' + self.json(response)
                exact = self.exceptions['exact']
                if message in exact:
                    raise exact[message](feedback)
                broad = self.exceptions['broad']
                broadKey = self.findBroadlyMatchedKey(broad, body)
                if broadKey is not None:
                    raise broad[broadKey](feedback)
                raise ExchangeError(feedback)  # unknown message
