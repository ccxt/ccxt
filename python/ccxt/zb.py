# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import RequestTimeout


class zb(Exchange):

    def describe(self):
        return self.deep_extend(super(zb, self).describe(), {
            'id': 'zb',
            'name': 'ZB',
            'countries': ['CN'],
            'rateLimit': 100,
            'version': 'v1',
            'certified': True,
            'pro': True,
            'has': {
                'CORS': None,
                'spot': True,
                'margin': None,  # has but unimplemented
                'swap': None,  # has but unimplemented
                'future': None,
                'option': None,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'createMarketOrder': None,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchDepositAddresses': True,
                'fetchDeposits': True,
                'fetchFundingRate': True,
                'fetchFundingRateHistory': True,
                'fetchMarkets': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchWithdrawals': True,
                'setLeverage': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '1min',
                '3m': '3min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '1hour',
                '2h': '2hour',
                '4h': '4hour',
                '6h': '6hour',
                '12h': '12hour',
                '1d': '1day',
                '3d': '3day',
                '1w': '1week',
            },
            'exceptions': {
                'ws': {
                    #  '1000': ExchangeError,  # The call is successful.
                    '1001': ExchangeError,  # General error prompt
                    '1002': ExchangeError,  # Internal Error
                    '1003': AuthenticationError,  # Fail to verify
                    '1004': AuthenticationError,  # The transaction password is locked
                    '1005': AuthenticationError,  # Wrong transaction password, please check it and re-enter。
                    '1006': PermissionDenied,  # Real-name authentication is pending approval or unapproved
                    '1007': ExchangeError,  # Channel does not exist
                    '1009': OnMaintenance,  # This interface is under maintenance
                    '1010': ExchangeNotAvailable,  # Not available now
                    '1012': PermissionDenied,  # Insufficient permissions
                    '1013': ExchangeError,  # Cannot trade, please contact email: support@zb.cn for support.
                    '1014': ExchangeError,  # Cannot sell during the pre-sale period
                    '2001': InsufficientFunds,  # Insufficient CNY account balance
                    '2002': InsufficientFunds,  # Insufficient BTC account balance
                    '2003': InsufficientFunds,  # Insufficient LTC account balance
                    '2005': InsufficientFunds,  # Insufficient ETH account balance
                    '2006': InsufficientFunds,  # ETCInsufficient account balance
                    '2007': InsufficientFunds,  # BTSInsufficient account balance
                    '2008': InsufficientFunds,  # EOSInsufficient account balance
                    '2009': InsufficientFunds,  # BCCInsufficient account balance
                    '3001': OrderNotFound,  # Order not found or is completed
                    '3002': InvalidOrder,  # Invalid amount
                    '3003': InvalidOrder,  # Invalid quantity
                    '3004': AuthenticationError,  # User does not exist
                    '3005': BadRequest,  # Invalid parameter
                    '3006': PermissionDenied,  # Invalid IP or not consistent with the bound IP
                    '3007': RequestTimeout,  # The request time has expired
                    '3008': ExchangeError,  # Transaction not found
                    '3009': InvalidOrder,  # The price exceeds the limit
                    '3010': PermissionDenied,  # It fails to place an order, due to you have set up to prohibit trading of self market.
                    '3011': InvalidOrder,  # The entrusted price is abnormal, please modify it and place order again
                    '3012': InvalidOrder,  # Duplicate custom customerOrderId
                    '4001': AccountSuspended,  # APIThe interface is locked for one hour
                    '4002': RateLimitExceeded,  # Request too frequently
                },
                'exact': {
                    # '1000': 'Successful operation',
                    '1001': ExchangeError,  # 'General error message',
                    '1002': ExchangeError,  # 'Internal error',
                    '1003': AuthenticationError,  # 'Verification does not pass',
                    '1004': AuthenticationError,  # 'Funding security password lock',
                    '1005': AuthenticationError,  # 'Funds security password is incorrect, please confirm and re-enter.',
                    '1006': AuthenticationError,  # 'Real-name certification pending approval or audit does not pass',
                    '1009': ExchangeNotAvailable,  # 'This interface is under maintenance',
                    '1010': ExchangeNotAvailable,  # Not available now
                    '1012': PermissionDenied,  # Insufficient permissions
                    '1013': ExchangeError,  # Cannot trade, please contact email: support@zb.cn for support.
                    '1014': ExchangeError,  # Cannot sell during the pre-sale period
                    '2001': InsufficientFunds,  # 'Insufficient CNY Balance',
                    '2002': InsufficientFunds,  # 'Insufficient BTC Balance',
                    '2003': InsufficientFunds,  # 'Insufficient LTC Balance',
                    '2005': InsufficientFunds,  # 'Insufficient ETH Balance',
                    '2006': InsufficientFunds,  # 'Insufficient ETC Balance',
                    '2007': InsufficientFunds,  # 'Insufficient BTS Balance',
                    '2008': InsufficientFunds,  # EOSInsufficient account balance
                    '2009': InsufficientFunds,  # 'Account balance is not enough',
                    '3001': OrderNotFound,  # 'Pending orders not found',
                    '3002': InvalidOrder,  # 'Invalid price',
                    '3003': InvalidOrder,  # 'Invalid amount',
                    '3004': AuthenticationError,  # 'User does not exist',
                    '3005': BadRequest,  # 'Invalid parameter',
                    '3006': AuthenticationError,  # 'Invalid IP or inconsistent with the bound IP',
                    '3007': AuthenticationError,  # 'The request time has expired',
                    '3008': OrderNotFound,  # 'Transaction records not found',
                    '3009': InvalidOrder,  # 'The price exceeds the limit',
                    '3010': PermissionDenied,  # It fails to place an order, due to you have set up to prohibit trading of self market.
                    '3011': InvalidOrder,  # 'The entrusted price is abnormal, please modify it and place order again',
                    '3012': InvalidOrder,  # Duplicate custom customerOrderId
                    '4001': ExchangeNotAvailable,  # 'API interface is locked or not enabled',
                    '4002': RateLimitExceeded,  # 'Request too often',
                    '10017': PermissionDenied,  # {"code":10017,"desc":"没有权限"} when contract trading is not enabled on the api key
                },
                'broad': {
                    '提币地址有误，请先添加提币地址。': InvalidAddress,  # {"code":1001,"message":"提币地址有误，请先添加提币地址。"}
                    '资金不足,无法划账': InsufficientFunds,  # {"code":1001,"message":"资金不足,无法划账"}
                    '响应超时': RequestTimeout,  # {"code":1001,"message":"响应超时"}
                },
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg',
                'api': {
                    'spot': {
                        'v1': {
                            'public': 'https://api.zb.work/data',
                            'private': 'https://trade.zb.work/api',
                        },
                    },
                    'contract': {
                        'v1': {
                            'public': 'https://fapi.zb.com/api/public',
                        },
                        'v2': {
                            'public': 'https://fapi.zb.com/Server/api',
                            'private': 'https://fapi.zb.com/Server/api',
                        },
                    },
                },
                'www': 'https://www.zb.com',
                'doc': 'https://www.zb.com/i/developer',
                'fees': 'https://www.zb.com/i/rate',
                'referral': {
                    'url': 'https://www.zbex.club/en/register?ref=4301lera',
                    'discount': 0.16,
                },
            },
            'api': {
                'spot': {
                    'v1': {
                        'public': {
                            'get': [
                                'markets',
                                'ticker',
                                'allTicker',
                                'depth',
                                'trades',
                                'kline',
                                'getGroupMarkets',
                                'getFeeInfo',
                            ],
                        },
                        'private': {
                            'get': [
                                # spot API
                                'order',
                                'orderMoreV2',
                                'cancelOrder',
                                'getOrder',
                                'getOrders',
                                'getOrdersNew',
                                'getOrdersIgnoreTradeType',
                                'getUnfinishedOrdersIgnoreTradeType',
                                'getFinishedAndPartialOrders',
                                'getAccountInfo',
                                'getUserAddress',
                                'getPayinAddress',
                                'getWithdrawAddress',
                                'getWithdrawRecord',
                                'getChargeRecord',
                                'getCnyWithdrawRecord',
                                'getCnyChargeRecord',
                                'withdraw',
                                # sub accounts
                                'addSubUser',
                                'getSubUserList',
                                'doTransferFunds',
                                'createSubUserKey',  # removed on 2021-03-16 according to the update log in the API doc
                                # leverage API
                                'getLeverAssetsInfo',
                                'getLeverBills',
                                'transferInLever',
                                'transferOutLever',
                                'loan',
                                'cancelLoan',
                                'getLoans',
                                'getLoanRecords',
                                'borrow',
                                'autoBorrow',
                                'repay',
                                'doAllRepay',
                                'getRepayments',
                                'getFinanceRecords',
                                'changeInvestMark',
                                'changeLoop',
                                # cross API
                                'getCrossAssets',
                                'getCrossBills',
                                'transferInCross',
                                'transferOutCross',
                                'doCrossLoan',
                                'doCrossRepay',
                                'getCrossRepayRecords',
                            ],
                        },
                    },
                },
                'contract': {
                    'v1': {
                        'public': {
                            'get': [
                                'depth',
                                'fundingRate',
                                'indexKline',
                                'indexPrice',
                                'kCline',
                                'markKline',
                                'markPrice',
                                'ticker',
                                'trade',
                            ],
                        },
                    },
                    'v2': {
                        'public': {
                            'get': [
                                'allForceOrders',
                                'config/marketList',
                                'topLongShortAccountRatio',
                                'topLongShortPositionRatio',
                                'fundingRate',
                                'premiumIndex',
                            ],
                        },
                        'private': {
                            'get': [
                                'Fund/balance',
                                'Fund/getAccount',
                                'Fund/getBill',
                                'Fund/getBillTypeList',
                                'Fund/marginHistory',
                                'Positions/getPositions',
                                'Positions/getNominalValue',
                                'Positions/marginInfo',
                                'setting/get',
                                'trade/getAllOrders',
                                'trade/getOrder',
                                'trade/getOrderAlgos',
                                'trade/getTradeList',
                                'trade/getUndoneOrders',
                                'trade/tradeHistory',
                            ],
                            'post': [
                                'activity/buyTicket',
                                'Fund/transferFund',
                                'Positions/setMarginCoins',
                                'Positions/updateAppendUSDValue',
                                'Positions/updateMargin',
                                'setting/setLeverage',
                                'trade/batchOrder',
                                'trade/batchCancelOrder',
                                'trade/cancelAlgos',
                                'trade/cancelAllOrders',
                                'trade/cancelOrder',
                                'trade/order',
                                'trade/orderAlgo',
                                'trade/updateOrderAlgo',
                            ],
                        },
                    },
                },
            },
            'fees': {
                'funding': {
                    'withdraw': {},
                },
                'trading': {
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
            },
            'commonCurrencies': {
                'ANG': 'Anagram',
                'ENT': 'ENTCash',
                'BCHABC': 'BCHABC',  # conflict with BCH / BCHA
                'BCHSV': 'BCHSV',  # conflict with BCH / BSV
            },
        })

    def fetch_markets(self, params={}):
        markets = self.spotV1PublicGetMarkets(params)
        #
        #     {
        #         "zb_qc":{
        #             "amountScale":2,
        #             "minAmount":0.01,
        #             "minSize":5,
        #             "priceScale":4,
        #         },
        #     }
        #
        contracts = self.contractV2PublicGetConfigMarketList(params)
        #
        #     {
        #         BTC_USDT: {
        #             symbol: 'BTC_USDT',
        #             buyerCurrencyId: '6',
        #             contractType: '1',
        #             defaultMarginMode: '1',
        #             marketType: '2',
        #             historyDBName: 'trade_history_readonly.dbc',
        #             defaultLeverage: '20',
        #             id: '100',
        #             canCancelOrder: True,
        #             area: '1',
        #             mixMarginCoinName: 'usdt',
        #             fundingRateRatio: '0.25',
        #             marginCurrencyName: 'usdt',
        #             minTradeMoney: '0.0001',
        #             enableTime: '1638954000000',
        #             maxTradeMoney: '10000000',
        #             canTrade: True,
        #             maxLeverage: '125',
        #             defaultPositionsMode: '2',
        #             onlyWhitelistVisible: False,
        #             riskWarnRatio: '0.8',
        #             marginDecimal: '8',
        #             spot: False,
        #             status: '1',
        #             amountDecimal: '3',
        #             leverage: False,
        #             minAmount: '0.001',
        #             canOrder: True,
        #             duration: '1',
        #             feeDecimal: '8',
        #             sellerCurrencyId: '1',
        #             maxAmount: '1000',
        #             canOpenPosition: True,
        #             isSupportMixMargin: False,
        #             markPriceLimitRate: '0.05',
        #             marginCurrencyId: '6',
        #             stopFundingFee: False,
        #             priceDecimal: '2',
        #             lightenUpFeeRate: '0',
        #             futures: True,
        #             sellerCurrencyName: 'btc',
        #             marketPriceLimitRate: '0.05',
        #             canRebate: True,
        #             marketName: 'BTC_USDT',
        #             depth: [0.01, 0.1, 1],
        #             createTime: '1607590430094',
        #             mixMarginCoinIds: [6],
        #             buyerCurrencyName: 'usdt',
        #             stopService: False
        #         },
        #     }
        #
        contractsData = self.safe_value(contracts, 'data', [])
        contractsById = self.index_by(contractsData, 'marketName')
        dataById = self.deep_extend(contractsById, markets)
        keys = list(dataById.keys())
        result = []
        for i in range(0, len(keys)):
            id = keys[i]
            market = dataById[id]
            baseId, quoteId = id.split('_')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            settleId = self.safe_value(market, 'marginCurrencyName')
            settle = self.safe_currency_code(settleId)
            spot = settle is None
            swap = self.safe_value(market, 'futures', False)
            linear = True if swap else None
            active = True
            symbol = base + '/' + quote
            amountPrecisionString = self.safe_string_2(market, 'amountScale', 'amountDecimal')
            pricePrecisionString = self.safe_string_2(market, 'priceScale', 'priceDecimal')
            if swap:
                status = self.safe_string(market, 'status')
                active = (status == '1')
                symbol = base + '/' + quote + ':' + settle
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': settle,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': settleId,
                'type': 'swap' if swap else 'spot',
                'spot': spot,
                'margin': False,
                'swap': swap,
                'future': False,
                'option': False,
                'active': active,
                'contract': swap,
                'linear': linear,
                'inverse': not linear if swap else None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': int(amountPrecisionString),
                    'price': int(pricePrecisionString),
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': self.safe_number(market, 'maxLeverage'),
                    },
                    'amount': {
                        'min': self.safe_number(market, 'minAmount'),
                        'max': self.safe_number(market, 'maxAmount'),
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': self.safe_number_2(market, 'minSize', 'minTradeMoney'),
                        'max': self.safe_number(market, 'maxTradeMoney'),
                    },
                },
                'info': market,
            })
        return result

    def fetch_currencies(self, params={}):
        response = self.spotV1PublicGetGetFeeInfo(params)
        #
        #     {
        #         "code":1000,
        #         "message":"success",
        #         "result":{
        #             "USDT":[
        #                 {
        #                     "chainName":"TRC20",
        #                     "canWithdraw":true,
        #                     "fee":1.0,
        #                     "mainChainName":"TRX",
        #                     "canDeposit":true
        #                 },
        #                 {
        #                     "chainName":"OMNI",
        #                     "canWithdraw":true,
        #                     "fee":5.0,
        #                     "mainChainName":"BTC",
        #                     "canDeposit":true
        #                 },
        #                 {
        #                     "chainName":"ERC20",
        #                     "canWithdraw":true,
        #                     "fee":15.0,
        #                     "mainChainName":"ETH",
        #                     "canDeposit":true
        #                 }
        #             ],
        #         }
        #     }
        #
        currencies = self.safe_value(response, 'result', {})
        ids = list(currencies.keys())
        result = {}
        for i in range(0, len(ids)):
            id = ids[i]
            currency = currencies[id]
            code = self.safe_currency_code(id)
            precision = None
            isWithdrawEnabled = True
            isDepositEnabled = True
            fees = {}
            for j in range(0, len(currency)):
                networkItem = currency[j]
                network = self.safe_string(networkItem, 'chainName')
                # name = self.safe_string(networkItem, 'name')
                withdrawFee = self.safe_number(networkItem, 'fee')
                depositEnable = self.safe_value(networkItem, 'canDeposit')
                withdrawEnable = self.safe_value(networkItem, 'canWithdraw')
                isDepositEnabled = isDepositEnabled or depositEnable
                isWithdrawEnabled = isWithdrawEnabled or withdrawEnable
                fees[network] = withdrawFee
            active = (isWithdrawEnabled and isDepositEnabled)
            result[code] = {
                'id': id,
                'name': None,
                'code': code,
                'precision': precision,
                'info': currency,
                'active': active,
                'deposit': isDepositEnabled,
                'withdraw': isWithdrawEnabled,
                'fee': None,
                'fees': fees,
                'limits': self.limits,
            }
        return result

    def parse_balance(self, response):
        balances = self.safe_value(response['result'], 'coins')
        result = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        for i in range(0, len(balances)):
            balance = balances[i]
            #     {       enName: "BTC",
            #               freez: "0.00000000",
            #         unitDecimal:  8,  # always 8
            #              cnName: "BTC",
            #       isCanRecharge:  True,  # TODO: should use self
            #             unitTag: "฿",
            #       isCanWithdraw:  True,  # TODO: should use self
            #           available: "0.00000000",
            #                 key: "btc"         }
            account = self.account()
            currencyId = self.safe_string(balance, 'key')
            code = self.safe_currency_code(currencyId)
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'freez')
            result[code] = account
        return self.safe_balance(result)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.spotV1PrivateGetGetAccountInfo(params)
        # todo: use self somehow
        # permissions = response['result']['base']
        return self.parse_balance(response)

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        # fetchDepositAddress
        #
        #     {
        #         "key": "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        #     }
        #
        # fetchDepositAddresses
        #
        #     {
        #         "blockChain": "btc",
        #         "isUseMemo": False,
        #         "address": "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        #         "canWithdraw": True,
        #         "canDeposit": True
        #     }
        #     {
        #         "blockChain": "bts",
        #         "isUseMemo": True,
        #         "account": "btstest",
        #         "memo": "123",
        #         "canWithdraw": True,
        #         "canDeposit": True
        #     }
        #
        address = self.safe_string_2(depositAddress, 'key', 'address')
        tag = None
        memo = self.safe_string(depositAddress, 'memo')
        if memo is not None:
            tag = memo
        elif address.find('_') >= 0:
            parts = address.split('_')
            address = parts[0]  # WARNING: MAY BE tag_address INSTEAD OF address_tag FOR SOME CURRENCIESnot !
            tag = parts[1]
        currencyId = self.safe_string(depositAddress, 'blockChain')
        code = self.safe_currency_code(currencyId, currency)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'network': None,
            'info': depositAddress,
        }

    def fetch_deposit_addresses(self, codes=None, params={}):
        self.load_markets()
        response = self.spotV1PrivateGetGetPayinAddress(params)
        #
        #     {
        #         "code": 1000,
        #         "message": {
        #             "des": "success",
        #             "isSuc": True,
        #             "datas": [
        #                 {
        #                     "blockChain": "btc",
        #                     "isUseMemo": False,
        #                     "address": "1LL5ati6pXHZnTGzHSA3rWdqi4mGGXudwM",
        #                     "canWithdraw": True,
        #                     "canDeposit": True
        #                 },
        #                 {
        #                     "blockChain": "bts",
        #                     "isUseMemo": True,
        #                     "account": "btstest",
        #                     "memo": "123",
        #                     "canWithdraw": True,
        #                     "canDeposit": True
        #                 },
        #             ]
        #         }
        #     }
        #
        message = self.safe_value(response, 'message', {})
        datas = self.safe_value(message, 'datas', [])
        return self.parse_deposit_addresses(datas, codes)

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.spotV1PrivateGetGetUserAddress(self.extend(request, params))
        #
        #     {
        #         "code": 1000,
        #         "message": {
        #             "des": "success",
        #             "isSuc": True,
        #             "datas": {
        #                 "key": "0x0af7f36b8f09410f3df62c81e5846da673d4d9a9"
        #             }
        #         }
        #     }
        #
        message = self.safe_value(response, 'message', {})
        datas = self.safe_value(message, 'datas', {})
        return self.parse_deposit_address(datas, currency)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            # 'market': market['id'],  # only applicable to SPOT
            # 'symbol': market['id'],  # only applicable to SWAP
            # 'size': limit,  # 1-50 applicable to SPOT and SWAP
            # 'merge': 5.0,  # float default depth only applicable to SPOT
            # 'scale': 5,  # int accuracy, only applicable to SWAP
        }
        marketIdField = 'symbol' if market['swap'] else 'market'
        request[marketIdField] = market['id']
        method = self.get_supported_mapping(market['type'], {
            'spot': 'spotV1PublicGetDepth',
            'swap': 'contractV1PublicGetDepth',
        })
        if limit is not None:
            request['size'] = limit
        response = getattr(self, method)(self.extend(request, params))
        #
        # Spot
        #
        #     {
        #         "asks":[
        #             [35000.0,0.2741],
        #             [34949.0,0.0173],
        #             [34900.0,0.5004],
        #         ],
        #         "bids":[
        #             [34119.32,0.0030],
        #             [34107.83,0.1500],
        #             [34104.42,0.1500],
        #         ],
        #         "timestamp":1624536510
        #     }
        #
        # Swap
        #
        #     {
        #         "code": 10000,
        #         "desc": "操作成功",
        #         "data": {
        #             "asks": [
        #                 [43416.6,0.02],
        #                 [43418.25,0.04],
        #                 [43425.82,0.02]
        #             ],
        #             "bids": [
        #                 [43414.61,0.1],
        #                 [43414.18,0.04],
        #                 [43413.03,0.05]
        #             ],
        #             "time": 1645087743071
        #         }
        #     }
        #
        result = None
        timestamp = None
        if market['type'] == 'swap':
            result = self.safe_value(response, 'data')
            timestamp = self.safe_integer(result, 'time')
        else:
            result = response
            timestamp = self.safe_timestamp(response, 'timestamp')
        return self.parse_order_book(result, symbol, timestamp)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.spotV1PublicGetAllTicker(params)
        result = {}
        marketsByIdWithoutUnderscore = {}
        marketIds = list(self.markets_by_id.keys())
        for i in range(0, len(marketIds)):
            tickerId = marketIds[i].replace('_', '')
            marketsByIdWithoutUnderscore[tickerId] = self.markets_by_id[marketIds[i]]
        ids = list(response.keys())
        for i in range(0, len(ids)):
            market = marketsByIdWithoutUnderscore[ids[i]]
            result[market['symbol']] = self.parse_ticker(response[ids[i]], market)
        return self.filter_by_array(result, 'symbol', symbols)

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            # 'market': market['id'],  # only applicable to SPOT
            # 'symbol': market['id'],  # only applicable to SWAP
        }
        marketIdField = 'symbol' if market['swap'] else 'market'
        request[marketIdField] = market['id']
        method = self.get_supported_mapping(market['type'], {
            'spot': 'spotV1PublicGetTicker',
            'swap': 'contractV1PublicGetTicker',
        })
        response = getattr(self, method)(self.extend(request, params))
        #
        # Spot
        #
        #     {
        #         "date":"1624399623587",
        #         "ticker":{
        #             "high":"33298.38",
        #             "vol":"56152.9012",
        #             "last":"32578.55",
        #             "low":"28808.19",
        #             "buy":"32572.68",
        #             "sell":"32615.37",
        #             "turnover":"1764201303.6100",
        #             "open":"31664.85",
        #             "riseRate":"2.89"
        #         }
        #     }
        #
        # Swap
        #
        #     {
        #         "code": 10000,
        #         "desc": "操作成功",
        #         "data": {
        #             "BTC_USDT": [44053.47,44357.77,42911.54,43297.79,53471.264,-1.72,1645093002,302201.255084]
        #         }
        #     }
        #
        ticker = None
        if market['type'] == 'swap':
            ticker = {}
            data = self.safe_value(response, 'data')
            values = self.safe_value(data, market['id'])
            for i in range(0, len(values)):
                ticker['open'] = self.safe_value(values, 0)
                ticker['high'] = self.safe_value(values, 1)
                ticker['low'] = self.safe_value(values, 2)
                ticker['last'] = self.safe_value(values, 3)
                ticker['vol'] = self.safe_value(values, 4)
                ticker['riseRate'] = self.safe_value(values, 5)
        else:
            ticker = self.safe_value(response, 'ticker', {})
            ticker['date'] = self.safe_value(response, 'date')
        return self.parse_ticker(ticker, market)

    def parse_ticker(self, ticker, market=None):
        #
        # Spot
        #
        #     {
        #         "date":"1624399623587",  # injected from outside
        #         "high":"33298.38",
        #         "vol":"56152.9012",
        #         "last":"32578.55",
        #         "low":"28808.19",
        #         "buy":"32572.68",
        #         "sell":"32615.37",
        #         "turnover":"1764201303.6100",
        #         "open":"31664.85",
        #         "riseRate":"2.89"
        #     }
        #
        # Swap
        #
        #     {
        #         open: 44083.82,
        #         high: 44357.77,
        #         low: 42911.54,
        #         last: 43097.87,
        #         vol: 53451.641,
        #         riseRate: -2.24
        #     }
        #
        timestamp = self.safe_integer(ticker, 'date', self.milliseconds())
        last = self.safe_string(ticker, 'last')
        return self.safe_ticker({
            'symbol': self.safe_symbol(None, market),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'high'),
            'low': self.safe_string(ticker, 'low'),
            'bid': self.safe_string(ticker, 'buy'),
            'bidVolume': None,
            'ask': self.safe_string(ticker, 'sell'),
            'askVolume': None,
            'vwap': None,
            'open': self.safe_string(ticker, 'open'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_string(ticker, 'vol'),
            'quoteVolume': None,
            'info': ticker,
        }, market, False)

    def parse_ohlcv(self, ohlcv, market=None):
        return [
            self.safe_integer(ohlcv, 0),
            self.safe_number(ohlcv, 1),
            self.safe_number(ohlcv, 2),
            self.safe_number(ohlcv, 3),
            self.safe_number(ohlcv, 4),
            self.safe_number(ohlcv, 5),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        if limit is None:
            limit = 1000
        request = {
            'market': market['id'],
            'type': self.timeframes[timeframe],
            'limit': limit,
        }
        if since is not None:
            request['since'] = since
        response = self.spotV1PublicGetKline(self.extend(request, params))
        data = self.safe_value(response, 'data', [])
        return self.parse_ohlcvs(data, market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        #
        #     {
        #         "date":1624537391,
        #         "amount":"0.0142",
        #         "price":"33936.42",
        #         "trade_type":"ask",
        #         "type":"sell",
        #         "tid":1718869018
        #     }
        #
        timestamp = self.safe_timestamp(trade, 'date')
        side = self.safe_string(trade, 'trade_type')
        side = 'buy' if (side == 'bid') else 'sell'
        id = self.safe_string(trade, 'tid')
        price = self.safe_string(trade, 'price')
        amount = self.safe_string(trade, 'amount')
        market = self.safe_market(None, market)
        return self.safe_trade({
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'type': None,
            'side': side,
            'order': None,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': None,
        }, market)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        response = self.spotV1PublicGetTrades(self.extend(request, params))
        #
        #     [
        #         {"date":1624537391,"amount":"0.0142","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869018},
        #         {"date":1624537391,"amount":"0.0010","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869020},
        #         {"date":1624537391,"amount":"0.0133","price":"33936.42","trade_type":"ask","type":"sell","tid":1718869021},
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if type != 'limit':
            raise InvalidOrder(self.id + ' allows limit orders only')
        self.load_markets()
        request = {
            'price': self.price_to_precision(symbol, price),
            'amount': self.amount_to_precision(symbol, amount),
            'tradeType': '1' if (side == 'buy') else '0',
            'currency': self.market_id(symbol),
        }
        response = self.spotV1PrivateGetOrder(self.extend(request, params))
        return {
            'info': response,
            'id': response['id'],
        }

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'id': str(id),
            'currency': self.market_id(symbol),
        }
        return self.spotV1PrivateGetCancelOrder(self.extend(request, params))

    def cancel_all_orders(self, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelAllOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        if market['spot']:
            raise NotSupported(self.id + ' cancelAllOrders() is not supported on ' + market['type'] + ' markets')
        request = {
            'symbol': market['id'],
        }
        return self.contractV2PrivatePostTradeCancelAllOrders(self.extend(request, params))

    def fetch_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a symbol argument')
        self.load_markets()
        request = {
            'id': str(id),
            'currency': self.market_id(symbol),
        }
        response = self.spotV1PrivateGetGetOrder(self.extend(request, params))
        #
        #     {
        #         'total_amount': 0.01,
        #         'id': '20180910244276459',
        #         'price': 180.0,
        #         'trade_date': 1536576744960,
        #         'status': 2,
        #         'trade_money': '1.96742',
        #         'trade_amount': 0.01,
        #         'type': 0,
        #         'currency': 'eth_usdt'
        #     }
        #
        return self.parse_order(response, None)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + 'fetchOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        swap = market['swap']
        request = {
            'pageSize': limit,  # default pageSize is 50 for spot, 30 for swap
            # 'currency': market['id'],  # only applicable to SPOT
            # 'pageIndex': 1,  # only applicable to SPOT
            # 'symbol': market['id'],  # only applicable to SWAP
            # 'pageNum': 1,  # only applicable to SWAP
            # 'type': params['type'],  # only applicable to SWAP
            # 'side': params['side'],  # only applicable to SWAP
            # 'dateRange': params['dateRange'],  # only applicable to SWAP
            # 'action': params['action'],  # only applicable to SWAP
            # 'endTime': params['endTime'],  # only applicable to SWAP
            # 'startTime': since,  # only applicable to SWAP
        }
        marketIdField = 'symbol' if market['swap'] else 'currency'
        request[marketIdField] = market['id']
        pageNumField = 'pageNum' if market['swap'] else 'pageIndex'
        request[pageNumField] = 1
        if swap:
            request['startTime'] = since
        method = self.get_supported_mapping(market['type'], {
            'spot': 'spotV1PrivateGetGetOrdersIgnoreTradeType',
            'swap': 'contractV2PrivateGetTradeGetAllOrders',
        })
        # tradeType 交易类型1/0[buy/sell]
        if 'tradeType' in params:
            method = 'spotV1PrivateGetGetOrdersNew'
        response = None
        try:
            response = getattr(self, method)(self.extend(request, params))
        except Exception as e:
            if isinstance(e, OrderNotFound):
                return []
            raise e
        # Spot
        #
        #     [
        #         {
        #             "acctType": 0,
        #             "currency": "btc_usdt",
        #             "fees": 0,
        #             "id": "202202234857482656",
        #             "price": 30000.0,
        #             "status": 3,
        #             "total_amount": 0.0006,
        #             "trade_amount": 0.0000,
        #             "trade_date": 1645610254524,
        #             "trade_money": 0.000000,
        #             "type": 1,
        #             "useZbFee": False,
        #             "webId": 0
        #         }
        #     ]
        #
        # Swap
        #
        #     {
        #         "code": 10000,
        #         "data": {
        #             "list": [
        #                 {
        #                     "action": 1,
        #                     "amount": "0.004",
        #                     "availableAmount": "0.004",
        #                     "availableValue": "120",
        #                     "avgPrice": "0",
        #                     "canCancel": True,
        #                     "cancelStatus": 20,
        #                     "createTime": "1645609643885",
        #                     "entrustType": 1,
        #                     "id": "6902187111785635850",
        #                     "leverage": 5,
        #                     "margin": "24",
        #                     "marketId": "100",
        #                     "marketName": "BTC_USDT",
        #                     "modifyTime": "1645609643889",
        #                     "price": "30000",
        #                     "showStatus": 1,
        #                     "side": 1,
        #                     "sourceType": 1,
        #                     "status": 12,
        #                     "tradeAmount": "0",
        #                     "tradeValue": "0",
        #                     "type": 1,
        #                     "userId": "6896693805014120448",
        #                     "value": "120"
        #                 },
        #             ],
        #             "pageNum": 1,
        #             "pageSize": 10
        #         },
        #         "desc": "操作成功"
        #     }
        #
        if swap:
            data = self.safe_value(response, 'data', {})
            response = self.safe_value(data, 'list', [])
        return self.parse_orders(response, market, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=10, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + 'fetchClosedOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'currency': market['id'],
            'pageIndex': 1,  # default pageIndex is 1
            'pageSize': limit,  # default pageSize is 10, doesn't work with other values now
        }
        response = self.spotV1PrivateGetGetFinishedAndPartialOrders(self.extend(request, params))
        return self.parse_orders(response, market, since, limit)

    def fetch_open_orders(self, symbol=None, since=None, limit=10, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + 'fetchOpenOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'currency': market['id'],
            'pageIndex': 1,  # default pageIndex is 1
            'pageSize': limit,  # default pageSize is 10
        }
        method = 'spotV1PrivateGetGetUnfinishedOrdersIgnoreTradeType'
        # tradeType 交易类型1/0[buy/sell]
        if 'tradeType' in params:
            method = 'spotV1PrivateGetGetOrdersNew'
        response = None
        try:
            response = getattr(self, method)(self.extend(request, params))
        except Exception as e:
            if isinstance(e, OrderNotFound):
                return []
            raise e
        return self.parse_orders(response, market, since, limit)

    def parse_order(self, order, market=None):
        #
        #     {
        #         acctType: 0,
        #         currency: 'btc_usdt',
        #         fees: 3.6e-7,
        #         id: '202102282829772463',
        #         price: 45177.5,
        #         status: 2,
        #         total_amount: 0.0002,
        #         trade_amount: 0.0002,
        #         trade_date: 1614515104998,
        #         trade_money: 8.983712,
        #         type: 1,
        #         useZbFee: False
        #     },
        #
        side = self.safe_integer(order, 'type')
        side = 'buy' if (side == 1) else 'sell'
        type = 'limit'  # market order is not availalbe in ZB
        timestamp = self.safe_integer(order, 'trade_date')
        marketId = self.safe_string(order, 'currency')
        market = self.safe_market(marketId, market, '_')
        price = self.safe_string(order, 'price')
        filled = self.safe_string(order, 'trade_amount')
        amount = self.safe_string(order, 'total_amount')
        cost = self.safe_string(order, 'trade_money')
        status = self.parse_order_status(self.safe_string(order, 'status'))
        id = self.safe_string(order, 'id')
        feeCost = self.safe_number(order, 'fees')
        fee = None
        if feeCost is not None:
            feeCurrency = None
            zbFees = self.safe_value(order, 'useZbFee')
            if zbFees is True:
                feeCurrency = 'ZB'
            else:
                feeCurrency = market['quote'] if (side == 'sell') else market['base']
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': market['symbol'],
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'average': None,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': None,
            'status': status,
            'fee': fee,
            'trades': None,
        }, market)

    def parse_order_status(self, status):
        statuses = {
            '0': 'open',
            '1': 'canceled',
            '2': 'closed',
            '3': 'open',  # partial
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction_status(self, status):
        statuses = {
            '0': 'pending',  # submitted, pending confirmation
            '1': 'failed',
            '2': 'ok',
            '3': 'canceled',
            '5': 'ok',  # confirmed
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # withdraw
        #
        #     {
        #         "code": 1000,
        #         "message": "success",
        #         "id": "withdrawalId"
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #         "amount": 0.01,
        #         "fees": 0.001,
        #         "id": 2016042556231,
        #         "manageTime": 1461579340000,
        #         "status": 3,
        #         "submitTime": 1461579288000,
        #         "toAddress": "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        #     }
        #
        # fetchDeposits
        #
        #     {
        #         "address": "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        #         "amount": "1.00000000",
        #         "confirmTimes": 1,
        #         "currency": "BTC",
        #         "description": "Successfully Confirm",
        #         "hash": "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        #         "id": 558,
        #         "itransfer": 1,
        #         "status": 2,
        #         "submit_time": "2016-12-07 18:51:57",
        #     }
        #
        id = self.safe_string(transaction, 'id')
        txid = self.safe_string(transaction, 'hash')
        amount = self.safe_number(transaction, 'amount')
        timestamp = self.parse8601(self.safe_string(transaction, 'submit_time'))
        timestamp = self.safe_integer(transaction, 'submitTime', timestamp)
        address = self.safe_string_2(transaction, 'toAddress', 'address')
        tag = None
        if address is not None:
            parts = address.split('_')
            address = self.safe_string(parts, 0)
            tag = self.safe_string(parts, 1)
        confirmTimes = self.safe_integer(transaction, 'confirmTimes')
        updated = self.safe_integer(transaction, 'manageTime')
        type = None
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId, currency)
        if address is not None:
            type = 'withdrawal' if (confirmTimes is None) else 'deposit'
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        fee = None
        feeCost = self.safe_number(transaction, 'fees')
        if feeCost is not None:
            fee = {
                'cost': feeCost,
                'currency': code,
            }
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'network': None,
            'addressFrom': None,
            'address': address,
            'addressTo': address,
            'tagFrom': None,
            'tag': tag,
            'tagTo': tag,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': updated,
            'fee': fee,
        }

    def set_leverage(self, leverage, symbol=None, params={}):
        self.load_markets()
        if symbol is None:
            raise ArgumentsRequired(self.id + ' setLeverage() requires a symbol argument')
        if (leverage < 1) or (leverage > 125):
            raise BadRequest(self.id + ' leverage should be between 1 and 125')
        market = self.market(symbol)
        accountType = None
        if not market['swap']:
            raise BadSymbol(self.id + ' setLeverage() supports swap contracts only')
        else:
            accountType = 1
        request = {
            'symbol': market['id'],
            'leverage': leverage,
            'futuresAccountType': accountType,  # 1: USDT perpetual swaps
        }
        return self.contractV2PrivatePostSettingSetLeverage(self.extend(request, params))

    def fetch_funding_rate_history(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'symbol': market['id'],
            # 'startTime': since,
            # 'endTime': endTime,  # current time by default
            # 'limit': limit,  # default 100, max 1000
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['startTime'] = since
        till = self.safe_integer(params, 'till')
        endTime = self.safe_string(params, 'endTime')
        params = self.omit(params, ['endTime', 'till'])
        if till is not None:
            request['endTime'] = till
        elif endTime is not None:
            request['endTime'] = endTime
        if limit is not None:
            request['limit'] = limit
        response = self.contractV2PublicGetFundingRate(self.extend(request, params))
        #
        #     {
        #         "code": 10000,
        #         "data": [
        #             {
        #                 "symbol": "BTC_USDT",
        #                 "fundingRate": "0.0001",
        #                 "fundingTime": "1645171200000"
        #             },
        #         ],
        #         "desc": "操作成功"
        #     }
        #
        data = self.safe_value(response, 'data')
        rates = []
        for i in range(0, len(data)):
            entry = data[i]
            marketId = self.safe_string(entry, 'symbol')
            symbol = self.safe_symbol(marketId)
            timestamp = self.safe_string(entry, 'fundingTime')
            rates.append({
                'info': entry,
                'symbol': symbol,
                'fundingRate': self.safe_number(entry, 'fundingRate'),
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
            })
        sorted = self.sort_by(rates, 'timestamp')
        return self.filter_by_symbol_since_limit(sorted, symbol, since, limit)

    def fetch_funding_rate(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        if not market['swap']:
            raise BadSymbol(self.id + ' fetchFundingRate() does not supports contracts only')
        request = {
            'symbol': market['id'],
        }
        response = self.contractV1PublicGetFundingRate(self.extend(request, params))
        #
        #     {
        #         "code": 10000,
        #         "desc": "操作成功",
        #         "data": {
        #             "fundingRate": "0.0001",
        #             "nextCalculateTime": "2022-02-19 00:00:00"
        #         }
        #     }
        #
        data = self.safe_value(response, 'data')
        return self.parse_funding_rate(data, market)

    def parse_funding_rate(self, contract, market=None):
        #
        #     {
        #         "fundingRate": "0.0001",
        #         "nextCalculateTime": "2022-02-19 00:00:00"
        #     }
        #
        marketId = self.safe_string(contract, 'symbol')
        symbol = self.safe_symbol(marketId, market)
        fundingRate = self.safe_number(contract, 'fundingRate')
        nextFundingDatetime = self.safe_string(contract, 'nextCalculateTime')
        return {
            'info': contract,
            'symbol': symbol,
            'markPrice': None,
            'indexPrice': None,
            'interestRate': None,
            'estimatedSettlePrice': None,
            'timestamp': None,
            'datetime': None,
            'fundingRate': fundingRate,
            'fundingTimestamp': None,
            'fundingDatetime': None,
            'nextFundingRate': None,
            'nextFundingTimestamp': self.parse8601(nextFundingDatetime),
            'nextFundingDatetime': nextFundingDatetime,
            'previousFundingRate': None,
            'previousFundingTimestamp': None,
            'previousFundingDatetime': None,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        tag, params = self.handle_withdraw_tag_and_params(tag, params)
        password = self.safe_string(params, 'safePwd', self.password)
        if password is None:
            raise ArgumentsRequired(self.id + ' withdraw() requires exchange.password or a safePwd parameter')
        fees = self.safe_number(params, 'fees')
        if fees is None:
            raise ArgumentsRequired(self.id + ' withdraw() requires a fees parameter')
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        if tag is not None:
            address += '_' + tag
        request = {
            'amount': self.currency_to_precision(code, amount),
            'currency': currency['id'],
            'fees': self.currency_to_precision(code, fees),
            # 'itransfer': 0,  # agree for an internal transfer, 0 disagree, 1 agree, the default is to disagree
            'method': 'withdraw',
            'receiveAddr': address,
            'safePwd': password,
        }
        response = self.spotV1PrivateGetWithdraw(self.extend(request, params))
        #
        #     {
        #         "code": 1000,
        #         "message": "success",
        #         "id": "withdrawalId"
        #     }
        #
        transaction = self.parse_transaction(response, currency)
        return self.extend(transaction, {
            'type': 'withdrawal',
            'address': address,
            'addressTo': address,
            'amount': amount,
        })

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'currency': currency['id'],
            # 'pageIndex': 1,
            # 'pageSize': limit,
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
        if limit is not None:
            request['pageSize'] = limit
        response = self.spotV1PrivateGetGetWithdrawRecord(self.extend(request, params))
        #
        #     {
        #         "code": 1000,
        #         "message": {
        #             "des": "success",
        #             "isSuc": True,
        #             "datas": {
        #                 "list": [
        #                     {
        #                         "amount": 0.01,
        #                         "fees": 0.001,
        #                         "id": 2016042556231,
        #                         "manageTime": 1461579340000,
        #                         "status": 3,
        #                         "submitTime": 1461579288000,
        #                         "toAddress": "14fxEPirL9fyfw1i9EF439Pq6gQ5xijUmp",
        #                     },
        #                 ],
        #                 "pageIndex": 1,
        #                 "pageSize": 10,
        #                 "totalCount": 4,
        #                 "totalPage": 1
        #             }
        #         }
        #     }
        #
        message = self.safe_value(response, 'message', {})
        datas = self.safe_value(message, 'datas', {})
        withdrawals = self.safe_value(datas, 'list', [])
        return self.parse_transactions(withdrawals, currency, since, limit)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'currency': currency['id'],
            # 'pageIndex': 1,
            # 'pageSize': limit,
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
        if limit is not None:
            request['pageSize'] = limit
        response = self.spotV1PrivateGetGetChargeRecord(self.extend(request, params))
        #
        #     {
        #         "code": 1000,
        #         "message": {
        #             "des": "success",
        #             "isSuc": True,
        #             "datas": {
        #                 "list": [
        #                     {
        #                         "address": "1FKN1DZqCm8HaTujDioRL2Aezdh7Qj7xxx",
        #                         "amount": "1.00000000",
        #                         "confirmTimes": 1,
        #                         "currency": "BTC",
        #                         "description": "Successfully Confirm",
        #                         "hash": "7ce842de187c379abafadd64a5fe66c5c61c8a21fb04edff9532234a1dae6xxx",
        #                         "id": 558,
        #                         "itransfer": 1,
        #                         "status": 2,
        #                         "submit_time": "2016-12-07 18:51:57",
        #                     },
        #                 ],
        #                 "pageIndex": 1,
        #                 "pageSize": 10,
        #                 "total": 8
        #             }
        #         }
        #     }
        #
        message = self.safe_value(response, 'message', {})
        datas = self.safe_value(message, 'datas', {})
        deposits = self.safe_value(datas, 'list', [])
        return self.parse_transactions(deposits, currency, since, limit)

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        section, version, access = api
        url = self.urls['api'][section][version][access]
        if access == 'public':
            if path == 'getFeeInfo':
                url = self.urls['api'][section][version]['private'] + '/' + path
            else:
                url += '/' + version + '/' + path
            if params:
                url += '?' + self.urlencode(params)
        elif section == 'contract':
            timestamp = self.milliseconds()
            iso8601 = self.iso8601(timestamp)
            signedString = iso8601 + method + '/Server/api/' + version + '/' + path
            params = self.keysort(params)
            headers = {
                'ZB-APIKEY': self.apiKey,
                'ZB-TIMESTAMP': iso8601,
                # 'ZB-LAN': 'cn',  # cn, en, kr
            }
            url += '/' + version + '/' + path
            if method == 'POST':
                headers['Content-Type'] = 'application/json'
                body = self.json(params)
                signedString += self.urlencode(params)
            else:
                if params:
                    query = self.urlencode(params)
                    url += '?' + query
                    signedString += query
            secret = self.hash(self.encode(self.secret), 'sha1')
            signature = self.hmac(self.encode(signedString), self.encode(secret), hashlib.sha256, 'base64')
            headers['ZB-SIGN'] = signature
        else:
            query = self.keysort(self.extend({
                'method': path,
                'accesskey': self.apiKey,
            }, params))
            nonce = self.nonce()
            query = self.keysort(query)
            auth = self.rawencode(query)
            secret = self.hash(self.encode(self.secret), 'sha1')
            signature = self.hmac(self.encode(auth), self.encode(secret), hashlib.md5)
            suffix = 'sign=' + signature + '&reqTime=' + str(nonce)
            url += '/' + path + '?' + auth + '&' + suffix
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if body[0] == '{':
            feedback = self.id + ' ' + body
            self.throw_broadly_matched_exception(self.exceptions['broad'], body, feedback)
            if 'code' in response:
                code = self.safe_string(response, 'code')
                self.throw_exactly_matched_exception(self.exceptions['exact'], code, feedback)
                if (code != '1000') and (code != '10000'):
                    raise ExchangeError(feedback)
            # special case for {"result":false,"message":"服务端忙碌"}(a "Busy Server" reply)
            result = self.safe_value(response, 'result')
            if result is not None:
                if not result:
                    message = self.safe_string(response, 'message')
                    if message == u'服务端忙碌':
                        raise ExchangeNotAvailable(feedback)
                    else:
                        raise ExchangeError(feedback)
