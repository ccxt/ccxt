# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import hashlib
import time

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.precise import Precise


class bitwyre(Exchange):

    def describe(self):
        return self.deep_extend(super(bitwyre, self).describe(), {
            'id': 'bitwyre',
            'name': 'BITWYRE',
            'countries': ['ID'],  # Indonesia
            'has': {
                'fetchTime': True,
                'CORS': None,
                'createMarketOrder': None,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': None,
                'fetchMarkets': True,
                'fetchMyTrades': None,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchTicker': True,
                'fetchTickers': None,
                'fetchTime': True,
                'fetchTrades': None,
                'withdraw': None
            },
            'version': '1.0',
            'urls': {
                'logo': '',
                'test': {
                    'public': 'https://api.bitwyre.net/public',
                    'private': 'https://api.bitwyre.net/private',
                },
                'api': {
                    'public': 'https://api.bitwyre.com/public',
                    'private': 'https://api.bitwyre.com/private',
                },
                'www': 'https://www.bitwyre.com',
                'doc': 'https://docs.bitwyre.com',
                'referral': '',
            },
            'api': {
                'public': {
                    'get': [
                        'assets',
                        'contract',
                        'depth',
                        'orderlag',
                        'pairs',
                        'ticker',
                        'time',
                        'throughput',
                    ],
                },
                'private': {
                    'delete': [
                        'orders/cancel',
                        'orders/cancel/instrument/{instrument}'
                    ],
                    'get': [
                        'account/spotbalance',
                        'account/derivativesbalance',
                        'orders/cancelled',
                        'orders/closed',
                        'orders/info/{order_id}',
                        'orders/open'
                    ],
                    'post': [
                        'orders',
                        'account/deposit/crypto'
                    ]
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0,
                    'taker': 0.003,
                },
            },
            'exceptions': {
                'exact': {
                    'invalid_pair': BadSymbol,  # {"error":"invalid_pair","error_description":"Invalid Pair"}
                    'Insufficient balance.': InsufficientFunds,
                    'invalid order.': OrderNotFound,
                    'Invalid credentials. API not found or session has expired.': AuthenticationError,
                    'Invalid credentials. Bad sign.': AuthenticationError,
                },
                'broad': {
                    'Minimum price': InvalidOrder,
                    'Minimum order': InvalidOrder,
                },
            },
            # exchange-specific options
            'options': {
                'recvWindow': 5 * 1000,  # default 5 sec
                'timeDifference': 0,  # the difference between system clock and exchange clock
                'adjustForTimeDifference': False,  # controls the adjustment logic upon instantiation
                'accountsByType': {
                    'spot': 'spot',
                    'derivatives': 'derivatives',
                },
            },
        })

    def fetch_time(self, params={}):
        response = self.publicGetTime(params)
        result = self.safe_value(response, 'result', {})
        #
        #     {
        #         "unixtime": "1637664744329847066",
        #     }
        #
        return self.safe_integer(result, 'unixtime')
    
    def load_time_difference(self):
        serverTime = self.fetch_time()
        after = self.nanoseconds()
        self.options['timeDifference'] = after - serverTime
        return self.options['timeDifference']

    @staticmethod
    def nanoseconds():
        try:
            timens = time.time_ns()
        except:
            timens = int("%d" % int(time.time() * 1_000_000_000))
        return int(timens)

    def nonce(self):
        return self.nanoseconds() - self.options['timeDifference']
    
    def fetch_markets(self, params={}):
        params_pairs_spot = {
            "market": "crypto",
            "product": "spot",
            "country": "id"
        }
        response_pairs_spot = self.publicGetPairs(params_pairs_spot)
        result = self.safe_value(response_pairs_spot, 'result', {})

        params_pairs_stablecoins = {
            "market": "stablecoin",
            "product": "spot",
            "country": "id"
        }
        response_pairs_stablecoins = self.publicGetPairs(params_pairs_stablecoins)
        result_pairs_stablecoins = self.safe_value(response_pairs_stablecoins, 'result', {})

        params_asset = {}
        response_asset = self.publicGetAssets(params_asset)
        result_asset = self.safe_value(response_asset, 'result', {})
        asset_map = {}
        for asset_dict in result_asset:
            asset = self.safe_string_lower(asset_dict, 'asset', "")
            asset_map[asset] = asset_dict

        result.extend(result_pairs_stablecoins)
        for pairs_market in result:
            instrument = self.safe_string_lower(pairs_market, 'instrument', "")
            base_quote = instrument.split('_')[0]
            
            if base_quote in asset_map:
                pairs_market.update(asset_map[base_quote])
        
        # [
        #     {
        #         "instrument": "eth_usdt_spot",
        #         "symbol": "ETH/USDT",
        #         "asset": "eth",
        #         "btc_equivalent": "",
        #         "constant_multiplier": "1000000000",
        #         "icon_url": "https://robin.bitwyre.id/app/Raster/ETH_125px.png",
        #         "is_deposit_enabled": true,
        #         "is_trading_enabled": true,
        #         "is_withdraw_enabled": true,
        #         "local_equivalent": "",
        #         "local_reference": "",
        #         "max_withdrawal": "1000",
        #         "min_withdrawal": "0",
        #         "name": "Ethereum",
        #         "precision": "1e-9",
        #         "type": "crypto",
        #         "withdrawal_fee": "0"
        #     }
        # ]
        return result

    def fetch_orderlag(self, symbol=None, params={}):
        if symbol is not None:
            self.load_markets()
            market = self.market(symbol)
            instrument = market['instrument']
            params = {
                'instrument': instrument,
            }
        method = 'publicGetOrderlag'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if result == {} or error != []:
            raise BadSymbol(self.id + ': Invalid pairs ' + symbol + ', Error ' + error)
        elif isinstance(result, list):
            try:
                result = result[0]
            except:
                raise ExchangeError(self.id + ': Something wrong. Please contact bitwyre developer')
        #
        #     {
        #         "btc_usdt_spot": "1",
        #         "eth_usdt_spot": "0"
        #     }
        #
        return result

    def fetch_throughput(self, symbol=None, params={}):
        if symbol is not None:
            self.load_markets()
            market = self.market(symbol)
            instrument = market['instrument']
            params = {
                'instrument': instrument,
            }
        method = 'publicGetThroughput'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
    
        if result == {} or error != []:
            raise BadSymbol(self.id + ': Invalid pairs ' + symbol + ', Error ' + str(error))
        elif isinstance(result, list):
            try:
                result = result[0]
            except:
                raise ExchangeError(self.id + ': Something wrong. Please contact bitwyre developer')
        #
        #     {
        #       "Consumer": [
        #         {
        #           "instrument": "btc_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "1 events/second"
        #         }, 
        #         {
        #           "instrument": "eth_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "5 events/second"
        #         },
        #       ],
        #       "Matching": [
        #         {
        #           "instrument": "btc_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "1 events/second"
        #         }, 
        #         {
        #           "instrument": "eth_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "5 events/second"
        #         },
        #       ],
        #       "Producer": [
        #         {
        #           "instrument": "btc_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "1 events/second"
        #         }, 
        #         {
        #           "instrument": "eth_usdt_spot", 
        #           "lag": "1", 
        #           "max_lag": "2000", 
        #           "throughput": "5 events/second"
        #         },
        #       ],
        #     }  
        #
        return result
    
    def fetch_contract(self, symbol=None, params={}):
        if symbol is None:
            symbol = 'all'

        params = {
            'instrument': symbol,
        }
        
        method = 'publicGetContract'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if error != [] or result == {}:
            raise BadRequest(self.id + ': Bad Request with symbol ' + symbol + ', Error ' + str(error))
        #
        #   {
        #     "24h_volume": null,
        #     "24h_volume_currency": "usd",
        #     "bitwyre_index_price": null,
        #     "bitwyre_index_price_currency": null,
        #     "contract_uuid": "e0182b13-9771-43c8-999d-e8d26ff04a4e",
        #     "contract_value": "1",
        #     "current_date": "Tuesday, 09 March 2021, 00:00:00",
        #     "details": "BTC/USD Futures Contract for Expiry 30 April 2021 at strike 70,000 USD/BTC",
        #     "expiry_date": "Friday, 30 April 2021, 00:00:00",
        #     "in_the_money": null,
        #     "index_price": null,
        #     "index_price_currency": "usd",
        #     "initial_margin_base_value": null,
        #     "instrument": "btcusdx_usd_210430F70000000000",
        #     "interest_rate": null,
        #     "is_call": "0",
        #     "is_futures": "1",
        #     "is_option": "0",
        #     "is_put": "0",
        #     "is_swap": "0",
        #     "maintenance_margin_base_value": null,
        #     "open_interest": null,
        #     "pricing_source": null,
        #     "strike_price": "70000000000",
        #     "timestamp": "1615280206226789000",
        #     "volatility": null
        #   }
        #
        return result
    
    def fetch_order_book(self, symbol, depth_num, params={}):
        self.load_markets()
        market = self.market(symbol)
        instrument = market['instrument']
        params = {
            'instrument': instrument,
            'depth_num': depth_num,
        }
        method = 'publicGetDepth'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if error != []:
            raise BadRequest(self.id + ': Bad Request with symbol ' + symbol + ', Error ' + str(error))
        # {
        #     "asks": [
        #         [
        #             "70000.0",
        #             "0.00001"
        #         ],
        #         [
        #             "70150.0",
        #             "0.00001"
        #         ],
        #         [
        #             "70200.0",
        #             "0.00001"
        #         ]
        #     ],
        #     "bids": [
        #         [
        #             "68250.0",
        #             "0.00008"
        #         ],
        #         [
        #             "56525.0",
        #             "0.00001"
        #         ],
        #         [
        #             "56500.0",
        #             "0.00001"
        #         ]
        #     ],
        #     "is_frozen": "0"
        # }
        return result
    
    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        instrument = market['instrument']
        params = {
            "instrument": instrument
        }
        method = 'publicGetTicker'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        error = self.safe_value(response, 'error', [])
        if error != []:
            raise BadRequest(self.id + ': Bad Request with instrument ' + instrument + ', Error ' + str(error))
        # {
        #     "asset_base": "btc",
        #     "asset_quote": "usdt",
        #     "best_ask": "70000.0",
        #     "best_bid": "68250.0",
        #     "high": "0",
        #     "instrument": "btc_usdt_spot",
        #     "is_frozen": "0",
        #     "last": "0",
        #     "low": "0",
        #     "market": "spot",
        #     "percent_change": "0",
        #     "timestamp": "1637901492505176681",
        #     "volume_base": "0",
        #     "volume_quote": "0"
        # }
        return result
    
    def fetch_balance(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["type"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))

        type_ = self.safe_string_lower(params, 'type', 'spot')
        params = self.omit(params, 'type')
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        account = self.safe_string(accountsByType, type_)
        response = {}
        if account == 'spot':
            method = 'privateGetAccountSpotbalance'
            response = getattr(self, method)(params)
        elif account == 'derivatives':
            method = 'privateGetAccountDerivativesbalance'
            response = getattr(self, method)(params)
        else:
            keys = list(accountsByType.keys())
            raise BadRequest(self.id + ' fetchBalance() type parameter must be one of ' + ', '.join(keys))
        all_asset_balance = self.safe_value(response, 'result', {})
        result = []
        for asset_balance_dict in all_asset_balance:
            result.append(
                {
                    "asset": self.safe_string(asset_balance_dict, 'asset'),
                    "available_balance": self.safe_string(asset_balance_dict, 'available_balance'),
                    "locked_balance": self.safe_string(asset_balance_dict, 'locked_balance'),
                    "total_balance": self.safe_string(asset_balance_dict, 'total_balance'),
                }
            )
        # [
        #     {
        #         "asset": "btc",
        #         "available_balance": "0.3",
        #         "locked_balance": "0.2",
        #         "total_balance": "0.5",
        #     },
        # ]
        return result
    
    def fetch_open_orders(self, symbol, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["from_time", "to_time"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))

        self.load_markets()
        market = self.market(symbol)
        instrument = market['instrument']
        instrument_dict = {"instrument": instrument}
        request = self.extend(instrument_dict, params)
        
        method = 'privateGetOrdersOpen'
        response = getattr(self, method)(request)
        result = self.safe_value(response, 'result', {})
        # {
        #     "usdt_usd_spot": [
        #         {
        #             "AvgPx": "0.0",
        #             "LastLiquidityInd": "0",
        #             "LastPx": "0.0",
        #             "LastQty": "0",
        #             "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #             "cancelondisconnect": "0",
        #             "clorderid": "",
        #             "cumqty": "0",
        #             "execid": "",
        #             "exectype": "0",
        #             "expiry": "0",
        #             "fill_price": "0.0",
        #             "instrument": "usdt_usd_spot",
        #             "leavesqty": "100",
        #             "notes": "",
        #             "orderid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "orderqty": "100",
        #             "ordrejreason": "100",
        #             "ordstatus": "13",
        #             "ordstatusReqID": "d3a4573d-8eb3-4fc6-81c0-e9befdfce59c",
        #             "ordtype": "2",
        #             "origclid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "price": "10030.0",
        #             "side": "2",
        #             "stoppx": "0.0",
        #             "time_in_force": "0",
        #             "timestamp": "1637902253260317933",
        #             "transacttime": "1637902256301440553",
        #             "value": "1003000.0"
        #         }
        #     ]
        # }
        return result
    
    def fetch_closed_orders(self, symbol, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["from_time", "to_time"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        self.load_markets()
        market = self.market(symbol)
        instrument = market['instrument']
        instrument_dict = {"instrument": instrument}
        request = self.extend(instrument_dict, params)
        
        method = 'privateGetOrdersClosed'
        response = getattr(self, method)(request)
        result = self.safe_value(response, 'result', {})
        # {
        #     "usdt_usd_spot": [
        #         {
        #             "AvgPx": "0.0",
        #             "LastLiquidityInd": "0",
        #             "LastPx": "0.0",
        #             "LastQty": "0",
        #             "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #             "cancelondisconnect": "0",
        #             "clorderid": "",
        #             "cumqty": "0",
        #             "execid": "",
        #             "exectype": "0",
        #             "expiry": "0",
        #             "fill_price": "0.0",
        #             "instrument": "usdt_usd_spot",
        #             "leavesqty": "100",
        #             "notes": "",
        #             "orderid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "orderqty": "100",
        #             "ordrejreason": "100",
        #             "ordstatus": "13",
        #             "ordstatusReqID": "d3a4573d-8eb3-4fc6-81c0-e9befdfce59c",
        #             "ordtype": "2",
        #             "origclid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "price": "10030.0",
        #             "side": "2",
        #             "stoppx": "0.0",
        #             "time_in_force": "0",
        #             "timestamp": "1637902253260317933",
        #             "transacttime": "1637902256301440553",
        #             "value": "1003000.0"
        #         }
        #     ]
        # }
        return result
    
    def fetch_cancelled_orders(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set([])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        response = {}
        method = 'privateGetOrdersCancelled'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        # {
        #     "usdt_usd_spot": [
        #         {
        #             "AvgPx": "0.0",
        #             "LastLiquidityInd": "0",
        #             "LastPx": "0.0",
        #             "LastQty": "0",
        #             "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #             "cancelondisconnect": "0",
        #             "clorderid": "",
        #             "cumqty": "0",
        #             "execid": "",
        #             "exectype": "0",
        #             "expiry": "0",
        #             "fill_price": "0.0",
        #             "instrument": "usdt_usd_spot",
        #             "leavesqty": "100",
        #             "notes": "",
        #             "orderid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "orderqty": "100",
        #             "ordrejreason": "100",
        #             "ordstatus": "13",
        #             "ordstatusReqID": "d3a4573d-8eb3-4fc6-81c0-e9befdfce59c",
        #             "ordtype": "2",
        #             "origclid": "45450109-e716-4e5e-b903-8130d8051585",
        #             "price": "10030.0",
        #             "side": "2",
        #             "stoppx": "0.0",
        #             "time_in_force": "0",
        #             "timestamp": "1637902253260317933",
        #             "transacttime": "1637902256301440553",
        #             "value": "1003000.0"
        #         }
        #     ]
        # }
        return result
    
    def fetch_orders_info(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["order_id"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        order_id = self.safe_string_lower(params, 'order_id', 'all')
        response = {}
        request = {
            'order_id': order_id,
        }
        method = 'privateGetOrdersInfoOrderId'
        params = self.omit(params, 'order_id')
        response = getattr(self, method)(self.extend(request, params))
        result = self.safe_value(response, 'result', {})
        # [
        #     {
        #         "AvgPx": "0.0",
        #         "LastLiquidityInd": "0",
        #         "LastPx": "0.0",
        #         "LastQty": "0.0",
        #         "account": "a2d0aba6-aadf-4bda-a403-ee66e87c684f",
        #         "cancelondisconnect": "0",
        #         "clorderid": "",
        #         "cumqty": "0.0",
        #         "execid": "",
        #         "exectype": "0",
        #         "expiry": "0",
        #         "fill_price": "0.0",
        #         "instrument": "usdt_usd_spot",
        #         "leavesqty": "100.0",
        #         "notes": "",
        #         "orderid": "919658a3-5cbe-4dbb-987a-d945715e971e",
        #         "orderqty": "100.0",
        #         "ordrejreason": "",
        #         "ordstatus": "13",
        #         "ordstatusReqID": "a9aeadc8-69a0-4194-982d-400b14b8e709",
        #         "ordtype": "2",
        #         "origclid": "919658a3-5cbe-4dbb-987a-d945715e971e",
        #         "price": "10011.0",
        #         "side": "2",
        #         "stoppx": "0.0",
        #         "time_in_force": "0",
        #         "timestamp": "1637902223144780331",
        #         "transacttime": "1637902225247678732",
        #         "value": "1001100.0"
        #     }
        # ]
        return result
    
    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if price is None:
            if type == 'market':
                ordtype = 1
            else:
                raise ArgumentsRequired(self.id + ' non-market orders must include price parameter')
        elif type == 'limit':
            ordtype = 2
        else:
            raise ExchangeError(self.id + ' allows market/limit orders only')
        
        if side == 'buy':
            side = 1
        elif side == 'sell':
            side = 2
        else:
            raise ExchangeError(self.id + ' allows sell/buy side only')

        self.load_markets()
        market = self.market(symbol)
        instrument = market['instrument']
        request = {
            'instrument': instrument,
            'ordtype': ordtype,
            'orderqty': amount,
            'side': side,
            'price': price
        }
        method = 'privatePostOrders'
        response = getattr(self, method)(self.extend(request, params))
        error = self.safe_value(response, 'error', {})
        if error != []:
            raise BadRequest(self.id + ': Bad Order Request: Error '+ str(error))
        result = self.safe_value(response, 'result', {})

        return result

    def cancel_order(self, symbol, id, quantity=[-1], params={}):
        self.load_markets()
        market = self.market(symbol)
        _ = market['instrument']
        request = {
            'order_ids': id,
            'qtys': quantity,
        }
        method = 'privateDeleteOrdersCancel'
        response = getattr(self, method)(self.extend(request, params))
        result = self.safe_value(response, 'result', {})

        return result

    def cancel_order_per_symbol(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        instrument = market['instrument']
        request = {
            'instrument': instrument,
        }
        method = 'privateDeleteOrdersCancelInstrumentInstrument'
        response = getattr(self, method)(self.extend(request, params))
        result = self.safe_value(response, 'result', {})

        return result

    def fetch_crypto_deposit_address(self, params={}):
        params_keys = set(params.keys())
        valid_keys = set(["asset"])
        invalid_keys = params_keys - valid_keys
        if invalid_keys:
            raise BadRequest(self.id + ': Invalid parameter(s) ' + str(list(invalid_keys)))
        
        asset = self.safe_string_lower(params, 'asset')
        if asset is None:
            raise ArgumentsRequired(self.id + ' fetchCryptoDepositAddress() requires asset parameter')
        
        params_asset = {
            'type': 'crypto'
        }
        response_asset = self.publicGetAssets(params_asset)
        result_asset = self.safe_value(response_asset, 'result', {})
        if not any(d['asset'] == asset for d in result_asset):
            raise BadRequest(self.id + ' fetchCryptoDepositAddress() asset '+ asset +' does not exist')

        method = 'privatePostAccountDepositCrypto'
        response = getattr(self, method)(params)
        result = self.safe_value(response, 'result', {})
        # {
        #     "deposit": {
        #         "BTC": [
        #             {
        #                 "address": "moEZpc8f3aakqK1ckuoN2WpYKbAeGo9xtg"
        #             }
        #         ]
        #     }
        # }
        return result

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api]
        if api == 'public':
            url += '/' + self.implode_params(path, params)
            params = self.omit(params, self.extract_params(path))
            if params:
                url += '?' + self.urlencode(params)
        elif api == 'private':
            self.check_required_credentials()
            uri_path = '/' + api + '/' + self.implode_params(path, params)
            url += '/' + self.implode_params(path, params)
            params = self.omit(params, self.extract_params(path))
            if params == {}:
                payload = None
                payload_json = self.json(self.json(payload))
            else:
                payload = params
                payload_json = self.json(self.json(self.json(payload)))
            nonce = self.nonce()
            checksum = self.hash(self.encode(str(payload_json)), 'sha256')
            nonce_checksum = self.hash(self.encode(str(nonce)) + self.encode(str(checksum)), 'sha256')
            signature = self.hmac(self.encode(uri_path) + self.encode(nonce_checksum), self.encode(self.secret), algorithm=hashlib.sha512)
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'API-Key': self.apiKey,
                'API-Sign': signature
            }
            body = {
                'nonce': nonce,
                'checksum': checksum,
            }
            if payload is not None:
                body.update({'payload': self.json(payload)})
            body = self.urlencode(body)
        
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
