# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class difx(Exchange):

    def describe(self):
        return self.deep_extend(super(difx, self).describe(), {
            'id': 'difx',
            'name': 'difx',
            'countries': ['SG'],  # Singapore
            # 8 requests per minute = 0.13333 per second => rateLimit = 750
            # testing 400 works
            'rateLimit': 400,
            'certified': True,
            'pro': False,
            # new metainfo interface
            'has': {
                'CORS': None,
                'spot': True,
                'margin': True,
                'swap': True,
                'future': True,
                'option': False,
                'addMargin': True,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'createOrder': True,
                'createReduceOnlyOrder': True,
                'createStopLimitOrder': True,
                'createStopMarketOrder': True,
                'createStopOrder': True,
                'fetchAccounts': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchDeposits': True,
                'fetchFundingFee': False,
                'fetchFundingFees': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': True,
                'fetchIndexOHLCV': False,
                'fetchLeverage': False,
                'fetchLeverageTiers': True,
                'fetchMarketLeverageTiers': 'emulated',
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': False,
                'fetchPosition': False,
                'fetchPositions': True,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': True,
                'fetchTransactions': True,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'fetchWithdrawal': False,
                'fetchWithdrawals': True,
                'reduceMargin': True,
                'setLeverage': True,
                'setMarginMode': True,
                'setPositionMode': False,
                'transfer': True,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '6h': '360',
                '12h': '720',
                '1d': '1d',
                '1w': '1w',
                '1M': '1m',
            },
            'version': 'v2',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg',
                'api': {
                    'rest': 'https://api.difx.com',
                },
                'test': {
                    'rest': 'https://api.difx.com',
                },
                'www': 'https://difx.com',
                'doc': [
                    'https://docs.difx.com',
                ],
                'fees': 'https://difx.com/en/feerate/transactionfee-traderate',
                'referral': {
                    'url': 'https://difx.com/en-us/register?inviteCode=EL6BXBQM',
                    'discount': 0.25,
                },
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'pairs': 1,
                            'currencies': 1,

                            'assets': 1,
                            'products': 1,
                            'ticker': 1,
                            'barhist/info': 1,
                            'barhist': 1,
                            'depth': 1,
                            'trades': 1,
                            'cash/assets': 1,  # not documented
                            'cash/products': 1,  # not documented
                            'margin/assets': 1,  # not documented
                            'margin/products': 1,  # not documented
                            'futures/collateral': 1,
                            'futures/contracts': 1,
                            'futures/ref-px': 1,
                            'futures/market-data': 1,
                            'futures/funding-rates': 1,
                            'risk-limit-info': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'info': 1,
                            'wallet/transactions': 1,
                            'wallet/deposit/address': 1,  # not documented
                            'data/balance/snapshot': 1,
                            'data/balance/history': 1,
                        },
                        'accountCategory': {
                            'get': {
                                'balance': 1,
                                'order/open': 1,
                                'order/status': 1,
                                'order/hist/current': 1,
                                'risk': 1,
                            },
                            'post': {
                                'order': 1,
                                'order/batch': 1,
                            },
                            'delete': {
                                'order': 1,
                                'order/all': 1,
                                'order/batch': 1,
                            },
                        },
                        'accountGroup': {
                            'get': {
                                'cash/balance': 1,
                                'margin/balance': 1,
                                'margin/risk': 1,
                                'futures/collateral-balance': 1,
                                'futures/position': 1,
                                'futures/risk': 1,
                                'futures/funding-payments': 1,
                                'order/hist': 1,
                                'spot/fee': 1,
                            },
                            'post': {
                                'transfer': 1,
                                'futures/transfer/deposit': 1,
                                'futures/transfer/withdraw': 1,
                            },
                        },
                    },
                },
                'v2': {
                    'public': {
                        'get': {
                            'assets': 1,
                            'futures/contract': 1,
                            'futures/collateral': 1,
                            'futures/pricing-data': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'account/info': 1,
                        },
                        'accountGroup': {
                            'get': {
                                'order/hist': 1,
                                'futures/position': 1,
                                'futures/free-margin': 1,
                                'futures/order/hist/current': 1,
                                'futures/order/open': 1,
                                'futures/order/status': 1,
                            },
                            'post': {
                                'futures/isolated-position-margin': 1,
                                'futures/margin-type': 1,
                                'futures/leverage': 1,
                                'futures/transfer/deposit': 1,
                                'futures/transfer/withdraw': 1,
                                'futures/order': 1,
                                'futures/order/batch': 1,
                                'futures/order/open': 1,
                                'subuser/subuser-transfer': 1,
                                'subuser/subuser-transfer-hist': 1,
                            },
                            'delete': {
                                'futures/order': 1,
                                'futures/order/batch': 1,
                                'futures/order/all': 1,
                            },
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'feeSide': 'get',
                    'tierBased': True,
                    'percentage': True,
                    'taker': self.parse_number('0.002'),
                    'maker': self.parse_number('0.002'),
                },
            },
            'precisionMode': TICK_SIZE,
            'options': {
                'account-category': 'cash',  # 'cash', 'margin', 'futures'  # obsolete
                'account-group': None,
                'fetchClosedOrders': {
                    'method': 'v1PrivateAccountGroupGetOrderHist',  # 'v1PrivateAccountGroupGetAccountCategoryOrderHistCurrent'
                },
                'defaultType': 'spot',  # 'spot', 'margin', 'swap'
                'accountsByType': {
                    'spot': 'cash',
                    'future': 'futures',
                    'margin': 'margin',
                },
                'transfer': {
                    'fillResponseFromRequest': True,
                },
            },
            'exceptions': {
                'exact': {
                    # not documented
                    '1900': BadRequest,  # {"code":1900,"message":"Invalid Http Request Input"}
                    '2100': AuthenticationError,  # {"code":2100,"message":"ApiKeyFailure"}
                    '5002': BadSymbol,  # {"code":5002,"message":"Invalid Symbol"}
                    '6001': BadSymbol,  # {"code":6001,"message":"Trading is disabled on symbol."}
                    '6010': InsufficientFunds,  # {'code': 6010, 'message': 'Not enough balance.'}
                    '60060': InvalidOrder,  # {'code': 60060, 'message': 'The order is already filled or canceled.'}
                    '600503': InvalidOrder,  # {"code":600503,"message":"Notional is too small."}
                    # documented
                    '100001': BadRequest,  # INVALID_HTTP_INPUT Http request is invalid
                    '100002': BadRequest,  # DATA_NOT_AVAILABLE Some required data is missing
                    '100003': BadRequest,  # KEY_CONFLICT The same key exists already
                    '100004': BadRequest,  # INVALID_REQUEST_DATA The HTTP request contains invalid field or argument
                    '100005': BadRequest,  # INVALID_WS_REQUEST_DATA Websocket request contains invalid field or argument
                    '100006': BadRequest,  # INVALID_ARGUMENT The arugment is invalid
                    '100007': BadRequest,  # ENCRYPTION_ERROR Something wrong with data encryption
                    '100008': BadSymbol,  # SYMBOL_ERROR Symbol does not exist or not valid for the request
                    '100009': AuthenticationError,  # AUTHORIZATION_NEEDED Authorization is require for the API access or request
                    '100010': BadRequest,  # INVALID_OPERATION The action is invalid or not allowed for the account
                    '100011': BadRequest,  # INVALID_TIMESTAMP Not a valid timestamp
                    '100012': BadRequest,  # INVALID_STR_FORMAT String format does not
                    '100013': BadRequest,  # INVALID_NUM_FORMAT Invalid number input
                    '100101': ExchangeError,  # UNKNOWN_ERROR Some unknown error
                    '150001': BadRequest,  # INVALID_JSON_FORMAT Require a valid json object
                    '200001': AuthenticationError,  # AUTHENTICATION_FAILED Authorization failed
                    '200002': ExchangeError,  # TOO_MANY_ATTEMPTS Tried and failed too many times
                    '200003': ExchangeError,  # ACCOUNT_NOT_FOUND Account not exist
                    '200004': ExchangeError,  # ACCOUNT_NOT_SETUP Account not setup properly
                    '200005': ExchangeError,  # ACCOUNT_ALREADY_EXIST Account already exist
                    '200006': ExchangeError,  # ACCOUNT_ERROR Some error related with error
                    '200007': ExchangeError,  # CODE_NOT_FOUND
                    '200008': ExchangeError,  # CODE_EXPIRED Code expired
                    '200009': ExchangeError,  # CODE_MISMATCH Code does not match
                    '200010': AuthenticationError,  # PASSWORD_ERROR Wrong assword
                    '200011': ExchangeError,  # CODE_GEN_FAILED Do not generate required code promptly
                    '200012': ExchangeError,  # FAKE_COKE_VERIFY
                    '200013': ExchangeError,  # SECURITY_ALERT Provide security alert message
                    '200014': PermissionDenied,  # RESTRICTED_ACCOUNT Account is restricted for certain activity, such as trading, or withdraw.
                    '200015': PermissionDenied,  # PERMISSION_DENIED No enough permission for the operation
                    '300001': InvalidOrder,  # INVALID_PRICE Order price is invalid
                    '300002': InvalidOrder,  # INVALID_QTY Order size is invalid
                    '300003': InvalidOrder,  # INVALID_SIDE Order side is invalid
                    '300004': InvalidOrder,  # INVALID_NOTIONAL Notional is too small or too large
                    '300005': InvalidOrder,  # INVALID_TYPE Order typs is invalid
                    '300006': InvalidOrder,  # INVALID_ORDER_ID Order id is invalid
                    '300007': InvalidOrder,  # INVALID_TIME_IN_FORCE Time In Force in order request is invalid
                    '300008': InvalidOrder,  # INVALID_ORDER_PARAMETER Some order parameter is invalid
                    '300009': InvalidOrder,  # TRADING_VIOLATION Trading violation on account or asset
                    '300011': InsufficientFunds,  # INVALID_BALANCE No enough account or asset balance for the trading
                    '300012': BadSymbol,  # INVALID_PRODUCT Not a valid product supported by exchange
                    '300013': InvalidOrder,  # INVALID_BATCH_ORDER Some or all orders are invalid in batch order request
                    '300014': InvalidOrder,  # {"code":300014,"message":"Order price doesn't conform to the required tick size: 0.1","reason":"TICK_SIZE_VIOLATION"}
                    '300020': InvalidOrder,  # TRADING_RESTRICTED There is some trading restriction on account or asset
                    '300021': InvalidOrder,  # TRADING_DISABLED Trading is disabled on account or asset
                    '300031': InvalidOrder,  # NO_MARKET_PRICE No market price for market type order trading
                    '310001': InsufficientFunds,  # INVALID_MARGIN_BALANCE No enough margin balance
                    '310002': InvalidOrder,  # INVALID_MARGIN_ACCOUNT Not a valid account for margin trading
                    '310003': InvalidOrder,  # MARGIN_TOO_RISKY Leverage is too high
                    '310004': BadSymbol,  # INVALID_MARGIN_ASSET This asset does not support margin trading
                    '310005': InvalidOrder,  # INVALID_REFERENCE_PRICE There is no valid reference price
                    '510001': ExchangeError,  # SERVER_ERROR Something wrong with server.
                    '900001': ExchangeError,  # HUMAN_CHALLENGE Human change do not pass
                },
                'broad': {},
            },
            'commonCurrencies': {
                'BOND': 'BONDED',
                'BTCBEAR': 'BEAR',
                'BTCBULL': 'BULL',
                'BYN': 'BeyondFi',
                'PLN': 'Pollen',
            },
        })

    def get_account(self, params={}):
        # get current or provided bitmax sub-account
        account = self.safe_value(params, 'account', self.options['account'])
        return account.lower().capitalize()

    def fetch_currencies(self, params={}):
        print("1.3")
        #assets = self.v1PublicGetPairs(params)
        assets = self.v1PublicGetCurrencies(params)
        #
        #     {
        #         "code":0,
        #         "data":[
        #             {
        #                 "assetCode" : "LTCBULL",
        #                 "assetName" : "3X Long LTC Token",
        #                 "precisionScale" : 9,
        #                 "nativeScale" : 4,
        #                 "withdrawalFee" : "0.2",
        #                 "minWithdrawalAmt" : "1.0",
        #                 "status" : "Normal"
        #             },
        #         ]
        #     }
        #
        #margin = self.v1PublicGetMarginAssets(params)
        #
        #     {
        #         "code":0,
        #         "data":[
        #             {
        #                 "assetCode":"BTT",
        #                 "borrowAssetCode":"BTT-B",
        #                 "interestAssetCode":"BTT-I",
        #                 "nativeScale":0,
        #                 "numConfirmations":1,
        #                 "withdrawFee":"100.0",
        #                 "minWithdrawalAmt":"1000.0",
        #                 "statusCode":"Normal",
        #                 "statusMessage":"",
        #                 "interestRate":"0.001"
        #             }
        #         ]
        #     }
        #
        #cash = self.v1PublicGetCashAssets(params)
        #
        #     {
        #         "code":0,
        #         "data":[
        #             {
        #                 "assetCode":"LTCBULL",
        #                 "nativeScale":4,
        #                 "numConfirmations":20,
        #                 "withdrawFee":"0.2",
        #                 "minWithdrawalAmt":"1.0",
        #                 "statusCode":"Normal",
        #                 "statusMessage":""
        #             }
        #         ]
        #     }
        #
        assetsData = self.safe_value(assets, '', assets)
        #marginData = self.safe_value(margin, 'data', [])
        #cashData = self.safe_value(cash, 'data', [])
        # assetsById = self.index_by(assetsData, 'assetCode')
        # marginById = self.index_by(marginData, 'assetCode')
        # cashById = self.index_by(cashData, 'assetCode')
        # dataById = self.deep_extend(assetsById, marginById, cashById)
        #ids = assetsData.keys()
        result = {}
        for i in range(0, len(assetsData)):
            #id = ids[i]
            data = assetsData[i]
            code = data['coin']
            currency = data['name']

            #currency = dataById[id]
            #scale = self.safe_string_2(currency, 'precisionScale', 'nativeScale')
            #precision = self.parse_number(self.parse_precision(scale))
            ## why would the exchange API have different names for the same field
            #fee = self.safe_number_2(currency, 'withdrawFee', 'withdrawalFee')
            #status = self.safe_string_2(currency, 'status', 'statusCode')
            #active = (status == 'Normal')
            #margin = ('borrowAssetCode' in currency)

            result[code] = {
                'id': code,
                'code': code,
                'info': currency,
                'type': None,
                #'margin': margin,
                'name': self.safe_string(data, 'name'),
                'active': True,
                'deposit': None,
                'withdraw': None,
                'fee': self.safe_string(data, 'wfee'),
                'precision': 8,
                'limits': {
                    'amount': {
                        'min': self.safe_number(data, 'dmin'),
                        'max': self.safe_number(data, 'dmax'),
                    },
                    'withdraw': {
                        'min': self.safe_number(data, 'wmin'),
                        'max': self.safe_number(data, 'wmax'),
                    },
                },
            }
        return result

    def fetch_markets(self, params={}):
        print('1.1')
        pairs = self.v1PublicGetPairs(params)
        pairsData = self.safe_value(pairs, '', pairs)

        result = []
        for i in range(0, len(pairsData)):

            data = pairsData[i];
            symbol = self.safe_string(data, 'symbol')
            base = self.safe_string(data, 'currency1')
            quote = self.safe_string(data, 'currency2')
            tfee = self.safe_number(data, 'tfee')
            mfee = self.safe_number(data, 'mfee')
            settle = None
            spot = settle is None
            swap = not spot
            linear = True if swap else None

            result.append({
                'id': symbol,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': settle,
                'baseId': base,
                'quoteId': quote,
                'settleId': None,
                'type': 'swap' if swap else 'spot',
                'spot': spot,
                #'margin': marginTradable if spot else None,
                'swap': swap,
                'future': False,
                'option': False,
                'active': True,
                'contract': swap,
                'linear': linear,
                'inverse': not linear if swap else None,
                'taker': tfee,
                'maker': mfee,
                'contractSize': self.parse_number('1') if swap else None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                # 'precision': {
                    # 'amount': self.safe_number(market, 'lotSize'),
                    # 'price': self.safe_number(market, 'tickSize'),
                # },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': 1,
                        'max': 20000,
                    },
                    'price': {
                        'min': 0.001,
                        'max': 2000000,
                    },
                    # 'cost': {
                        # 'min': self.safe_number(market, 'minNotional'),
                        # 'max': self.safe_number(market, 'maxNotional'),
                    # },
                },
                'info': " Market ",
            })
        return result

    def fetch_accounts(self, params={}):
        accountGroup = self.safe_string(self.options, 'account-group')
        response = None
        if accountGroup is None:
            response = self.v1PrivateGetInfo(params)
            #
            #     {
            #         "code":0,
            #         "data":{
            #             "email":"igor.kroitor@gmail.com",
            #             "accountGroup":8,
            #             "viewPermission":true,
            #             "tradePermission":true,
            #             "transferPermission":true,
            #             "cashAccount":["cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda"],
            #             "marginAccount":["martXoh1v1N3EMQC5FDtSj5VHso8aI2Z"],
            #             "futuresAccount":["futc9r7UmFJAyBY2rE3beA2JFxav2XFF"],
            #             "userUID":"U6491137460"
            #         }
            #     }
            #
            data = self.safe_value(response, 'data', {})
            accountGroup = self.safe_string(data, 'accountGroup')
            self.options['account-group'] = accountGroup
        return [
            {
                'id': accountGroup,
                'type': None,
                'currency': None,
                'info': response,
            },
        ]

    def parse_balance(self, response):
        result = {
            'info': response,
            'timestamp': None,
            'datetime': None,
        }
        balances = self.safe_value(response, 'data', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_currency_code(self.safe_string(balance, 'asset'))
            account = self.account()
            account['free'] = self.safe_string(balance, 'availableBalance')
            account['total'] = self.safe_string(balance, 'totalBalance')
            result[code] = account
        return self.safe_balance(result)

    def parse_swap_balance(self, response):
        timestamp = self.milliseconds()
        result = {
            'info': response,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
        }
        data = self.safe_value(response, 'data', {})
        collaterals = self.safe_value(data, 'collaterals', [])
        for i in range(0, len(collaterals)):
            balance = collaterals[i]
            code = self.safe_currency_code(self.safe_string(balance, 'asset'))
            account = self.account()
            account['total'] = self.safe_string(balance, 'balance')
            result[code] = account
        return self.safe_balance(result)

    def fetch_balance(self, params={}):
        self.load_markets()
        self.load_accounts()
        marketType, query = self.handle_market_type_and_params('fetchBalance', None, params)
        options = self.safe_value(self.options, 'fetchBalance', {})
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, marketType, 'cash')
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        request = {
            'account-group': accountGroup,
        }
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountCategoryGetBalance')
        method = self.get_supported_mapping(marketType, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupGetFuturesPosition',
        })
        if accountCategory == 'cash':
            request['account-category'] = accountCategory
        response = getattr(self, method)(self.extend(request, query))
        #
        # cash
        #
        #     {
        #         'code': 0,
        #         'data': [
        #             {
        #                 'asset': 'BCHSV',
        #                 'totalBalance': '64.298000048',
        #                 'availableBalance': '64.298000048',
        #             },
        #         ]
        #     }
        #
        # margin
        #
        #     {
        #         'code': 0,
        #         'data': [
        #             {
        #                 'asset': 'BCHSV',
        #                 'totalBalance': '64.298000048',
        #                 'availableBalance': '64.298000048',
        #                 'borrowed': '0',
        #                 'interest': '0',
        #             },
        #         ]
        #     }
        #
        # swap
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #             "ac": "FUTURES",
        #             "collaterals": [
        #                 {"asset":"ADA","balance":"0.355803","referencePrice":"1.05095","discountFactor":"0.9"},
        #                 {"asset":"USDT","balance":"0.000014519","referencePrice":"1","discountFactor":"1"}
        #             ],
        #         }j
        #     }
        #
        if marketType == 'swap':
            return self.parse_swap_balance(response)
        else:
            return self.parse_balance(response)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = self.v1PublicGetDepth(self.extend(request, params))
        #
        #     {
        #         "code":0,
        #         "data":{
        #             "m":"depth-snapshot",
        #             "symbol":"BTC-PERP",
        #             "data":{
        #                 "ts":1590223998202,
        #                 "seqnum":115444921,
        #                 "asks":[
        #                     ["9207.5","18.2383"],
        #                     ["9207.75","18.8235"],
        #                     ["9208","10.7873"],
        #                 ],
        #                 "bids":[
        #                     ["9207.25","0.4009"],
        #                     ["9207","0.003"],
        #                     ["9206.5","0.003"],
        #                 ]
        #             }
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        orderbook = self.safe_value(data, 'data', {})
        timestamp = self.safe_integer(orderbook, 'ts')
        result = self.parse_order_book(orderbook, symbol, timestamp)
        result['nonce'] = self.safe_integer(orderbook, 'seqnum')
        return result

    def parse_ticker(self, ticker, market=None):
        #
        #     {
        #         "symbol":"QTUM/BTC",
        #         "open":"0.00016537",
        #         "close":"0.00019077",
        #         "high":"0.000192",
        #         "low":"0.00016537",
        #         "volume":"846.6",
        #         "ask":["0.00018698","26.2"],
        #         "bid":["0.00018408","503.7"],
        #         "type":"spot"
        #     }
        #
        timestamp = None
        marketId = self.safe_string(ticker, 'symbol')
        type = self.safe_string(ticker, 'type')
        delimiter = '/' if (type == 'spot') else None
        symbol = self.safe_symbol(marketId, market, delimiter)
        close = self.safe_string(ticker, 'close')
        bid = self.safe_value(ticker, 'bid', [])
        ask = self.safe_value(ticker, 'ask', [])
        open = self.safe_string(ticker, 'open')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': None,
            'high': self.safe_string(ticker, 'high'),
            'low': self.safe_string(ticker, 'low'),
            'bid': self.safe_string(bid, 0),
            'bidVolume': self.safe_string(bid, 1),
            'ask': self.safe_string(ask, 0),
            'askVolume': self.safe_string(ask, 1),
            'vwap': None,
            'open': open,
            'close': close,
            'last': close,
            'previousClose': None,  # previous day close
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_string(ticker, 'volume'),
            'quoteVolume': None,
            'info': ticker,
        }, market, False)

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = self.v1PublicGetTicker(self.extend(request, params))
        #
        #     {
        #         "code":0,
        #         "data":{
        #             "symbol":"BTC-PERP",  # or "BTC/USDT"
        #             "open":"9073",
        #             "close":"9185.75",
        #             "high":"9185.75",
        #             "low":"9185.75",
        #             "volume":"576.8334",
        #             "ask":["9185.75","15.5863"],
        #             "bid":["9185.5","0.003"],
        #             "type":"derivatives",  # or "spot"
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        return self.parse_ticker(data, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        request = {}
        if symbols is not None:
            marketIds = self.market_ids(symbols)
            request['symbol'] = ','.join(marketIds)
        response = self.v1PublicGetTicker(self.extend(request, params))
        #
        #     {
        #         "code":0,
        #         "data":[
        #             {
        #                 "symbol":"QTUM/BTC",
        #                 "open":"0.00016537",
        #                 "close":"0.00019077",
        #                 "high":"0.000192",
        #                 "low":"0.00016537",
        #                 "volume":"846.6",
        #                 "ask":["0.00018698","26.2"],
        #                 "bid":["0.00018408","503.7"],
        #                 "type":"spot"
        #             }
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_tickers(data, symbols)

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     {
        #         "m":"bar",
        #         "s":"BTC/USDT",
        #         "data":{
        #             "i":"1",
        #             "ts":1590228000000,
        #             "o":"9139.59",
        #             "c":"9131.94",
        #             "h":"9139.99",
        #             "l":"9121.71",
        #             "v":"25.20648"
        #         }
        #     }
        #
        data = self.safe_value(ohlcv, 'data', {})
        return [
            self.safe_integer(data, 'ts'),
            self.safe_number(data, 'o'),
            self.safe_number(data, 'h'),
            self.safe_number(data, 'l'),
            self.safe_number(data, 'c'),
            self.safe_number(data, 'v'),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'interval': self.timeframes[timeframe],
        }
        # if since and limit are not specified
        # the exchange will return just 1 last candle by default
        duration = self.parse_timeframe(timeframe)
        options = self.safe_value(self.options, 'fetchOHLCV', {})
        defaultLimit = self.safe_integer(options, 'limit', 500)
        if since is not None:
            request['from'] = since
            if limit is None:
                limit = defaultLimit
            else:
                limit = min(limit, defaultLimit)
            request['to'] = self.sum(since, limit * duration * 1000, 1)
        elif limit is not None:
            request['n'] = limit  # max 500
        response = self.v1PublicGetBarhist(self.extend(request, params))
        #
        #     {
        #         "code":0,
        #         "data":[
        #             {
        #                 "m":"bar",
        #                 "s":"BTC/USDT",
        #                 "data":{
        #                     "i":"1",
        #                     "ts":1590228000000,
        #                     "o":"9139.59",
        #                     "c":"9131.94",
        #                     "h":"9139.99",
        #                     "l":"9121.71",
        #                     "v":"25.20648"
        #                 }
        #             }
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_ohlcvs(data, market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # public fetchTrades
        #
        #     {
        #         "p":"9128.5",  # price
        #         "q":"0.0030",  # quantity
        #         "ts":1590229002385,  # timestamp
        #         "bm":false,  # if True, the buyer is the market maker, we only use self field to "define the side" of a public trade
        #         "seqnum":180143985289898554
        #     }
        #
        timestamp = self.safe_integer(trade, 'ts')
        priceString = self.safe_string_2(trade, 'price', 'p')
        amountString = self.safe_string(trade, 'q')
        buyerIsMaker = self.safe_value(trade, 'bm', False)
        makerOrTaker = 'maker' if buyerIsMaker else 'taker'
        side = 'buy' if buyerIsMaker else 'sell'
        market = self.safe_market(None, market)
        return self.safe_trade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'id': None,
            'order': None,
            'type': None,
            'takerOrMaker': makerOrTaker,
            'side': side,
            'price': priceString,
            'amount': amountString,
            'cost': None,
            'fee': None,
        }, market)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['n'] = limit  # max 100
        response = self.v1PublicGetTrades(self.extend(request, params))
        #
        #     {
        #         "code":0,
        #         "data":{
        #             "m":"trades",
        #             "symbol":"BTC-PERP",
        #             "data":[
        #                 {"p":"9128.5","q":"0.0030","ts":1590229002385,"bm":false,"seqnum":180143985289898554},
        #                 {"p":"9129","q":"0.0030","ts":1590229002642,"bm":false,"seqnum":180143985289898587},
        #                 {"p":"9129.5","q":"0.0030","ts":1590229021306,"bm":false,"seqnum":180143985289899043}
        #             ]
        #         }
        #     }
        #
        records = self.safe_value(response, 'data', [])
        trades = self.safe_value(records, 'data', [])
        return self.parse_trades(trades, market, since, limit)

    def parse_order_status(self, status):
        statuses = {
            'PendingNew': 'open',
            'New': 'open',
            'PartiallyFilled': 'open',
            'Filled': 'closed',
            'Canceled': 'canceled',
            'Rejected': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        # createOrder
        #
        #     {
        #         "id": "16e607e2b83a8bXHbAwwoqDo55c166fa",
        #         "orderId": "16e85b4d9b9a8bXHbAwwoqDoc3d66830",
        #         "orderType": "Market",
        #         "symbol": "BTC/USDT",
        #         "timestamp": 1573576916201
        #     }
        #
        #     {
        #         "ac": "FUTURES",
        #         "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #         "time": 1640819389454,
        #         "orderId": "a17e0874ecbdU0711043490bbtcpDU5X",
        #         "seqNum": -1,
        #         "orderType": "Limit",
        #         "execInst": "NULL_VAL",
        #         "side": "Buy",
        #         "symbol": "BTC-PERP",
        #         "price": "30000",
        #         "orderQty": "0.002",
        #         "stopPrice": "0",
        #         "stopBy": "ref-px",
        #         "status": "Ack",
        #         "lastExecTime": 1640819389454,
        #         "lastQty": "0",
        #         "lastPx": "0",
        #         "avgFilledPx": "0",
        #         "cumFilledQty": "0",
        #         "fee": "0",
        #         "cumFee": "0",
        #         "feeAsset": "",
        #         "errorCode": "",
        #         "posStopLossPrice": "0",
        #         "posStopLossTrigger": "market",
        #         "posTakeProfitPrice": "0",
        #         "posTakeProfitTrigger": "market",
        #         "liquidityInd": "n"
        #      }
        #
        # fetchOrder, fetchOpenOrders, fetchClosedOrders
        #
        #     {
        #         "symbol":       "BTC/USDT",
        #         "price":        "8131.22",
        #         "orderQty":     "0.00082",
        #         "orderType":    "Market",
        #         "avgPx":        "7392.02",
        #         "cumFee":       "0.005152238",
        #         "cumFilledQty": "0.00082",
        #         "errorCode":    "",
        #         "feeAsset":     "USDT",
        #         "lastExecTime": 1575953151764,
        #         "orderId":      "a16eee20b6750866943712zWEDdAjt3",
        #         "seqNum":       2623469,
        #         "side":         "Buy",
        #         "status":       "Filled",
        #         "stopPrice":    "",
        #         "execInst":     "NULL_VAL"
        #     }
        #
        #     {
        #         "ac": "FUTURES",
        #         "accountId": "testabcdefg",
        #         "avgPx": "0",
        #         "cumFee": "0",
        #         "cumQty": "0",
        #         "errorCode": "NULL_VAL",
        #         "execInst": "NULL_VAL",
        #         "feeAsset": "USDT",
        #         "lastExecTime": 1584072844085,
        #         "orderId": "r170d21956dd5450276356bbtcpKa74",
        #         "orderQty": "1.1499",
        #         "orderType": "Limit",
        #         "price": "4000",
        #         "sendingTime": 1584072841033,
        #         "seqNum": 24105338,
        #         "side": "Buy",
        #         "status": "Canceled",
        #         "stopPrice": "",
        #         "symbol": "BTC-PERP"
        #     },
        #
        status = self.parse_order_status(self.safe_string(order, 'status'))
        marketId = self.safe_string(order, 'symbol')
        symbol = self.safe_symbol(marketId, market, '/')
        timestamp = self.safe_integer_2(order, 'timestamp', 'sendingTime')
        lastTradeTimestamp = self.safe_integer(order, 'lastExecTime')
        price = self.safe_string(order, 'price')
        amount = self.safe_string(order, 'orderQty')
        average = self.safe_string(order, 'avgPx')
        filled = self.safe_string_2(order, 'cumFilledQty', 'cumQty')
        id = self.safe_string(order, 'orderId')
        clientOrderId = self.safe_string(order, 'id')
        if clientOrderId is not None:
            if len(clientOrderId) < 1:
                clientOrderId = None
        type = self.safe_string_lower(order, 'orderType')
        side = self.safe_string_lower(order, 'side')
        feeCost = self.safe_number(order, 'cumFee')
        fee = None
        if feeCost is not None:
            feeCurrencyId = self.safe_string(order, 'feeAsset')
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            }
        stopPrice = self.safe_number(order, 'stopPrice')
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': type,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': stopPrice,
            'amount': amount,
            'cost': None,
            'average': average,
            'filled': filled,
            'remaining': None,
            'status': status,
            'fee': fee,
            'trades': None,
        }, market)

    def fetch_trading_fees(self, params={}):
        self.load_markets()
        self.load_accounts()
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        request = {
            'account-group': accountGroup,
        }
        response = self.v1PrivateAccountGroupGetSpotFee(self.extend(request, params))
        #
        #      {
        #         code: '0',
        #         data: {
        #           domain: 'spot',
        #           userUID: 'U1479576458',
        #           vipLevel: '0',
        #           fees: [
        #             {symbol: 'HT/USDT', fee: {taker: '0.001', maker: '0.001'}},
        #             {symbol: 'LAMB/BTC', fee: {taker: '0.002', maker: '0.002'}},
        #             {symbol: 'STOS/USDT', fee: {taker: '0.002', maker: '0.002'}},
        #             ...
        #           ]
        #         }
        #      }
        #
        data = self.safe_value(response, 'data', {})
        fees = self.safe_value(data, 'fees', [])
        result = {}
        for i in range(0, len(fees)):
            fee = fees[i]
            marketId = self.safe_string(fee, 'symbol')
            symbol = self.safe_symbol(marketId, None, '/')
            takerMaker = self.safe_value(fee, 'fee', {})
            result[symbol] = {
                'info': fee,
                'symbol': symbol,
                'maker': self.safe_number(takerMaker, 'maker'),
                'taker': self.safe_number(takerMaker, 'taker'),
            }
        return result

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        marketType = None
        marketType, params = self.handle_market_type_and_params('createOrder', market, params)
        options = self.safe_value(self.options, 'createOrder', {})
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, marketType, 'cash')
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_value(account, 'id')
        clientOrderId = self.safe_string_2(params, 'clientOrderId', 'id')
        reduceOnly = self.safe_value(params, 'execInst')
        if reduceOnly is not None:
            if (marketType != 'swap'):
                raise InvalidOrder(self.id + ' createOrder() does not support reduceOnly for ' + marketType + ' orders, reduceOnly orders are supported for perpetuals only')
        request = {
            'account-group': accountGroup,
            'account-category': accountCategory,
            'symbol': market['id'],
            'time': self.milliseconds(),
            'orderQty': self.amount_to_precision(symbol, amount),
            'orderType': type,  # "limit", "market", "stop_market", "stop_limit"
            'side': side,  # "buy" or "sell"
            # 'orderPrice': self.price_to_precision(symbol, price),
            # 'stopPrice': self.price_to_precision(symbol, stopPrice),  # required for stop orders
            # 'postOnly': 'false',  # 'false', 'true'
            # 'timeInForce': 'GTC',  # GTC, IOC, FOK
            # 'respInst': 'ACK',  # ACK, 'ACCEPT, DONE
            # 'posStopLossPrice': position stop loss price( v2 swap orders only)
            # 'posTakeProfitPrice': position take profit price(v2 swap orders only)
        }
        if clientOrderId is not None:
            request['id'] = clientOrderId
            params = self.omit(params, ['clientOrderId', 'id'])
        if (type == 'limit') or (type == 'stop_limit'):
            request['orderPrice'] = self.price_to_precision(symbol, price)
        if (type == 'stop_limit') or (type == 'stop_market'):
            stopPrice = self.safe_number(params, 'stopPrice')
            if stopPrice is None:
                raise InvalidOrder(self.id + ' createOrder() requires a stopPrice parameter for ' + type + ' orders')
            else:
                request['stopPrice'] = self.price_to_precision(symbol, stopPrice)
                params = self.omit(params, 'stopPrice')
        timeInForce = self.safe_string(params, 'timeInForce')
        postOnly = self.safe_value(params, 'postOnly', False)
        if (timeInForce == 'PO') or (postOnly):
            request['postOnly'] = True
            params = self.omit(params, ['postOnly', 'timeInForce'])
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountCategoryPostOrder')
        method = self.get_supported_mapping(marketType, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupPostFuturesOrder',
        })
        if method == 'v1PrivateAccountCategoryPostOrder':
            if accountCategory is not None:
                request['category'] = accountCategory
        else:
            request['account-category'] = accountCategory
        response = getattr(self, method)(self.extend(request, params))
        #
        # AccountCategoryPostOrder
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "ac": "MARGIN",
        #             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        #             "action": "place-order",
        #             "info": {
        #                 "id": "16e607e2b83a8bXHbAwwoqDo55c166fa",
        #                 "orderId": "16e85b4d9b9a8bXHbAwwoqDoc3d66830",
        #                 "orderType": "Market",
        #                 "symbol": "BTC/USDT",
        #                 "timestamp": 1573576916201
        #             },
        #             "status": "Ack"
        #         }
        #     }
        #
        # AccountGroupPostFuturesOrder
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "meta": {
        #                 "id": "",
        #                 "action": "place-order",
        #                 "respInst": "ACK"
        #             },
        #             "order": {
        #                 "ac": "FUTURES",
        #                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #                 "time": 1640819389454,
        #                 "orderId": "a17e0874ecbdU0711043490bbtcpDU5X",
        #                 "seqNum": -1,
        #                 "orderType": "Limit",
        #                 "execInst": "NULL_VAL",
        #                 "side": "Buy",
        #                 "symbol": "BTC-PERP",
        #                 "price": "30000",
        #                 "orderQty": "0.002",
        #                 "stopPrice": "0",
        #                 "stopBy": "ref-px",
        #                 "status": "Ack",
        #                 "lastExecTime": 1640819389454,
        #                 "lastQty": "0",
        #                 "lastPx": "0",
        #                 "avgFilledPx": "0",
        #                 "cumFilledQty": "0",
        #                 "fee": "0",
        #                 "cumFee": "0",
        #                 "feeAsset": "",
        #                 "errorCode": "",
        #                 "posStopLossPrice": "0",
        #                 "posStopLossTrigger": "market",
        #                 "posTakeProfitPrice": "0",
        #                 "posTakeProfitTrigger": "market",
        #                 "liquidityInd": "n"
        #             }
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        order = self.safe_value_2(data, 'order', 'info', {})
        return self.parse_order(order, market)

    def create_reduce_only_order(self, symbol, type, side, amount, price=None, params={}):
        request = {
            'execInst': 'reduceOnly',
        }
        return self.create_order(symbol, type, side, amount, price, self.extend(request, params))

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        type, query = self.handle_market_type_and_params('fetchOrder', market, params)
        options = self.safe_value(self.options, 'fetchOrder', {})
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, type, 'cash')
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_value(account, 'id')
        request = {
            'account-group': accountGroup,
            'account-category': accountCategory,
            'orderId': id,
        }
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountCategoryGetOrderStatus')
        method = self.get_supported_mapping(type, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupGetFuturesOrderStatus',
        })
        if method == 'v1PrivateAccountCategoryGetOrderStatus':
            if accountCategory is not None:
                request['category'] = accountCategory
        else:
            request['account-category'] = accountCategory
        response = getattr(self, method)(self.extend(request, query))
        #
        # AccountCategoryGetOrderStatus
        #
        #     {
        #         "code": 0,
        #         "accountCategory": "CASH",
        #         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        #         "data": [
        #             {
        #                 "symbol":       "BTC/USDT",
        #                 "price":        "8131.22",
        #                 "orderQty":     "0.00082",
        #                 "orderType":    "Market",
        #                 "avgPx":        "7392.02",
        #                 "cumFee":       "0.005152238",
        #                 "cumFilledQty": "0.00082",
        #                 "errorCode":    "",
        #                 "feeAsset":     "USDT",
        #                 "lastExecTime": 1575953151764,
        #                 "orderId":      "a16eee20b6750866943712zWEDdAjt3",
        #                 "seqNum":       2623469,
        #                 "side":         "Buy",
        #                 "status":       "Filled",
        #                 "stopPrice":    "",
        #                 "execInst":     "NULL_VAL"
        #             }
        #         ]
        #     }
        #
        # AccountGroupGetFuturesOrderStatus
        #
        #     {
        #         "code": 0,
        #         "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #         "ac": "FUTURES",
        #         "data": {
        #             "ac": "FUTURES",
        #             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #             "time": 1640247020217,
        #             "orderId": "r17de65747aeU0711043490bbtcp0cmt",
        #             "seqNum": 28796162908,
        #             "orderType": "Limit",
        #             "execInst": "NULL_VAL",
        #             "side": "Buy",
        #             "symbol": "BTC-PERP",
        #             "price": "30000",
        #             "orderQty": "0.0021",
        #             "stopPrice": "0",
        #             "stopBy": "market",
        #             "status": "New",
        #             "lastExecTime": 1640247020232,
        #             "lastQty": "0",
        #             "lastPx": "0",
        #             "avgFilledPx": "0",
        #             "cumFilledQty": "0",
        #             "fee": "0",
        #             "cumFee": "0",
        #             "feeAsset": "USDT",
        #             "errorCode": "",
        #             "posStopLossPrice": "0",
        #             "posStopLossTrigger": "market",
        #             "posTakeProfitPrice": "0",
        #             "posTakeProfitTrigger": "market",
        #             "liquidityInd": "n"
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        return self.parse_order(data, market)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        if symbol is not None:
            market = self.market(symbol)
            symbol = market['symbol']
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_value(account, 'id')
        type, query = self.handle_market_type_and_params('fetchOpenOrders', market, params)
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, type, 'cash')
        request = {
            'account-group': accountGroup,
            'account-category': accountCategory,
        }
        options = self.safe_value(self.options, 'fetchOpenOrders', {})
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountCategoryGetOrderOpen')
        method = self.get_supported_mapping(type, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupGetFuturesOrderOpen',
        })
        if method == 'v1PrivateAccountCategoryGetOrderOpen':
            if accountCategory is not None:
                request['category'] = accountCategory
        else:
            request['account-category'] = accountCategory
        response = getattr(self, method)(self.extend(request, query))
        #
        # AccountCategoryGetOrderOpen
        #
        #     {
        #         "ac": "CASH",
        #         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        #         "code": 0,
        #         "data": [
        #             {
        #                 "avgPx": "0",         # Average filled price of the order
        #                 "cumFee": "0",       # cumulative fee paid for self order
        #                 "cumFilledQty": "0",  # cumulative filled quantity
        #                 "errorCode": "",     # error code; could be empty
        #                 "feeAsset": "USDT",  # fee asset
        #                 "lastExecTime": 1576019723550,  #  The last execution time of the order
        #                 "orderId": "s16ef21882ea0866943712034f36d83",  # server provided orderId
        #                 "orderQty": "0.0083",  # order quantity
        #                 "orderType": "Limit",  # order type
        #                 "price": "7105",       # order price
        #                 "seqNum": 8193258,     # sequence number
        #                 "side": "Buy",         # order side
        #                 "status": "New",       # order status on matching engine
        #                 "stopPrice": "",       # only available for stop market and stop limit orders; otherwise empty
        #                 "symbol": "BTC/USDT",
        #                 "execInst": "NULL_VAL"  # execution instruction
        #             },
        #         ]
        #     }
        #
        # AccountGroupGetFuturesOrderOpen
        #
        # {
        #     "code": 0,
        #     "data": [
        #         {
        #             "ac": "FUTURES",
        #             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #             "time": 1640247020217,
        #             "orderId": "r17de65747aeU0711043490bbtcp0cmt",
        #             "seqNum": 28796162908,
        #             "orderType": "Limit",
        #             "execInst": "NULL_VAL",
        #             "side": "Buy",
        #             "symbol": "BTC-PERP",
        #             "price": "30000",
        #             "orderQty": "0.0021",
        #             "stopPrice": "0",
        #             "stopBy": "market",
        #             "status": "New",
        #             "lastExecTime": 1640247020232,
        #             "lastQty": "0",
        #             "lastPx": "0",
        #             "avgFilledPx": "0",
        #             "cumFilledQty": "0",
        #             "fee": "0",
        #             "cumFee": "0",
        #             "feeAsset": "USDT",
        #             "errorCode": "",
        #             "posStopLossPrice": "0",
        #             "posStopLossTrigger": "market",
        #             "posTakeProfitPrice": "0",
        #             "posTakeProfitTrigger": "market",
        #             "liquidityInd": "n"
        #         }
        #     ]
        # }
        #
        data = self.safe_value(response, 'data', [])
        if accountCategory == 'futures':
            return self.parse_orders(data, market, since, limit)
        # a workaround for https://github.com/ccxt/ccxt/issues/7187
        orders = []
        for i in range(0, len(data)):
            order = self.parse_order(data[i], market)
            orders.append(order)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        self.load_accounts()
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_value(account, 'id')
        request = {
            'account-group': accountGroup,
            # 'category': accountCategory,
            # 'symbol': market['id'],
            # 'orderType': 'market',  # optional, string
            # 'side': 'buy',  # or 'sell', optional, case insensitive.
            # 'status': 'Filled',  # "Filled", "Canceled", or "Rejected"
            # 'startTime': exchange.milliseconds(),
            # 'endTime': exchange.milliseconds(),
            # 'page': 1,
            # 'pageSize': 100,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        type, query = self.handle_market_type_and_params('fetchCLosedOrders', market, params)
        options = self.safe_value(self.options, 'fetchClosedOrders', {})
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountGroupGetOrderHist')
        method = self.get_supported_mapping(type, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupGetFuturesOrderHistCurrent',
        })
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, type, 'cash')
        if method == 'v1PrivateAccountGroupGetOrderHist':
            if accountCategory is not None:
                request['category'] = accountCategory
        else:
            request['account-category'] = accountCategory
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['pageSize'] = limit
        response = getattr(self, method)(self.extend(request, query))
        #
        # accountCategoryGetOrderHistCurrent
        #
        #     {
        #         "code":0,
        #         "accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda",
        #         "ac":"CASH",
        #         "data":[
        #             {
        #                 "seqNum":15561826728,
        #                 "orderId":"a17294d305c0U6491137460bethu7kw9",
        #                 "symbol":"ETH/USDT",
        #                 "orderType":"Limit",
        #                 "lastExecTime":1591635618200,
        #                 "price":"200",
        #                 "orderQty":"0.1",
        #                 "side":"Buy",
        #                 "status":"Canceled",
        #                 "avgPx":"0",
        #                 "cumFilledQty":"0",
        #                 "stopPrice":"",
        #                 "errorCode":"",
        #                 "cumFee":"0",
        #                 "feeAsset":"USDT",
        #                 "execInst":"NULL_VAL"
        #             }
        #         ]
        #     }
        #
        # accountGroupGetOrderHist
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "data": [
        #                 {
        #                     "ac": "FUTURES",
        #                     "accountId": "testabcdefg",
        #                     "avgPx": "0",
        #                     "cumFee": "0",
        #                     "cumQty": "0",
        #                     "errorCode": "NULL_VAL",
        #                     "execInst": "NULL_VAL",
        #                     "feeAsset": "USDT",
        #                     "lastExecTime": 1584072844085,
        #                     "orderId": "r170d21956dd5450276356bbtcpKa74",
        #                     "orderQty": "1.1499",
        #                     "orderType": "Limit",
        #                     "price": "4000",
        #                     "sendingTime": 1584072841033,
        #                     "seqNum": 24105338,
        #                     "side": "Buy",
        #                     "status": "Canceled",
        #                     "stopPrice": "",
        #                     "symbol": "BTC-PERP"
        #                 },
        #             ],
        #             "hasNext": False,
        #             "limit": 500,
        #             "page": 1,
        #             "pageSize": 20
        #         }
        #     }
        #
        # accountGroupGetFuturesOrderHistCurrent
        #
        #     {
        #         "code": 0,
        #         "data": [
        #             {
        #                 "ac": "FUTURES",
        #                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #                 "time": 1640245777002,
        #                 "orderId": "r17de6444fa6U0711043490bbtcpJ2lI",
        #                 "seqNum": 28796124902,
        #                 "orderType": "Limit",
        #                 "execInst": "NULL_VAL",
        #                 "side": "Buy",
        #                 "symbol": "BTC-PERP",
        #                 "price": "30000",
        #                 "orderQty": "0.0021",
        #                 "stopPrice": "0",
        #                 "stopBy": "market",
        #                 "status": "Canceled",
        #                 "lastExecTime": 1640246574886,
        #                 "lastQty": "0",
        #                 "lastPx": "0",
        #                 "avgFilledPx": "0",
        #                 "cumFilledQty": "0",
        #                 "fee": "0",
        #                 "cumFee": "0",
        #                 "feeAsset": "USDT",
        #                 "errorCode": "",
        #                 "posStopLossPrice": "0",
        #                 "posStopLossTrigger": "market",
        #                 "posTakeProfitPrice": "0",
        #                 "posTakeProfitTrigger": "market",
        #                 "liquidityInd": "n"
        #             }
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data')
        isArray = isinstance(data, list)
        if not isArray:
            data = self.safe_value(data, 'data', [])
        return self.parse_orders(data, market, since, limit)

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        type, query = self.handle_market_type_and_params('cancelOrder', market, params)
        options = self.safe_value(self.options, 'cancelOrder', {})
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, type, 'cash')
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_value(account, 'id')
        request = {
            'account-group': accountGroup,
            'account-category': accountCategory,
            'symbol': market['id'],
            'time': self.milliseconds(),
            'id': 'foobar',
        }
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountCategoryDeleteOrder')
        method = self.get_supported_mapping(type, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupDeleteFuturesOrder',
        })
        if method == 'v1PrivateAccountCategoryDeleteOrder':
            if accountCategory is not None:
                request['category'] = accountCategory
        else:
            request['account-category'] = accountCategory
        clientOrderId = self.safe_string_2(params, 'clientOrderId', 'id')
        if clientOrderId is None:
            request['orderId'] = id
        else:
            request['id'] = clientOrderId
            params = self.omit(params, ['clientOrderId', 'id'])
        response = getattr(self, method)(self.extend(request, query))
        #
        # AccountCategoryDeleteOrder
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        #             "ac": "CASH",
        #             "action": "cancel-order",
        #             "status": "Ack",
        #             "info": {
        #                 "id":        "wv8QGquoeamhssvQBeHOHGQCGlcBjj23",
        #                 "orderId":   "16e6198afb4s8bXHbAwwoqDo2ebc19dc",
        #                 "orderType": "",  # could be empty
        #                 "symbol":    "ETH/USDT",
        #                 "timestamp":  1573594877822
        #             }
        #         }
        #     }
        #
        # AccountGroupDeleteFuturesOrder
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "meta": {
        #                 "id": "foobar",
        #                 "action": "cancel-order",
        #                 "respInst": "ACK"
        #             },
        #             "order": {
        #                 "ac": "FUTURES",
        #                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #                 "time": 1640244480476,
        #                 "orderId": "r17de63086f4U0711043490bbtcpPUF4",
        #                 "seqNum": 28795959269,
        #                 "orderType": "Limit",
        #                 "execInst": "NULL_VAL",
        #                 "side": "Buy",
        #                 "symbol": "BTC-PERP",
        #                 "price": "30000",
        #                 "orderQty": "0.0021",
        #                 "stopPrice": "0",
        #                 "stopBy": "market",
        #                 "status": "New",
        #                 "lastExecTime": 1640244480491,
        #                 "lastQty": "0",
        #                 "lastPx": "0",
        #                 "avgFilledPx": "0",
        #                 "cumFilledQty": "0",
        #                 "fee": "0",
        #                 "cumFee": "0",
        #                 "feeAsset": "BTCPC",
        #                 "errorCode": "",
        #                 "posStopLossPrice": "0",
        #                 "posStopLossTrigger": "market",
        #                 "posTakeProfitPrice": "0",
        #                 "posTakeProfitTrigger": "market",
        #                 "liquidityInd": "n"
        #             }
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        order = self.safe_value_2(data, 'order', 'info', {})
        return self.parse_order(order, market)

    def cancel_all_orders(self, symbol=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        type, query = self.handle_market_type_and_params('cancelAllOrders', market, params)
        options = self.safe_value(self.options, 'cancelAllOrders', {})
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        accountCategory = self.safe_string(accountsByType, type, 'cash')
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_value(account, 'id')
        request = {
            'account-group': accountGroup,
            'account-category': accountCategory,
            'time': self.milliseconds(),
        }
        if symbol is not None:
            request['symbol'] = market['id']
        defaultMethod = self.safe_string(options, 'method', 'v1PrivateAccountCategoryDeleteOrderAll')
        method = self.get_supported_mapping(type, {
            'spot': defaultMethod,
            'margin': defaultMethod,
            'swap': 'v2PrivateAccountGroupDeleteFuturesOrderAll',
        })
        if method == 'v1PrivateAccountCategoryDeleteOrderAll':
            if accountCategory is not None:
                request['category'] = accountCategory
        else:
            request['account-category'] = accountCategory
        response = getattr(self, method)(self.extend(request, query))
        #
        # AccountCategoryDeleteOrderAll
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "ac": "CASH",
        #             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
        #             "action": "cancel-all",
        #             "info": {
        #                 "id":  "2bmYvi7lyTrneMzpcJcf2D7Pe9V1P9wy",
        #                 "orderId": "",
        #                 "orderType": "NULL_VAL",
        #                 "symbol": "",
        #                 "timestamp": 1574118495462
        #             },
        #             "status": "Ack"
        #         }
        #     }
        #
        # AccountGroupDeleteFuturesOrderAll
        #
        #     {
        #         "code": 0,
        #         "data": {
        #             "ac": "FUTURES",
        #             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
        #             "action": "cancel-all",
        #             "info": {
        #                 "symbol":"BTC-PERP"
        #             }
        #         }
        #     }
        #
        return response

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
        #         destTag: "",
        #         tagType: "",
        #         tagId: "",
        #         chainName: "ERC20",
        #         numConfirmations: 20,
        #         withdrawalFee: 1,
        #         nativeScale: 4,
        #         tips: []
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tagId = self.safe_string(depositAddress, 'tagId')
        tag = self.safe_string(depositAddress, tagId)
        self.check_address(address)
        code = None if (currency is None) else currency['code']
        chainName = self.safe_string(depositAddress, 'chainName')
        network = self.safe_network(chainName)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'network': network,
            'info': depositAddress,
        }

    def safe_network(self, networkId):
        networksById = {
            'TRC20': 'TRC20',
            'ERC20': 'ERC20',
            'GO20': 'GO20',
            'BEP2': 'BEP2',
            'BEP20(BSC)': 'BEP20',
            'Bitcoin': 'BTC',
            'Bitcoin ABC': 'BCH',
            'Litecoin': 'LTC',
            'Matic Network': 'MATIC',
            'Solana': 'SOL',
            'xDai': 'STAKE',
            'Akash': 'AKT',
        }
        return self.safe_string(networksById, networkId, networkId)

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        chainName = self.safe_string(params, 'chainName')
        params = self.omit(params, 'chainName')
        request = {
            'asset': currency['id'],
        }
        response = self.v1PrivateGetWalletDepositAddress(self.extend(request, params))
        #
        #     {
        #         "code":0,
        #         "data":{
        #             "asset":"USDT",
        #             "assetName":"Tether",
        #             "address":[
        #                 {
        #                     "address":"1N22odLHXnLPCjC8kwBJPTayarr9RtPod6",
        #                     "destTag":"",
        #                     "tagType":"",
        #                     "tagId":"",
        #                     "chainName":"Omni",
        #                     "numConfirmations":3,
        #                     "withdrawalFee":4.7,
        #                     "nativeScale":4,
        #                     "tips":[]
        #                 },
        #                 {
        #                     "address":"0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
        #                     "destTag":"",
        #                     "tagType":"",
        #                     "tagId":"",
        #                     "chainName":"ERC20",
        #                     "numConfirmations":20,
        #                     "withdrawalFee":1.0,
        #                     "nativeScale":4,
        #                     "tips":[]
        #                 }
        #             ]
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        addresses = self.safe_value(data, 'address', [])
        numAddresses = len(addresses)
        address = None
        if numAddresses > 1:
            addressesByChainName = self.index_by(addresses, 'chainName')
            if chainName is None:
                chainNames = list(addressesByChainName.keys())
                chains = ', '.join(chainNames)
                raise ArgumentsRequired(self.id + ' fetchDepositAddress() returned more than one address, a chainName parameter is required, one of ' + chains)
            address = self.safe_value(addressesByChainName, chainName, {})
        else:
            # first address
            address = self.safe_value(addresses, 0, {})
        result = self.parse_deposit_address(address, currency)
        return self.extend(result, {
            'info': response,
        })

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        request = {
            'txType': 'deposit',
        }
        return self.fetch_transactions(code, since, limit, self.extend(request, params))

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        request = {
            'txType': 'withdrawal',
        }
        return self.fetch_transactions(code, since, limit, self.extend(request, params))

    def fetch_transactions(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'asset': currency['id'],
            # 'page': 1,
            # 'pageSize': 20,
            # 'startTs': self.milliseconds(),
            # 'endTs': self.milliseconds(),
            # 'txType': undefned,  # deposit, withdrawal
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['asset'] = currency['id']
        if since is not None:
            request['startTs'] = since
        if limit is not None:
            request['pageSize'] = limit
        response = self.v1PrivateGetWalletTransactions(self.extend(request, params))
        #
        #     {
        #         code: 0,
        #         data: {
        #             data: [
        #                 {
        #                     requestId: "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
        #                     time: 1591606166000,
        #                     asset: "USDT",
        #                     transactionType: "deposit",
        #                     amount: "25",
        #                     commission: "0",
        #                     networkTransactionId: "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
        #                     status: "pending",
        #                     numConfirmed: 8,
        #                     numConfirmations: 20,
        #                     destAddress: {address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722"}
        #                 }
        #             ],
        #             page: 1,
        #             pageSize: 20,
        #             hasNext: False
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        transactions = self.safe_value(data, 'data', [])
        return self.parse_transactions(transactions, currency, since, limit)

    def parse_transaction_status(self, status):
        statuses = {
            'reviewing': 'pending',
            'pending': 'pending',
            'confirmed': 'ok',
            'rejected': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        #     {
        #         requestId: "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
        #         time: 1591606166000,
        #         asset: "USDT",
        #         transactionType: "deposit",
        #         amount: "25",
        #         commission: "0",
        #         networkTransactionId: "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
        #         status: "pending",
        #         numConfirmed: 8,
        #         numConfirmations: 20,
        #         destAddress: {
        #             address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
        #             destTag: "..."  # for currencies that have it
        #         }
        #     }
        #
        id = self.safe_string(transaction, 'requestId')
        amount = self.safe_number(transaction, 'amount')
        destAddress = self.safe_value(transaction, 'destAddress', {})
        address = self.safe_string(destAddress, 'address')
        tag = self.safe_string(destAddress, 'destTag')
        txid = self.safe_string(transaction, 'networkTransactionId')
        type = self.safe_string(transaction, 'transactionType')
        timestamp = self.safe_integer(transaction, 'time')
        currencyId = self.safe_string(transaction, 'asset')
        code = self.safe_currency_code(currencyId, currency)
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        feeCost = self.safe_number(transaction, 'commission')
        return {
            'info': transaction,
            'id': id,
            'currency': code,
            'amount': amount,
            'network': None,
            'address': address,
            'addressTo': address,
            'addressFrom': None,
            'tag': tag,
            'tagTo': tag,
            'tagFrom': None,
            'status': status,
            'type': type,
            'updated': None,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def fetch_positions(self, symbols=None, params={}):
        self.load_markets()
        self.load_accounts()
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        request = {
            'account-group': accountGroup,
        }
        return self.v2PrivateAccountGroupGetFuturesPosition(self.extend(request, params))

    def parse_funding_rate(self, fundingRate, market=None):
        #
        #      {
        #          "time": 1640061364830,
        #          "symbol": "EOS-PERP",
        #          "markPrice": "3.353854865",
        #          "indexPrice": "3.3542",
        #          "openInterest": "14242",
        #          "fundingRate": "-0.000073026",
        #          "nextFundingTime": 1640073600000
        #      }
        #
        marketId = self.safe_string(fundingRate, 'symbol')
        symbol = self.safe_symbol(marketId, market)
        currentTime = self.safe_integer(fundingRate, 'time')
        nextFundingRate = self.safe_number(fundingRate, 'fundingRate')
        nextFundingRateTimestamp = self.safe_integer(fundingRate, 'nextFundingTime')
        previousFundingTimestamp = None
        return {
            'info': fundingRate,
            'symbol': symbol,
            'markPrice': self.safe_number(fundingRate, 'markPrice'),
            'indexPrice': self.safe_number(fundingRate, 'indexPrice'),
            'interestRate': self.parse_number('0'),
            'estimatedSettlePrice': None,
            'timestamp': currentTime,
            'datetime': self.iso8601(currentTime),
            'previousFundingRate': None,
            'nextFundingRate': nextFundingRate,
            'previousFundingTimestamp': previousFundingTimestamp,
            'nextFundingTimestamp': nextFundingRateTimestamp,
            'previousFundingDatetime': self.iso8601(previousFundingTimestamp),
            'nextFundingDatetime': self.iso8601(nextFundingRateTimestamp),
        }

    def fetch_funding_rates(self, symbols, params={}):
        self.load_markets()
        response = self.v2PublicGetFuturesPricingData(params)
        #
        #     {
        #          "code": 0,
        #          "data": {
        #              "contracts": [
        #                  {
        #                      "time": 1640061364830,
        #                      "symbol": "EOS-PERP",
        #                      "markPrice": "3.353854865",
        #                      "indexPrice": "3.3542",
        #                      "openInterest": "14242",
        #                      "fundingRate": "-0.000073026",
        #                      "nextFundingTime": 1640073600000
        #                  },
        #              ],
        #              "collaterals": [
        #                  {
        #                      "asset": "USDTR",
        #                      "referencePrice": "1"
        #                  },
        #              ]
        #          }
        #      }
        #
        data = self.safe_value(response, 'data', {})
        contracts = self.safe_value(data, 'contracts', [])
        result = self.parse_funding_rates(contracts)
        return self.filter_by_array(result, 'symbol', symbols)

    def modify_margin_helper(self, symbol, amount, type, params={}):
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        amount = self.amount_to_precision(symbol, amount)
        request = {
            'account-group': accountGroup,
            'symbol': market['id'],
            'amount': amount,  # positive value for adding margin, negative for reducing
        }
        response = self.v2PrivateAccountGroupPostFuturesIsolatedPositionMargin(self.extend(request, params))
        #
        # Can only change margin for perpetual futures isolated margin positions
        #
        #     {
        #          "code": 0
        #     }
        #
        if type == 'reduce':
            amount = Precise.string_abs(amount)
        return self.extend(self.parse_modify_margin(response, market), {
            'amount': self.parse_number(amount),
            'type': type,
        })

    def parse_modify_margin(self, data, market=None):
        errorCode = self.safe_string(data, 'code')
        status = 'ok' if (errorCode == '0') else 'failed'
        return {
            'info': data,
            'type': None,
            'amount': None,
            'code': market['quote'],
            'symbol': market['symbol'],
            'status': status,
        }

    def reduce_margin(self, symbol, amount, params={}):
        return self.modify_margin_helper(symbol, amount, 'reduce', params)

    def add_margin(self, symbol, amount, params={}):
        return self.modify_margin_helper(symbol, amount, 'add', params)

    def set_leverage(self, leverage, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' setLeverage() requires a symbol argument')
        if (leverage < 1) or (leverage > 100):
            raise BadRequest(self.id + ' leverage should be between 1 and 100')
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        if market['type'] != 'future':
            raise BadSymbol(self.id + ' setLeverage() supports futures contracts only')
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        request = {
            'account-group': accountGroup,
            'symbol': market['id'],
            'leverage': leverage,
        }
        return self.v2PrivateAccountGroupPostFuturesLeverage(self.extend(request, params))

    def set_margin_mode(self, marginType, symbol=None, params={}):
        marginType = marginType.lower()
        if marginType == 'cross':
            marginType = 'crossed'
        if marginType != 'isolated' and marginType != 'crossed':
            raise BadRequest(self.id + ' setMarginMode() marginType argument should be isolated or cross')
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        request = {
            'account-group': accountGroup,
            'symbol': market['id'],
            'marginType': marginType,
        }
        if market['type'] != 'future':
            raise BadSymbol(self.id + ' setMarginMode() supports futures contracts only')
        return self.v2PrivateAccountGroupPostFuturesMarginType(self.extend(request, params))

    def fetch_leverage_tiers(self, symbols=None, params={}):
        self.load_markets()
        response = self.v2PublicGetFuturesContract(params)
        #
        #     {
        #         "code":0,
        #         "data":[
        #             {
        #                 "symbol":"BTC-PERP",
        #                 "status":"Normal",
        #                 "displayName":"BTCUSDT",
        #                 "settlementAsset":"USDT",
        #                 "underlying":"BTC/USDT",
        #                 "tradingStartTime":1579701600000,
        #                 "priceFilter":{"minPrice":"1","maxPrice":"1000000","tickSize":"1"},
        #                 "lotSizeFilter":{"minQty":"0.0001","maxQty":"1000000000","lotSize":"0.0001"},
        #                 "commissionType":"Quote",
        #                 "commissionReserveRate":"0.001",
        #                 "marketOrderPriceMarkup":"0.03",
        #                 "marginRequirements":[
        #                     {"positionNotionalLowerBound":"0","positionNotionalUpperBound":"50000","initialMarginRate":"0.01","maintenanceMarginRate":"0.006"},
        #                     {"positionNotionalLowerBound":"50000","positionNotionalUpperBound":"200000","initialMarginRate":"0.02","maintenanceMarginRate":"0.012"},
        #                     {"positionNotionalLowerBound":"200000","positionNotionalUpperBound":"2000000","initialMarginRate":"0.04","maintenanceMarginRate":"0.024"},
        #                     {"positionNotionalLowerBound":"2000000","positionNotionalUpperBound":"20000000","initialMarginRate":"0.1","maintenanceMarginRate":"0.06"},
        #                     {"positionNotionalLowerBound":"20000000","positionNotionalUpperBound":"40000000","initialMarginRate":"0.2","maintenanceMarginRate":"0.12"},
        #                     {"positionNotionalLowerBound":"40000000","positionNotionalUpperBound":"1000000000","initialMarginRate":"0.333333","maintenanceMarginRate":"0.2"}
        #                 ]
        #             }
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data')
        return self.parse_leverage_tiers(data, symbols, 'symbol')

    def parse_market_leverage_tiers(self, info, market=None):
        """
        :param dict info: Exchange market response for 1 market
        :param dict market: CCXT market
        """
        #
        #    {
        #        "symbol":"BTC-PERP",
        #        "status":"Normal",
        #        "displayName":"BTCUSDT",
        #        "settlementAsset":"USDT",
        #        "underlying":"BTC/USDT",
        #        "tradingStartTime":1579701600000,
        #        "priceFilter":{"minPrice":"1","maxPrice":"1000000","tickSize":"1"},
        #        "lotSizeFilter":{"minQty":"0.0001","maxQty":"1000000000","lotSize":"0.0001"},
        #        "commissionType":"Quote",
        #        "commissionReserveRate":"0.001",
        #        "marketOrderPriceMarkup":"0.03",
        #        "marginRequirements":[
        #            {"positionNotionalLowerBound":"0","positionNotionalUpperBound":"50000","initialMarginRate":"0.01","maintenanceMarginRate":"0.006"},
        #            {"positionNotionalLowerBound":"50000","positionNotionalUpperBound":"200000","initialMarginRate":"0.02","maintenanceMarginRate":"0.012"},
        #            {"positionNotionalLowerBound":"200000","positionNotionalUpperBound":"2000000","initialMarginRate":"0.04","maintenanceMarginRate":"0.024"},
        #            {"positionNotionalLowerBound":"2000000","positionNotionalUpperBound":"20000000","initialMarginRate":"0.1","maintenanceMarginRate":"0.06"},
        #            {"positionNotionalLowerBound":"20000000","positionNotionalUpperBound":"40000000","initialMarginRate":"0.2","maintenanceMarginRate":"0.12"},
        #            {"positionNotionalLowerBound":"40000000","positionNotionalUpperBound":"1000000000","initialMarginRate":"0.333333","maintenanceMarginRate":"0.2"}
        #        ]
        #    }
        #
        marginRequirements = self.safe_value(info, 'marginRequirements')
        id = self.safe_string(info, 'symbol')
        market = self.safe_market(id, market)
        tiers = []
        for i in range(0, len(marginRequirements)):
            tier = marginRequirements[i]
            initialMarginRate = self.safe_string(tier, 'initialMarginRate')
            tiers.append({
                'tier': self.sum(i, 1),
                'currency': market['quote'],
                'minNotional': self.safe_number(tier, 'positionNotionalLowerBound'),
                'maxNotional': self.safe_number(tier, 'positionNotionalUpperBound'),
                'maintenanceMarginRate': self.safe_number(tier, 'maintenanceMarginRate'),
                'maxLeverage': self.parse_number(Precise.string_div('1', initialMarginRate)),
                'info': tier,
            })
        return tiers

    def transfer(self, code, amount, fromAccount, toAccount, params={}):
        self.load_markets()
        self.load_accounts()
        account = self.safe_value(self.accounts, 0, {})
        accountGroup = self.safe_string(account, 'id')
        currency = self.currency(code)
        amount = self.currency_to_precision(code, amount)
        accountsByType = self.safe_value(self.options, 'accountsByType', {})
        fromId = self.safe_string(accountsByType, fromAccount, fromAccount)
        toId = self.safe_string(accountsByType, toAccount, toAccount)
        if fromId != 'cash' and toId != 'cash':
            raise ExchangeError(self.id + ' transfer() only supports direct balance transfer between spot and future, spot and margin')
        request = {
            'account-group': accountGroup,
            'amount': amount,
            'asset': currency['id'],
            'fromAccount': fromId,
            'toAccount': toId,
        }
        response = self.v1PrivateAccountGroupPostTransfer(self.extend(request, params))
        #
        #    {code: '0'}
        #
        transferOptions = self.safe_value(self.options, 'transfer', {})
        fillResponseFromRequest = self.safe_value(transferOptions, 'fillResponseFromRequest', True)
        transfer = self.parse_transfer(response, currency)
        if fillResponseFromRequest:
            transfer['fromAccount'] = fromAccount
            transfer['toAccount'] = toAccount
            transfer['amount'] = amount
            transfer['currency'] = code
        return transfer

    def parse_transfer(self, transfer, currency=None):
        #
        #    {code: '0'}
        #
        status = self.safe_integer(transfer, 'code')
        currencyCode = self.safe_currency_code(None, currency)
        timestamp = self.milliseconds()
        return {
            'info': transfer,
            'id': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'currency': currencyCode,
            'amount': None,
            'fromAccount': None,
            'toAccount': None,
            'status': self.parse_transfer_status(status),
        }

    def parse_transfer_status(self, status):
        if status == 0:
            return 'ok'
        return 'failed'

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        version = api[0]
        access = api[1]
        type = self.safe_string(api, 2)
        url = ''
        accountCategory = (type == 'accountCategory')
        if accountCategory or (type == 'accountGroup'):
            url += self.implode_params('/{account-group}', params)
            params = self.omit(params, 'account-group')
        request = self.implode_params(path, params)
        url += '/api/'
        if version == 'v2':
            request = version + '/' + request
        else:
            url += version + '/'
        if accountCategory:
            url += self.implode_params('{account-category}/', params)
        params = self.omit(params, 'account-category')
        url += request
        if (version == 'v1') and (request == 'cash/balance') or (request == 'margin/balance'):
            request = 'balance'
        if (version == 'v1') and (request == 'spot/fee'):
            request = 'fee'
        if request.find('subuser') >= 0:
            parts = request.split('/')
            request = parts[2]
        params = self.omit(params, self.extract_params(path))
        if access == 'public':
            if params:
                url += '?' + self.urlencode(params)
        else:
            self.check_required_credentials()
            timestamp = str(self.milliseconds())
            payload = timestamp + '+' + request
            hmac = self.hmac(self.encode(payload), self.encode(self.secret), hashlib.sha256, 'base64')
            headers = {
                'x-auth-key': self.apiKey,
                'x-auth-timestamp': timestamp,
                'x-auth-signature': hmac,
            }
            if method == 'GET':
                if params:
                    url += '?' + self.urlencode(params)
            else:
                headers['Content-Type'] = 'application/json'
                body = self.json(params)
        url = self.urls['api']['rest'] + url
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        #
        #     {'code': 6010, 'message': 'Not enough balance.'}
        #     {'code': 60060, 'message': 'The order is already filled or canceled.'}
        #     {"code":2100,"message":"ApiKeyFailure"}
        #     {"code":300001,"message":"Price is too low from market price.","reason":"INVALID_PRICE","accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda","ac":"CASH","action":"place-order","status":"Err","info":{"symbol":"BTC/USDT"}}
        #
        code = self.safe_string(response, 'code')
        message = self.safe_string(response, 'message')
        error = (code is not None) and (code != '0')
        if error or (message is not None):
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], code, feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message
