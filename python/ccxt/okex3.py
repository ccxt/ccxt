# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import hashlib
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import CancelPending
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import RequestTimeout


class okex3 (Exchange):

    def describe(self):
        return self.deep_extend(super(okex3, self).describe(), {
            'id': 'okex3',
            'name': 'OKEX',
            'countries': ['CN', 'US'],
            'version': 'v3',
            'rateLimit': 1000,  # up to 3000 requests per 5 minutes ≈ 600 requests per minute ≈ 10 requests per second ≈ 100 ms
            'has': {
                'CORS': False,
                'fetchOHLCV': True,
                'fetchOrder': True,
                'fetchOrders': False,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': False,  # see below
                'fetchDeposits': True,
                'fetchWithdrawals': True,
                'fetchTransactions': False,
                'fetchMyTrades': False,  # they don't have it
                'fetchDepositAddress': True,
                'fetchOrderTrades': True,
                'fetchTickers': True,
                'fetchLedger': True,
                'withdraw': True,
                'futures': True,
            },
            'timeframes': {
                '1m': '60',
                '3m': '180',
                '5m': '300',
                '15m': '900',
                '30m': '1800',
                '1h': '3600',
                '2h': '7200',
                '4h': '14400',
                '6h': '21600',
                '12h': '43200',
                '1d': '86400',
                '1w': '604800',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
                'api': 'https://www.okex.com',
                'www': 'https://www.okex.com',
                'doc': 'https://www.okex.com/docs/en/',
                'fees': 'https://www.okex.com/pages/products/fees.html',
            },
            'api': {
                'general': {
                    'get': [
                        'time',
                    ],
                },
                'account': {
                    'get': [
                        'currencies',
                        'wallet',
                        'wallet/{currency}',
                        'withdrawal/fee',
                        'withdrawal/history',
                        'withdrawal/history/{currency}',
                        'ledger',
                        'deposit/address',
                        'deposit/history',
                        'deposit/history/{currency}',
                    ],
                    'post': [
                        'transfer',
                        'withdrawal',
                    ],
                },
                'spot': {
                    'get': [
                        'accounts',
                        'accounts/{currency}',
                        'accounts/{currency}/ledger',
                        'orders',
                        'orders_pending',
                        'orders/{order_id}',
                        'orders/{client_oid}',
                        'fills',
                        # public
                        'instruments',
                        'instruments/{instrument_id}/book',
                        'instruments/ticker',
                        'instruments/{instrument_id}/ticker',
                        'instruments/{instrument_id}/trades',
                        'instruments/{instrument_id}/candles',
                    ],
                    'post': [
                        'orders',
                        'batch_orders',
                        'cancel_orders/{order_id}',
                        'cancel_orders/{client_oid}',
                        'cancel_batch_orders',
                    ],
                },
                'margin': {
                    'get': [
                        'accounts',
                        'accounts/{instrument_id}',
                        'accounts/{instrument_id}/ledger',
                        'accounts/availability',
                        'accounts/{instrument_id}/availability',
                        'accounts/borrowed',
                        'accounts/{instrument_id}/borrowed',
                        'orders',
                        'orders/{order_id}',
                        'orders/{client_oid}',
                        'orders_pending',
                        'fills',
                    ],
                    'post': [
                        'accounts/borrow',
                        'accounts/repayment',
                        'orders',
                        'batch_orders',
                        'cancel_orders',
                        'cancel_orders/{order_id}',
                        'cancel_orders/{client_oid}',
                        'cancel_batch_orders',
                    ],
                },
                'futures': {
                    'get': [
                        'position',
                        '{instrument_id}/position',
                        'accounts',
                        'accounts/{currency}',
                        'accounts/{currency}/leverage',
                        'accounts/{currency}/ledger',
                        'orders/{instrument_id}',
                        'orders/{instrument_id}/{order_id}',
                        'orders/{instrument_id}/{client_oid}',
                        'fills',
                        # public
                        'instruments',
                        'instruments/{instrument_id}/book',
                        'instruments/ticker',
                        'instruments/{instrument_id}/ticker',
                        'instruments/{instrument_id}/trades',
                        'instruments/{instrument_id}/candles',
                        'accounts/{instrument_id}/holds',
                        'instruments/{instrument_id}/index',
                        'rate',
                        'instruments/{instrument_id}/estimated_price',
                        'instruments/{instrument_id}/open_interest',
                        'instruments/{instrument_id}/price_limit',
                        'instruments/{instrument_id}/liquidation',
                        'instruments/{instrument_id}/mark_price',
                    ],
                    'post': [
                        'accounts/{currency}/leverage',
                        'order',
                        'orders',
                        'cancel_order/{instrument_id}/{order_id}',
                        'cancel_order/{instrument_id}/{client_oid}',
                        'cancel_batch_orders/{instrument_id}',
                    ],
                },
                'swap': {
                    'get': [
                        'position',
                        '{instrument_id}/position',
                        'accounts',
                        '{instrument_id}/accounts',
                        'accounts/{instrument_id}/settings',
                        'accounts/{instrument_id}/ledger',
                        'accounts/{instrument_id}/holds',
                        'orders/{instrument_id}',
                        'orders/{instrument_id}/{order_id}',
                        'orders/{instrument_id}/{client_oid}',
                        'fills',
                        # public
                        'instruments',
                        'instruments/{instrument_id}/depth?size=50',
                        'instruments/ticker',
                        'instruments/{instrument_id}/ticker',
                        'instruments/{instrument_id}/trades',
                        'instruments/{instrument_id}/candles',
                        'instruments/{instrument_id}/index',
                        'rate',
                        'instruments/{instrument_id}/open_interest',
                        'instruments/{instrument_id}/price_limit',
                        'instruments/{instrument_id}/liquidation',
                        'instruments/{instrument_id}/funding_time',
                        'instruments/{instrument_id}/mark_price',
                        'instruments/{instrument_id}/historical_funding_rate',
                    ],
                    'post': [
                        'accounts/{instrument_id}/leverage',
                        'order',
                        'orders',
                        'cancel_order/{instrument_id}/{order_id}',
                        'cancel_order/{instrument_id}/{client_oid}',
                        'cancel_batch_orders/{instrument_id}',
                    ],
                },
                # they have removed self part from public
                'ett': {
                    'get': [
                        'accounts',
                        'accounts/{currency}',
                        'accounts/{currency}/ledger',
                        'orders',  # fetchOrder, fetchOrders
                        # public
                        'constituents/{ett}',
                        'define-price/{ett}',
                    ],
                    'post': [
                        'orders',
                        'orders/{order_id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.0015,
                    'maker': 0.0010,
                },
                'spot': {
                    'taker': 0.0015,
                    'maker': 0.0010,
                },
                'futures': {
                    'taker': 0.0030,
                    'maker': 0.0020,
                },
                'swap': {
                    'taker': 0.0070,
                    'maker': 0.0020,
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'password': True,
            },
            'exceptions': {
                # http error codes
                # 400 Bad Request — Invalid request format
                # 401 Unauthorized — Invalid API Key
                # 403 Forbidden — You do not have access to the requested resource
                # 404 Not Found
                # 500 Internal Server Error — We had a problem with our server
                'exact': {
                    '1': ExchangeError,  # {"code": 1, "message": "System error"}
                    # undocumented
                    'failure to get a peer from the ring-balancer': ExchangeError,  # {"message": "failure to get a peer from the ring-balancer"}
                    '4010': PermissionDenied,  # {"code": 4010, "message": "For the security of your funds, withdrawals are not permitted within 24 hours after changing fund password  / mobile number / Google Authenticator settings "}
                    # common
                    '30001': AuthenticationError,  # {"code": 30001, "message": 'request header "OK_ACCESS_KEY" cannot be blank'}
                    '30002': AuthenticationError,  # {"code": 30002, "message": 'request header "OK_ACCESS_SIGN" cannot be blank'}
                    '30003': AuthenticationError,  # {"code": 30003, "message": 'request header "OK_ACCESS_TIMESTAMP" cannot be blank'}
                    '30004': AuthenticationError,  # {"code": 30004, "message": 'request header "OK_ACCESS_PASSPHRASE" cannot be blank'}
                    '30005': InvalidNonce,  # {"code": 30005, "message": "invalid OK_ACCESS_TIMESTAMP"}
                    '30006': AuthenticationError,  # {"code": 30006, "message": "invalid OK_ACCESS_KEY"}
                    '30007': BadRequest,  # {"code": 30007, "message": 'invalid Content_Type, please use "application/json" format'}
                    '30008': RequestTimeout,  # {"code": 30008, "message": "timestamp request expired"}
                    '30009': ExchangeError,  # {"code": 30009, "message": "system error"}
                    '30010': AuthenticationError,  # {"code": 30010, "message": "API validation failed"}
                    '30011': PermissionDenied,  # {"code": 30011, "message": "invalid IP"}
                    '30012': AuthenticationError,  # {"code": 30012, "message": "invalid authorization"}
                    '30013': AuthenticationError,  # {"code": 30013, "message": "invalid sign"}
                    '30014': DDoSProtection,  # {"code": 30014, "message": "request too frequent"}
                    '30015': AuthenticationError,  # {"code": 30015, "message": 'request header "OK_ACCESS_PASSPHRASE" incorrect'}
                    '30016': ExchangeError,  # {"code": 30015, "message": "you are using v1 apiKey, please use v1 endpoint. If you would like to use v3 endpoint, please subscribe to v3 apiKey"}
                    '30017': ExchangeError,  # {"code": 30017, "message": "apikey's broker id does not match"}
                    '30018': ExchangeError,  # {"code": 30018, "message": "apikey's domain does not match"}
                    '30019': ExchangeNotAvailable,  # {"code": 30019, "message": "Api is offline or unavailable"}
                    '30020': BadRequest,  # {"code": 30020, "message": "body cannot be blank"}
                    '30021': BadRequest,  # {"code": 30021, "message": "Json data format error"}, {"code": 30021, "message": "json data format error"}
                    '30022': PermissionDenied,  # {"code": 30022, "message": "Api has been frozen"}
                    '30023': BadRequest,  # {"code": 30023, "message": "{0} parameter cannot be blank"}
                    '30024': BadRequest,  # {"code": 30024, "message": "{0} parameter value error"}
                    '30025': BadRequest,  # {"code": 30025, "message": "{0} parameter category error"}
                    '30026': DDoSProtection,  # {"code": 30026, "message": "requested too frequent"}
                    '30027': AuthenticationError,  # {"code": 30027, "message": "login failure"}
                    '30028': PermissionDenied,  # {"code": 30028, "message": "unauthorized execution"}
                    '30029': AccountSuspended,  # {"code": 30029, "message": "account suspended"}
                    '30030': ExchangeError,  # {"code": 30030, "message": "endpoint request failed. Please try again"}
                    '30031': BadRequest,  # {"code": 30031, "message": "token does not exist"}
                    '30032': ExchangeError,  # {"code": 30032, "message": "pair does not exist"}
                    '30033': BadRequest,  # {"code": 30033, "message": "exchange domain does not exist"}
                    '30034': ExchangeError,  # {"code": 30034, "message": "exchange ID does not exist"}
                    '30035': ExchangeError,  # {"code": 30035, "message": "trading is not supported in self website"}
                    '30036': ExchangeError,  # {"code": 30036, "message": "no relevant data"}
                    '30038': AuthenticationError,  # {"code": 30038, "message": "user does not exist"}
                    '30037': ExchangeNotAvailable,  # {"code": 30037, "message": "endpoint is offline or unavailable"}
                    # futures
                    '32001': AccountSuspended,  # {"code": 32001, "message": "futures account suspended"}
                    '32002': PermissionDenied,  # {"code": 32002, "message": "futures account does not exist"}
                    '32003': CancelPending,  # {"code": 32003, "message": "canceling, please wait"}
                    '32004': ExchangeError,  # {"code": 32004, "message": "you have no unfilled orders"}
                    '32005': InvalidOrder,  # {"code": 32005, "message": "max order quantity"}
                    '32006': InvalidOrder,  # {"code": 32006, "message": "the order price or trigger price exceeds USD 1 million"}
                    '32007': InvalidOrder,  # {"code": 32007, "message": "leverage level must be the same for orders on the same side of the contract"}
                    '32008': InvalidOrder,  # {"code": 32008, "message": "Max. positions to open(cross margin)"}
                    '32009': InvalidOrder,  # {"code": 32009, "message": "Max. positions to open(fixed margin)"}
                    '32010': ExchangeError,  # {"code": 32010, "message": "leverage cannot be changed with open positions"}
                    '32011': ExchangeError,  # {"code": 32011, "message": "futures status error"}
                    '32012': ExchangeError,  # {"code": 32012, "message": "futures order update error"}
                    '32013': ExchangeError,  # {"code": 32013, "message": "token type is blank"}
                    '32014': ExchangeError,  # {"code": 32014, "message": "your number of contracts closing is larger than the number of contracts available"}
                    '32015': ExchangeError,  # {"code": 32015, "message": "margin ratio is lower than 100% before opening positions"}
                    '32016': ExchangeError,  # {"code": 32016, "message": "margin ratio is lower than 100% after opening position"}
                    '32017': ExchangeError,  # {"code": 32017, "message": "no BBO"}
                    '32018': ExchangeError,  # {"code": 32018, "message": "the order quantity is less than 1, please try again"}
                    '32019': ExchangeError,  # {"code": 32019, "message": "the order price deviates from the price of the previous minute by more than 3%"}
                    '32020': ExchangeError,  # {"code": 32020, "message": "the price is not in the range of the price limit"}
                    '32021': ExchangeError,  # {"code": 32021, "message": "leverage error"}
                    '32022': ExchangeError,  # {"code": 32022, "message": "self function is not supported in your country or region according to the regulations"}
                    '32023': ExchangeError,  # {"code": 32023, "message": "self account has outstanding loan"}
                    '32024': ExchangeError,  # {"code": 32024, "message": "order cannot be placed during delivery"}
                    '32025': ExchangeError,  # {"code": 32025, "message": "order cannot be placed during settlement"}
                    '32026': ExchangeError,  # {"code": 32026, "message": "your account is restricted from opening positions"}
                    '32029': ExchangeError,  # {"code": 32029, "message": "order info does not exist"}
                    '32028': ExchangeError,  # {"code": 32028, "message": "account is suspended and liquidated"}
                    '32027': ExchangeError,  # {"code": 32027, "message": "cancelled over 20 orders"}
                    '32044': ExchangeError,  # {"code": 32044, "message": "The margin ratio after submitting self order is lower than the minimum requirement({0}) for your tier."}
                    # token and margin trading
                    '33001': PermissionDenied,  # {"code": 33001, "message": "margin account for self pair is not enabled yet"}
                    '33002': AccountSuspended,  # {"code": 33002, "message": "margin account for self pair is suspended"}
                    '33003': InsufficientFunds,  # {"code": 33003, "message": "no loan balance"}
                    '33004': ExchangeError,  # {"code": 33004, "message": "loan amount cannot be smaller than the minimum limit"}
                    '33005': ExchangeError,  # {"code": 33005, "message": "repayment amount must exceed 0"}
                    '33006': ExchangeError,  # {"code": 33006, "message": "loan order not found"}
                    '33007': ExchangeError,  # {"code": 33007, "message": "status not found"}
                    '33008': ExchangeError,  # {"code": 33008, "message": "loan amount cannot exceed the maximum limit"}
                    '33009': ExchangeError,  # {"code": 33009, "message": "user ID is blank"}
                    '33010': ExchangeError,  # {"code": 33010, "message": "you cannot cancel an order during session 2 of call auction"}
                    '33011': ExchangeError,  # {"code": 33011, "message": "no new market data"}
                    '33012': ExchangeError,  # {"code": 33012, "message": "order cancellation failed"}
                    '33013': InvalidOrder,  # {"code": 33013, "message": "order placement failed"}
                    '33014': OrderNotFound,  # {"code": 33014, "message": "order does not exist"}
                    '33015': InvalidOrder,  # {"code": 33015, "message": "exceeded maximum limit"}
                    '33016': ExchangeError,  # {"code": 33016, "message": "margin trading is not open for self token"}
                    '33017': InsufficientFunds,  # {"code": 33017, "message": "insufficient balance"}
                    '33018': ExchangeError,  # {"code": 33018, "message": "self parameter must be smaller than 1"}
                    '33020': ExchangeError,  # {"code": 33020, "message": "request not supported"}
                    '33021': BadRequest,  # {"code": 33021, "message": "token and the pair do not match"}
                    '33022': InvalidOrder,  # {"code": 33022, "message": "pair and the order do not match"}
                    '33023': ExchangeError,  # {"code": 33023, "message": "you can only place market orders during call auction"}
                    '33024': InvalidOrder,  # {"code": 33024, "message": "trading amount too small"}
                    '33025': InvalidOrder,  # {"code": 33025, "message": "base token amount is blank"}
                    '33026': ExchangeError,  # {"code": 33026, "message": "transaction completed"}
                    '33027': InvalidOrder,  # {"code": 33027, "message": "cancelled order or order cancelling"}
                    '33028': InvalidOrder,  # {"code": 33028, "message": "the decimal places of the trading price exceeded the limit"}
                    '33029': InvalidOrder,  # {"code": 33029, "message": "the decimal places of the trading size exceeded the limit"}
                    '33034': ExchangeError,  # {"code": 33034, "message": "You can only place limit order after Call Auction has started"}
                    '33059': BadRequest,  # {"code": 33059, "message": "client_oid or order_id is required"}
                    '33060': BadRequest,  # {"code": 33060, "message": "Only fill in either parameter client_oid or order_id"}
                    # account
                    '34001': PermissionDenied,  # {"code": 34001, "message": "withdrawal suspended"}
                    '34002': InvalidAddress,  # {"code": 34002, "message": "please add a withdrawal address"}
                    '34003': ExchangeError,  # {"code": 34003, "message": "sorry, self token cannot be withdrawn to xx at the moment"}
                    '34004': ExchangeError,  # {"code": 34004, "message": "withdrawal fee is smaller than minimum limit"}
                    '34005': ExchangeError,  # {"code": 34005, "message": "withdrawal fee exceeds the maximum limit"}
                    '34006': ExchangeError,  # {"code": 34006, "message": "withdrawal amount is lower than the minimum limit"}
                    '34007': ExchangeError,  # {"code": 34007, "message": "withdrawal amount exceeds the maximum limit"}
                    '34008': InsufficientFunds,  # {"code": 34008, "message": "insufficient balance"}
                    '34009': ExchangeError,  # {"code": 34009, "message": "your withdrawal amount exceeds the daily limit"}
                    '34010': ExchangeError,  # {"code": 34010, "message": "transfer amount must be larger than 0"}
                    '34011': ExchangeError,  # {"code": 34011, "message": "conditions not met"}
                    '34012': ExchangeError,  # {"code": 34012, "message": "the minimum withdrawal amount for NEO is 1, and the amount must be an integer"}
                    '34013': ExchangeError,  # {"code": 34013, "message": "please transfer"}
                    '34014': ExchangeError,  # {"code": 34014, "message": "transfer limited"}
                    '34015': ExchangeError,  # {"code": 34015, "message": "subaccount does not exist"}
                    '34016': PermissionDenied,  # {"code": 34016, "message": "transfer suspended"}
                    '34017': AccountSuspended,  # {"code": 34017, "message": "account suspended"}
                    '34018': AuthenticationError,  # {"code": 34018, "message": "incorrect trades password"}
                    '34019': PermissionDenied,  # {"code": 34019, "message": "please bind your email before withdrawal"}
                    '34020': PermissionDenied,  # {"code": 34020, "message": "please bind your funds password before withdrawal"}
                    '34021': InvalidAddress,  # {"code": 34021, "message": "Not verified address"}
                    '34022': ExchangeError,  # {"code": 34022, "message": "Withdrawals are not available for sub accounts"}
                    '34023': PermissionDenied,  # {"code": 34023, "message": "Please enable futures trading before transferring your funds"}
                    # swap
                    '35001': ExchangeError,  # {"code": 35001, "message": "Contract does not exist"}
                    '35002': ExchangeError,  # {"code": 35002, "message": "Contract settling"}
                    '35003': ExchangeError,  # {"code": 35003, "message": "Contract paused"}
                    '35004': ExchangeError,  # {"code": 35004, "message": "Contract pending settlement"}
                    '35005': AuthenticationError,  # {"code": 35005, "message": "User does not exist"}
                    '35008': InvalidOrder,  # {"code": 35008, "message": "Risk ratio too high"}
                    '35010': InvalidOrder,  # {"code": 35010, "message": "Position closing too large"}
                    '35012': InvalidOrder,  # {"code": 35012, "message": "Incorrect order size"}
                    '35014': InvalidOrder,  # {"code": 35014, "message": "Order price is not within limit"}
                    '35015': InvalidOrder,  # {"code": 35015, "message": "Invalid leverage level"}
                    '35017': ExchangeError,  # {"code": 35017, "message": "Open orders exist"}
                    '35019': InvalidOrder,  # {"code": 35019, "message": "Order size too large"}
                    '35020': InvalidOrder,  # {"code": 35020, "message": "Order price too high"}
                    '35021': InvalidOrder,  # {"code": 35021, "message": "Order size exceeded current tier limit"}
                    '35022': ExchangeError,  # {"code": 35022, "message": "Contract status error"}
                    '35024': ExchangeError,  # {"code": 35024, "message": "Contract not initialized"}
                    '35025': InsufficientFunds,  # {"code": 35025, "message": "No account balance"}
                    '35026': ExchangeError,  # {"code": 35026, "message": "Contract settings not initialized"}
                    '35029': OrderNotFound,  # {"code": 35029, "message": "Order does not exist"}
                    '35030': InvalidOrder,  # {"code": 35030, "message": "Order size too large"}
                    '35031': InvalidOrder,  # {"code": 35031, "message": "Cancel order size too large"}
                    '35032': ExchangeError,  # {"code": 35032, "message": "Invalid user status"}
                    '35039': ExchangeError,  # {"code": 35039, "message": "Open order quantity exceeds limit"}
                    '35040': InvalidOrder,  # {"error_message":"Invalid order type","result":"true","error_code":"35040","order_id":"-1"}
                    '35044': ExchangeError,  # {"code": 35044, "message": "Invalid order status"}
                    '35046': InsufficientFunds,  # {"code": 35046, "message": "Negative account balance"}
                    '35047': InsufficientFunds,  # {"code": 35047, "message": "Insufficient account balance"}
                    '35048': ExchangeError,  # {"code": 35048, "message": "User contract is frozen and liquidating"}
                    '35049': InvalidOrder,  # {"code": 35049, "message": "Invalid order type"}
                    '35050': InvalidOrder,  # {"code": 35050, "message": "Position settings are blank"}
                    '35052': InsufficientFunds,  # {"code": 35052, "message": "Insufficient cross margin"}
                    '35053': ExchangeError,  # {"code": 35053, "message": "Account risk too high"}
                    '35055': InsufficientFunds,  # {"code": 35055, "message": "Insufficient account balance"}
                    '35057': ExchangeError,  # {"code": 35057, "message": "No last traded price"}
                    '35058': ExchangeError,  # {"code": 35058, "message": "No limit"}
                    '35059': BadRequest,  # {"code": 35059, "message": "client_oid or order_id is required"}
                    '35060': BadRequest,  # {"code": 35060, "message": "Only fill in either parameter client_oid or order_id"}
                    '35061': BadRequest,  # {"code": 35061, "message": "Invalid instrument_id"}
                    '35062': InvalidOrder,  # {"code": 35062, "message": "Invalid match_price"}
                    '35063': InvalidOrder,  # {"code": 35063, "message": "Invalid order_size"}
                    '35064': InvalidOrder,  # {"code": 35064, "message": "Invalid client_oid"}
                },
                'broad': {
                },
            },
            'options': {
                'fetchMarkets': ['spot', 'futures', 'swap'],
                'defaultType': 'spot',  # 'account', 'spot', 'margin', 'futures', 'swap'
                'auth': {
                    'time': 'public',
                    'currencies': 'private',
                    'instruments': 'public',
                    'rate': 'public',
                    'constituents/{ett}': 'public',
                    'define-price/{ett}': 'public',
                },
            },
            'commonCurrencies': {
                # OKEX refers to ERC20 version of Aeternity(AEToken)
                'AE': 'AET',  # https://github.com/ccxt/ccxt/issues/4981
                'FAIR': 'FairGame',
                'HOT': 'Hydro Protocol',
                'HSR': 'HC',
                'MAG': 'Maggie',
                'YOYO': 'YOYOW',
            },
        })

    def fetch_time(self, params={}):
        response = self.generalGetTime(params)
        #
        #     {
        #         "iso": "2015-01-07T23:47:25.201Z",
        #         "epoch": 1420674445.201
        #     }
        #
        return self.parse8601(self.safe_string(response, 'iso'))

    def fetch_markets(self, params={}):
        types = self.safe_value(self.options, 'fetchMarkets')
        result = []
        for i in range(0, len(types)):
            markets = self.fetch_markets_by_type(types[i], params)
            result = self.array_concat(result, markets)
        return result

    def parse_markets(self, markets):
        result = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    def parse_market(self, market):
        #
        # spot markets
        #
        #     [{  base_currency: "EOS",
        #           instrument_id: "EOS-OKB",
        #                min_size: "0.01",
        #              product_id: "EOS-OKB",
        #          quote_currency: "OKB",
        #          size_increment: "0.000001",
        #               tick_size: "0.0001"        },
        #
        #       ...,  # the spot endpoint also returns ETT instruments
        #
        #       {  base_currency: "OK06ETT",
        #          base_increment: "0.00000001",
        #           base_min_size: "0.01",
        #           instrument_id: "OK06ETT-USDT",
        #                min_size: "0.01",
        #              product_id: "OK06ETT-USDT",
        #          quote_currency: "USDT",
        #         quote_increment: "0.0001",
        #          size_increment: "0.00000001",
        #               tick_size: "0.0001"        }]
        #
        # futures markets
        #
        #     [{   instrument_id: "BTG-USD-190329",
        #         underlying_index: "BTG",
        #           quote_currency: "USD",
        #                tick_size: "0.01",
        #             contract_val: "10",
        #                  listing: "2018-12-14",
        #                 delivery: "2019-03-29",
        #          trade_increment: "1"               }  ]
        #
        # swap markets
        #
        #     [{   instrument_id: "BTC-USD-SWAP",
        #         underlying_index: "BTC",
        #           quote_currency: "USD",
        #                     coin: "BTC",
        #             contract_val: "100",
        #                  listing: "2018-10-23T20:11:00.443Z",
        #                 delivery: "2018-10-24T20:11:00.443Z",
        #           size_increment: "4",
        #                tick_size: "4"                         }  ]
        #
        id = self.safe_string(market, 'instrument_id')
        marketType = 'spot'
        spot = True
        future = False
        swap = False
        baseId = self.safe_string(market, 'base_currency')
        if baseId is None:
            marketType = 'swap'
            spot = False
            swap = True
            baseId = self.safe_string(market, 'coin')
            if baseId is None:
                swap = False
                future = True
                marketType = 'futures'
                baseId = self.safe_string(market, 'underlying_index')
        quoteId = self.safe_string(market, 'quote_currency')
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        symbol = (base + '/' + quote) if spot else id
        amountPrecision = self.safe_string(market, 'size_increment')
        if amountPrecision is not None:
            amountPrecision = self.precision_from_string(amountPrecision)
        pricePrecision = self.safe_string(market, 'tick_size')
        if pricePrecision is not None:
            pricePrecision = self.precision_from_string(pricePrecision)
        precision = {
            'amount': amountPrecision,
            'price': pricePrecision,
        }
        minAmount = self.safe_float_2(market, 'min_size', 'base_min_size')
        minPrice = self.safe_float(market, 'tick_size')
        if precision['price'] is not None:
            minPrice = math.pow(10, -precision['price'])
        minCost = None
        if minAmount is not None and minPrice is not None:
            minCost = minAmount * minPrice
        active = True
        fees = self.safe_value_2(self.fees, marketType, 'trading', {})
        return self.extend(fees, {
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'info': market,
            'type': marketType,
            'spot': spot,
            'futures': future,
            'swap': swap,
            'active': active,
            'precision': precision,
            'limits': {
                'amount': {
                    'min': minAmount,
                    'max': None,
                },
                'price': {
                    'min': minPrice,
                    'max': None,
                },
                'cost': {
                    'min': minCost,
                    'max': None,
                },
            },
        })

    def fetch_markets_by_type(self, type, params={}):
        method = type + 'GetInstruments'
        response = getattr(self, method)(params)
        #
        # spot markets
        #
        #     [{  base_currency: "EOS",
        #          base_increment: "0.000001",
        #           base_min_size: "0.01",
        #           instrument_id: "EOS-OKB",
        #                min_size: "0.01",
        #              product_id: "EOS-OKB",
        #          quote_currency: "OKB",
        #         quote_increment: "0.0001",
        #          size_increment: "0.000001",
        #               tick_size: "0.0001"    }      ]
        #
        # futures markets
        #
        #     [{   instrument_id: "BTG-USD-190329",
        #         underlying_index: "BTG",
        #           quote_currency: "USD",
        #                tick_size: "0.01",
        #             contract_val: "10",
        #                  listing: "2018-12-14",
        #                 delivery: "2019-03-29",
        #          trade_increment: "1"               }  ]
        #
        # swap markets
        #
        #     [{   instrument_id: "BTC-USD-SWAP",
        #         underlying_index: "BTC",
        #           quote_currency: "USD",
        #                     coin: "BTC",
        #             contract_val: "100",
        #                  listing: "2018-10-23T20:11:00.443Z",
        #                 delivery: "2018-10-24T20:11:00.443Z",
        #           size_increment: "4",
        #                tick_size: "4"                         }  ]
        #
        return self.parse_markets(response)

    def fetch_currencies(self, params={}):
        # has['fetchCurrencies'] is currently set to False
        # despite that their docs say these endpoints are public:
        #     https://www.okex.com/api/account/v3/withdrawal/fee
        #     https://www.okex.com/api/account/v3/currencies
        # it will still reply with {"code":30001, "message": "OK-ACCESS-KEY header is required"}
        # if you attempt to access it without authentication
        response = self.accountGetCurrencies(params)
        #
        #     [
        #         {
        #             name: '',
        #             currency: 'BTC',
        #             can_withdraw: '1',
        #             can_deposit: '1',
        #             min_withdrawal: '0.0100000000000000'
        #         },
        #     ]
        #
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = self.safe_string(currency, 'currency')
            code = self.safe_currency_code(id)
            precision = 8  # default precision, todo: fix "magic constants"
            name = self.safe_string(currency, 'name')
            canDeposit = self.safe_integer(currency, 'can_deposit')
            canWithdraw = self.safe_integer(currency, 'can_withdraw')
            active = canDeposit and canWithdraw
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'type': None,
                'name': name,
                'active': active,
                'fee': None,  # todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                    'withdraw': {
                        'min': self.safe_float(currency, 'min_withdrawal'),
                        'max': None,
                    },
                },
            }
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentId'
        method += 'Depth' if (market['type'] == 'swap') else 'Book'
        request = {
            'instrument_id': market['id'],
        }
        if limit is not None:
            request['size'] = limit  # max 200
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {     asks: [["0.02685268", "0.242571", "1"],
        #                    ["0.02685493", "0.164085", "1"],
        #                    ...
        #                    ["0.02779", "1.039", "1"],
        #                    ["0.027813", "0.0876", "1"]        ],
        #            bids: [["0.02684052", "10.371849", "1"],
        #                    ["0.02684051", "3.707", "4"],
        #                    ...
        #                    ["0.02634963", "0.132934", "1"],
        #                    ["0.02634962", "0.264838", "2"]    ],
        #       timestamp:   "2018-12-17T20:24:16.159Z"            }
        #
        timestamp = self.parse8601(self.safe_string(response, 'timestamp'))
        return self.parse_order_book(response, timestamp)

    def parse_ticker(self, ticker, market=None):
        #
        #     {        best_ask: "0.02665472",
        #               best_bid: "0.02665221",
        #          instrument_id: "ETH-BTC",
        #             product_id: "ETH-BTC",
        #                   last: "0.02665472",
        #                    ask: "0.02665472",  # missing in the docs
        #                    bid: "0.02665221",  # not mentioned in the docs
        #               open_24h: "0.02645482",
        #               high_24h: "0.02714633",
        #                low_24h: "0.02614109",
        #        base_volume_24h: "572298.901923",
        #              timestamp: "2018-12-17T21:20:07.856Z",
        #       quote_volume_24h: "15094.86831261"            }
        #
        timestamp = self.parse8601(self.safe_string(ticker, 'timestamp'))
        symbol = None
        marketId = self.safe_string(ticker, 'instrument_id')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        elif marketId is not None:
            parts = marketId.split('-')
            numParts = len(parts)
            if numParts == 2:
                baseId, quoteId = parts
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
            else:
                symbol = marketId
        if market is not None:
            symbol = market['symbol']
        last = self.safe_float(ticker, 'last')
        open = self.safe_float(ticker, 'open_24h')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high_24h'),
            'low': self.safe_float(ticker, 'low_24h'),
            'bid': self.safe_float(ticker, 'best_bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'best_ask'),
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'base_volume_24h'),
            'quoteVolume': self.safe_float(ticker, 'quote_volume_24h'),
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdTicker'
        request = {
            'instrument_id': market['id'],
        }
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {        best_ask: "0.02665472",
        #               best_bid: "0.02665221",
        #          instrument_id: "ETH-BTC",
        #             product_id: "ETH-BTC",
        #                   last: "0.02665472",
        #                    ask: "0.02665472",
        #                    bid: "0.02665221",
        #               open_24h: "0.02645482",
        #               high_24h: "0.02714633",
        #                low_24h: "0.02614109",
        #        base_volume_24h: "572298.901923",
        #              timestamp: "2018-12-17T21:20:07.856Z",
        #       quote_volume_24h: "15094.86831261"            }
        #
        return self.parse_ticker(response)

    def fetch_tickers_by_type(self, type, symbols=None, params={}):
        self.load_markets()
        method = type + 'GetInstrumentsTicker'
        response = getattr(self, method)(params)
        result = {}
        for i in range(0, len(response)):
            ticker = self.parse_ticker(response[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return result

    def fetch_tickers(self, symbols=None, params={}):
        defaultType = self.safe_string_2(self.options, 'fetchTickers', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        return self.fetch_tickers_by_type(type, symbols, self.omit(params, 'type'))

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #     spot trades
        #
        #         {
        #             time: "2018-12-17T23:31:08.268Z",
        #             timestamp: "2018-12-17T23:31:08.268Z",
        #             trade_id: "409687906",
        #             price: "0.02677805",
        #             size: "0.923467",
        #             side: "sell"
        #         }
        #
        #     futures trades, swap trades
        #
        #         {
        #             trade_id: "1989230840021013",
        #             side: "buy",
        #             price: "92.42",
        #             qty: "184",  # missing in swap markets
        #             size: "5",  # missing in futures markets
        #             timestamp: "2018-12-17T23:26:04.613Z"
        #         }
        #
        # fetchOrderTrades(private)
        #
        #     spot trades, margin trades
        #
        #         {
        #             "created_at":"2019-03-15T02:52:56.000Z",
        #             "exec_type":"T",  # whether the order is taker or maker
        #             "fee":"0.00000082",
        #             "instrument_id":"BTC-USDT",
        #             "ledger_id":"3963052721",
        #             "liquidity":"T",  # whether the order is taker or maker
        #             "order_id":"2482659399697408",
        #             "price":"3888.6",
        #             "product_id":"BTC-USDT",
        #             "side":"buy",
        #             "size":"0.00055306",
        #             "timestamp":"2019-03-15T02:52:56.000Z"
        #         },
        #
        #     futures trades, swap trades
        #
        #         {
        #             "trade_id":"197429674631450625",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "order_id":"6a-7-54d663a28-0",
        #             "price":"3.633",
        #             "order_qty":"1.0000",
        #             "fee":"-0.000551",
        #             "created_at":"2019-03-21T04:41:58.0Z",  # missing in swap trades
        #             "timestamp":"2019-03-25T05:56:31.287Z",  # missing in futures trades
        #             "exec_type":"M",  # whether the order is taker or maker
        #             "side":"short",  # "buy" in futures trades
        #         }
        #
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = self.parse8601(self.safe_string_2(trade, 'timestamp', 'created_at'))
        price = self.safe_float(trade, 'price')
        amount = self.safe_float_2(trade, 'size', 'qty')
        amount = self.safe_float(trade, 'order_qty', amount)
        takerOrMaker = self.safe_string_2(trade, 'exec_type', 'liquidity')
        if takerOrMaker == 'M':
            takerOrMaker = 'maker'
        elif takerOrMaker == 'T':
            takerOrMaker = 'taker'
        side = self.safe_string(trade, 'side')
        cost = None
        if amount is not None:
            if price is not None:
                cost = amount * price
        feeCost = self.safe_float(trade, 'fee')
        fee = None
        if feeCost is not None:
            feeCurrency = None
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        orderId = self.safe_string(trade, 'order_id')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': self.safe_string(trade, 'trade_id'),
            'order': orderId,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdTrades'
        if (limit is None) or (limit > 100):
            limit = 100  # maximum = default = 100
        request = {
            'instrument_id': market['id'],
            'limit': limit,
            # from: 'id',
            # to: 'id',
        }
        response = getattr(self, method)(self.extend(request, params))
        #
        # spot markets
        #
        #     [
        #         {
        #             time: "2018-12-17T23:31:08.268Z",
        #             timestamp: "2018-12-17T23:31:08.268Z",
        #             trade_id: "409687906",
        #             price: "0.02677805",
        #             size: "0.923467",
        #             side: "sell"
        #         }
        #     ]
        #
        # futures markets, swap markets
        #
        #     [
        #         {
        #             trade_id: "1989230840021013",
        #             side: "buy",
        #             price: "92.42",
        #             qty: "184",  # missing in swap markets
        #             size: "5",  # missing in futures markets
        #             timestamp: "2018-12-17T23:26:04.613Z"
        #         }
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        #
        # spot markets
        #
        #     {
        #         close: "0.02684545",
        #         high: "0.02685084",
        #         low: "0.02683312",
        #         open: "0.02683894",
        #         time: "2018-12-17T20:28:00.000Z",
        #         volume: "101.457222"
        #     }
        #
        # futures markets
        #
        #     [
        #         1545072720000,
        #         0.3159,
        #         0.3161,
        #         0.3144,
        #         0.3149,
        #         22886,
        #         725179.26172331,
        #     ]
        #
        if isinstance(ohlcv, list):
            numElements = len(ohlcv)
            volumeIndex = 6 if (numElements > 6) else 5
            timestamp = ohlcv[0]
            if isinstance(timestamp, basestring):
                timestamp = self.parse8601(timestamp)
            return [
                timestamp,  # timestamp
                float(ohlcv[1]),            # Open
                float(ohlcv[2]),            # High
                float(ohlcv[3]),            # Low
                float(ohlcv[4]),            # Close
                # float(ohlcv[5]),         # Quote Volume
                # float(ohlcv[6]),         # Base Volume
                float(ohlcv[volumeIndex]),  # Volume, okex will return base volume in the 7th element for future markets
            ]
        else:
            return [
                self.parse8601(self.safe_string(ohlcv, 'time')),
                self.safe_float(ohlcv, 'open'),    # Open
                self.safe_float(ohlcv, 'high'),    # High
                self.safe_float(ohlcv, 'low'),     # Low
                self.safe_float(ohlcv, 'close'),   # Close
                self.safe_float(ohlcv, 'volume'),  # Base Volume
            ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdCandles'
        request = {
            'instrument_id': market['id'],
            'granularity': self.timeframes[timeframe],
        }
        if since is not None:
            request['start'] = self.iso8601(since)
        response = getattr(self, method)(self.extend(request, params))
        #
        # spot markets
        #
        #     [{ close: "0.02683401",
        #           high: "0.02683401",
        #            low: "0.02683401",
        #           open: "0.02683401",
        #           time: "2018-12-17T23:47:00.000Z",
        #         volume: "0"                         },
        #       ...
        #       { close: "0.02684545",
        #           high: "0.02685084",
        #            low: "0.02683312",
        #           open: "0.02683894",
        #           time: "2018-12-17T20:28:00.000Z",
        #         volume: "101.457222"                }  ]
        #
        # futures
        #
        #     [[1545090660000,
        #         0.3171,
        #         0.3174,
        #         0.3171,
        #         0.3173,
        #         1648,
        #         51930.38579450868],
        #       ...
        #       [1545072720000,
        #         0.3159,
        #         0.3161,
        #         0.3144,
        #         0.3149,
        #         22886,
        #         725179.26172331]    ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_account_balance(self, response):
        #
        # account
        #
        #     [
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "BTC",
        #             hold:  0
        #         },
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "ETH",
        #             hold:  0
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "BTC",
        #             balance: "0.0000000497717339",
        #             available: "0.0000000497717339",
        #             holds: "0"
        #         },
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "ICN",
        #             balance: "0.00000000925",
        #             available: "0.00000000925",
        #             holds: "0"
        #         }
        #     ]
        #
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['total'] = self.safe_float(balance, 'balance')
            account['used'] = self.safe_float(balance, 'hold')
            account['free'] = self.safe_float(balance, 'available')
            result[code] = account
        return self.parse_balance(result)

    def parse_margin_balance(self, response):
        #
        #     [
        #         {
        #             "currency:BTC": {
        #                 "available":"0",
        #                 "balance":"0",
        #                 "borrowed":"0",
        #                 "can_withdraw":"0",
        #                 "frozen":"0",
        #                 "hold":"0",
        #                 "holds":"0",
        #                 "lending_fee":"0"
        #             },
        #             "currency:USDT": {
        #                 "available":"100",
        #                 "balance":"100",
        #                 "borrowed":"0",
        #                 "can_withdraw":"100",
        #                 "frozen":"0",
        #                 "hold":"0",
        #                 "holds":"0",
        #                 "lending_fee":"0"
        #             },
        #             "instrument_id":"BTC-USDT",
        #             "liquidation_price":"0",
        #             "product_id":"BTC-USDT",
        #             "risk_rate":""
        #         },
        #     ]
        #
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            marketId = self.safe_string(balance, 'instrument_id')
            market = self.safe_value(self.markets_by_id, marketId)
            symbol = None
            if market is None:
                baseId, quoteId = marketId.split('-')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
            else:
                symbol = market['symbol']
            omittedBalance = self.omit(balance, [
                'instrument_id',
                'liquidation_price',
                'product_id',
                'risk_rate',
                'margin_ratio',
            ])
            keys = list(omittedBalance.keys())
            accounts = {}
            for k in range(0, len(keys)):
                key = keys[k]
                marketBalance = balance[key]
                if key.find(':') >= 0:
                    parts = key.split(':')
                    currencyId = parts[1]
                    code = self.safe_currency_code(currencyId)
                    account = self.account()
                    account['total'] = self.safe_float(marketBalance, 'balance')
                    account['used'] = self.safe_float(marketBalance, 'hold')
                    account['free'] = self.safe_float(marketBalance, 'available')
                    accounts[code] = account
                else:
                    raise NotSupported(self.id + ' margin balance response format has changednot ')
            result[symbol] = self.parse_balance(accounts)
        return result

    def parse_futures_balance(self, response):
        #
        #     {
        #         "info":{
        #             "eos":{
        #                 "auto_margin":"0",
        #                 "contracts": [
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"0",
        #                         "instrument_id":"EOS-USD-190329",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"0",
        #                         "realized_pnl":"0",
        #                         "unrealized_pnl":"0"
        #                     },
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"14.54895721",
        #                         "instrument_id":"EOS-USD-190628",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"10.64042157",
        #                         "realized_pnl":"-3.90853564",
        #                         "unrealized_pnl":"-0.259"
        #                     },
        #                 ],
        #                 "equity":"50.75220665",
        #                 "margin_mode":"fixed",
        #                 "total_avail_balance":"40.37069445"
        #             },
        #         }
        #     }
        #
        # their root field name is "info", so our info will contain their info
        result = {'info': response}
        info = self.safe_value(response, 'info', {})
        ids = list(info.keys())
        for i in range(0, len(ids)):
            id = ids[i]
            code = self.safe_currency_code(id)
            balance = self.safe_value(info, id, {})
            account = self.account()
            # it may be incorrect to use total, free and used for swap accounts
            account['total'] = self.safe_float(balance, 'equity')
            account['free'] = self.safe_float(balance, 'total_avail_balance')
            result[code] = account
        return self.parse_balance(result)

    def parse_swap_balance(self, response):
        #
        #     {
        #         "info": [
        #             {
        #                 "equity":"3.0139",
        #                 "fixed_balance":"0.0000",
        #                 "instrument_id":"EOS-USD-SWAP",
        #                 "margin":"0.5523",
        #                 "margin_frozen":"0.0000",
        #                 "margin_mode":"crossed",
        #                 "margin_ratio":"1.0913",
        #                 "realized_pnl":"-0.0006",
        #                 "timestamp":"2019-03-25T03:46:10.336Z",
        #                 "total_avail_balance":"3.0000",
        #                 "unrealized_pnl":"0.0145"
        #             }
        #         ]
        #     }
        #
        # their root field name is "info", so our info will contain their info
        result = {'info': response}
        info = self.safe_value(response, 'info', [])
        for i in range(0, len(info)):
            balance = info[i]
            marketId = self.safe_string(balance, 'instrument_id')
            symbol = marketId
            if marketId in self.markets_by_id:
                symbol = self.markets_by_id[marketId]['symbol']
            account = self.account()
            # it may be incorrect to use total, free and used for swap accounts
            account['total'] = self.safe_float(balance, 'equity')
            account['free'] = self.safe_float(balance, 'total_avail_balance')
            result[symbol] = account
        return self.parse_balance(result)

    def fetch_balance(self, params={}):
        self.load_markets()
        defaultType = self.safe_string_2(self.options, 'fetchBalance', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " fetchBalance requires a type parameter(one of 'account', 'spot', 'margin', 'futures', 'swap').")
        suffix = 'Wallet' if (type == 'account') else 'Accounts'
        method = type + 'Get' + suffix
        query = self.omit(params, 'type')
        response = getattr(self, method)(query)
        #
        # account
        #
        #     [
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "BTC",
        #             hold:  0
        #         },
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "ETH",
        #             hold:  0
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "BTC",
        #             balance: "0.0000000497717339",
        #             available: "0.0000000497717339",
        #             holds: "0"
        #         },
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "ICN",
        #             balance: "0.00000000925",
        #             available: "0.00000000925",
        #             holds: "0"
        #         }
        #     ]
        #
        # margin
        #
        #     [
        #         {
        #             "currency:BTC": {
        #                 "available":"0",
        #                 "balance":"0",
        #                 "borrowed":"0",
        #                 "can_withdraw":"0",
        #                 "frozen":"0",
        #                 "hold":"0",
        #                 "holds":"0",
        #                 "lending_fee":"0"
        #             },
        #             "currency:USDT": {
        #                 "available":"100",
        #                 "balance":"100",
        #                 "borrowed":"0",
        #                 "can_withdraw":"100",
        #                 "frozen":"0",
        #                 "hold":"0",
        #                 "holds":"0",
        #                 "lending_fee":"0"
        #             },
        #             "instrument_id":"BTC-USDT",
        #             "liquidation_price":"0",
        #             "product_id":"BTC-USDT",
        #             "risk_rate":""
        #         },
        #     ]
        #
        # futures
        #
        #     {
        #         "info":{
        #             "eos":{
        #                 "auto_margin":"0",
        #                 "contracts": [
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"0",
        #                         "instrument_id":"EOS-USD-190329",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"0",
        #                         "realized_pnl":"0",
        #                         "unrealized_pnl":"0"
        #                     },
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"14.54895721",
        #                         "instrument_id":"EOS-USD-190628",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"10.64042157",
        #                         "realized_pnl":"-3.90853564",
        #                         "unrealized_pnl":"-0.259"
        #                     },
        #                 ],
        #                 "equity":"50.75220665",
        #                 "margin_mode":"fixed",
        #                 "total_avail_balance":"40.37069445"
        #             },
        #         }
        #     }
        #
        # swap
        #
        #     {
        #         "info": [
        #             {
        #                 "equity":"3.0139",
        #                 "fixed_balance":"0.0000",
        #                 "instrument_id":"EOS-USD-SWAP",
        #                 "margin":"0.5523",
        #                 "margin_frozen":"0.0000",
        #                 "margin_mode":"crossed",
        #                 "margin_ratio":"1.0913",
        #                 "realized_pnl":"-0.0006",
        #                 "timestamp":"2019-03-25T03:46:10.336Z",
        #                 "total_avail_balance":"3.0000",
        #                 "unrealized_pnl":"0.0145"
        #             }
        #         ]
        #     }
        #
        if (type == 'account') or (type == 'spot'):
            return self.parse_account_balance(response)
        elif type == 'margin':
            return self.parse_margin_balance(response)
        elif type == 'futures':
            return self.parse_futures_balance(response)
        elif type == 'swap':
            return self.parse_swap_balance(response)
        raise NotSupported(self.id + " fetchBalance does not support the '" + type + "' type(the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'instrument_id': market['id'],
            # 'client_oid': 'abcdef1234567890',  # [a-z0-9]{1,32}
            # 'order_type': '0',  # 0: Normal limit order(Unfilled and 0 represent normal limit order) 1: Post only 2: Fill Or Kill 3: Immediatel Or Cancel
        }
        method = None
        if market['futures'] or market['swap']:
            size = self.number_to_string(amount) if market['futures'] else self.amount_to_precision(symbol, amount)
            request = self.extend(request, {
                'type': type,  # 1:open long 2:open short 3:close long 4:close short for futures
                'size': size,
                'price': self.price_to_precision(symbol, price),
                # 'match_price': '0',  # Order at best counter party price?(0:no 1:yes). The default is 0. If it is set as 1, the price parameter will be ignored. When posting orders at best bid price, order_type can only be 0(regular order).
            })
            if market['futures']:
                request['leverage'] = '10'  # or '20'
            method = market['type'] + 'PostOrder'
        else:
            marginTrading = self.safe_string(params, 'margin_trading', '1')  # 1 = spot, 2 = margin
            request = self.extend(request, {
                'side': side,
                'type': type,  # limit/market
                'margin_trading': marginTrading,  # 1 = spot, 2 = margin
            })
            if type == 'limit':
                request['price'] = self.price_to_precision(symbol, price)
                request['size'] = self.amount_to_precision(symbol, amount)
            elif type == 'market':
                # for market buy it requires the amount of quote currency to spend
                if side == 'buy':
                    notional = self.safe_float(params, 'notional')
                    createMarketBuyOrderRequiresPrice = self.safe_value(self.options, 'createMarketBuyOrderRequiresPrice', True)
                    if createMarketBuyOrderRequiresPrice:
                        if price is not None:
                            if notional is None:
                                notional = amount * price
                        elif notional is None:
                            raise InvalidOrder(self.id + " createOrder() requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = False and supply the total cost value in the 'notional' extra parameter(the exchange-specific behaviour)")
                    request['notional'] = self.cost_to_precision(symbol, notional)
                else:
                    request['size'] = self.amount_to_precision(symbol, amount)
            method = 'marginPostOrders' if (marginTrading == '2') else 'spotPostOrders'
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {
        #         "client_oid":"oktspot79",
        #         "error_code":"",
        #         "error_message":"",
        #         "order_id":"2510789768709120",
        #         "result":true
        #     }
        #
        timestamp = self.milliseconds()
        id = self.safe_string(response, 'order_id')
        return {
            'info': response,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
        }

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        defaultType = self.safe_string_2(self.options, 'cancelOrder', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " cancelOrder requires a type parameter(one of 'spot', 'margin', 'futures', 'swap').")
        method = type + 'PostCancelOrder'
        request = {
            'instrument_id': market['id'],
        }
        if market['futures'] or market['swap']:
            method += 'InstrumentId'
        else:
            method += 's'
        clientOid = self.safe_string(params, 'client_oid')
        if clientOid is not None:
            method += 'ClientOid'
            request['client_oid'] = clientOid
        else:
            method += 'OrderId'
            request['order_id'] = id
        query = self.omit(params, 'type')
        response = getattr(self, method)(self.extend(request, query))
        result = response if ('result' in list(response.keys())) else self.safe_value(response, market['id'], {})
        #
        # spot, margin
        #
        #     {
        #         "btc-usdt": [
        #             {
        #                 "result":true,
        #                 "client_oid":"a123",
        #                 "order_id": "2510832677225473"
        #             }
        #         ]
        #     }
        #
        # futures, swap
        #
        #     {
        #         "result": True,
        #         "client_oid": "oktfuture10",  # missing if requested by order_id
        #         "order_id": "2517535534836736",
        #         "instrument_id": "EOS-USD-190628"
        #     }
        #
        return self.parse_order(result, market)

    def parse_order_status(self, status):
        statuses = {
            '-2': 'failed',
            '-1': 'canceled',
            '0': 'open',
            '1': 'open',
            '2': 'closed',
            '3': 'open',
            '4': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def parse_order_side(self, side):
        sides = {
            '1': 'buy',  # open long
            '2': 'sell',  # open short
            '3': 'sell',  # close long
            '4': 'buy',  # close short
        }
        return self.safe_string(sides, side, side)

    def parse_order(self, order, market=None):
        #
        # createOrder
        #
        #     {
        #         "client_oid":"oktspot79",
        #         "error_code":"",
        #         "error_message":"",
        #         "order_id":"2510789768709120",
        #         "result":true
        #     }
        #
        # cancelOrder
        #
        #     {
        #         "result": True,
        #         "client_oid": "oktfuture10",  # missing if requested by order_id
        #         "order_id": "2517535534836736",
        #         # instrument_id is missing for spot/margin orders
        #         # available in futures and swap orders only
        #         "instrument_id": "EOS-USD-190628",
        #     }
        #
        # fetchOrder, fetchOrdersByState, fetchOpenOrders, fetchClosedOrders
        #
        #     # spot and margin orders
        #
        #     {
        #         "client_oid":"oktspot76",
        #         "created_at":"2019-03-18T07:26:49.000Z",
        #         "filled_notional":"3.9734",
        #         "filled_size":"0.001",  # filled_qty in futures and swap orders
        #         "funds":"",  # self is most likely the same as notional
        #         "instrument_id":"BTC-USDT",
        #         "notional":"",
        #         "order_id":"2500723297813504",
        #         "order_type":"0",
        #         "price":"4013",
        #         "product_id":"BTC-USDT",  # missing in futures and swap orders
        #         "side":"buy",
        #         "size":"0.001",
        #         "status":"filled",
        #         "state": "2",
        #         "timestamp":"2019-03-18T07:26:49.000Z",
        #         "type":"limit"
        #     }
        #
        #     # futures and swap orders
        #
        #     {
        #         "instrument_id":"EOS-USD-190628",
        #         "size":"10",
        #         "timestamp":"2019-03-20T10:04:55.000Z",
        #         "filled_qty":"10",  # filled_size in spot and margin orders
        #         "fee":"-0.00841043",
        #         "order_id":"2512669605501952",
        #         "price":"3.668",
        #         "price_avg":"3.567",  # missing in spot and margin orders
        #         "status":"2",
        #         "state": "2",
        #         "type":"4",
        #         "contract_val":"10",
        #         "leverage":"10",  # missing in swap, spot and margin orders
        #         "client_oid":"",
        #         "pnl":"1.09510794",  # missing in swap, spo and margin orders
        #         "order_type":"0"
        #     }
        #
        id = self.safe_string(order, 'order_id')
        timestamp = self.parse8601(self.safe_string(order, 'timestamp'))
        side = self.safe_string(order, 'side')
        type = self.safe_string(order, 'type')
        if (side != 'buy') and(side != 'sell'):
            side = self.parse_order_side(type)
        if (type != 'limit') and(type != 'market'):
            if 'pnl' in order:
                type = 'futures'
            else:
                type = 'swap'
        symbol = None
        marketId = self.safe_string(order, 'instrument_id')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
            symbol = market['symbol']
        else:
            symbol = marketId
        if market is not None:
            if symbol is None:
                symbol = market['symbol']
        amount = self.safe_float(order, 'size')
        filled = self.safe_float_2(order, 'filled_size', 'filled_qty')
        remaining = None
        if amount is not None:
            if filled is not None:
                amount = max(amount, filled)
                remaining = max(0, amount - filled)
        if type == 'market':
            remaining = 0
        cost = self.safe_float_2(order, 'filled_notional', 'funds')
        price = self.safe_float(order, 'price')
        average = self.safe_float(order, 'price_avg')
        if cost is None:
            if filled is not None and average is not None:
                cost = average * filled
        else:
            if (average is None) and(filled is not None) and(filled > 0):
                average = cost / filled
        status = self.parse_order_status(self.safe_string(order, 'state'))
        feeCost = self.safe_float(order, 'fee')
        fee = None
        if feeCost is not None:
            feeCurrency = None
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        return {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
        }

    def fetch_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        defaultType = self.safe_string_2(self.options, 'fetchOrder', 'defaultType', market['type'])
        type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " fetchOrder requires a type parameter(one of 'spot', 'margin', 'futures', 'swap').")
        instrumentId = 'InstrumentId' if (market['futures'] or market['swap']) else ''
        method = type + 'GetOrders' + instrumentId
        request = {
            'instrument_id': market['id'],
            # 'client_oid': 'abcdef12345',  # optional, [a-z0-9]{1,32}
            # 'order_id': id,
        }
        clientOid = self.safe_string(params, 'client_oid')
        if clientOid is not None:
            method += 'ClientOid'
            request['client_oid'] = clientOid
        else:
            method += 'OrderId'
            request['order_id'] = id
        query = self.omit(params, 'type')
        response = getattr(self, method)(self.extend(request, query))
        #
        # spot, margin
        #
        #     {
        #         "client_oid":"oktspot70",
        #         "created_at":"2019-03-15T02:52:56.000Z",
        #         "filled_notional":"3.8886",
        #         "filled_size":"0.001",
        #         "funds":"",
        #         "instrument_id":"BTC-USDT",
        #         "notional":"",
        #         "order_id":"2482659399697408",
        #         "order_type":"0",
        #         "price":"3927.3",
        #         "product_id":"BTC-USDT",
        #         "side":"buy",
        #         "size":"0.001",
        #         "status":"filled",
        #         "state": "2",
        #         "timestamp":"2019-03-15T02:52:56.000Z",
        #         "type":"limit"
        #     }
        #
        # futures, swap
        #
        #     {
        #         "instrument_id":"EOS-USD-190628",
        #         "size":"10",
        #         "timestamp":"2019-03-20T02:46:38.000Z",
        #         "filled_qty":"10",
        #         "fee":"-0.0080819",
        #         "order_id":"2510946213248000",
        #         "price":"3.712",
        #         "price_avg":"3.712",
        #         "status":"2",
        #         "state": "2",
        #         "type":"2",
        #         "contract_val":"10",
        #         "leverage":"10",
        #         "client_oid":"",  # missing in swap orders
        #         "pnl":"0",  # missing in swap orders
        #         "order_type":"0"
        #     }
        #
        return self.parse_order(response)

    def fetch_orders_by_state(self, state, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrdersByState requires a symbol argument')
        defaultType = self.safe_string_2(self.options, 'fetchOrdersByState', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(self.id + " fetchOrdersByState requires a type parameter(one of 'spot', 'margin', 'futures', 'swap').")
        self.load_markets()
        market = self.market(symbol)
        # '-2': failed,
        # '-1': cancelled,
        #  '0': open ,
        #  '1': partially filled,
        #  '2': fully filled,
        #  '3': submitting,
        #  '4': cancelling,
        #  '6': incomplete（open+partially filled),
        #  '7': complete（cancelled+fully filled),
        request = {
            'instrument_id': market['id'],
            'state': state,
        }
        method = type + 'GetOrders'
        if market['futures'] or market['swap']:
            method += 'InstrumentId'
        query = self.omit(params, 'type')
        response = getattr(self, method)(self.extend(request, query))
        #
        # spot, margin
        #
        #     [
        #         # in fact, self documented API response does not correspond
        #         # to their actual API response for spot markets
        #         # OKEX v3 API returns a plain array of orders(see below)
        #         [
        #             {
        #                 "client_oid":"oktspot76",
        #                 "created_at":"2019-03-18T07:26:49.000Z",
        #                 "filled_notional":"3.9734",
        #                 "filled_size":"0.001",
        #                 "funds":"",
        #                 "instrument_id":"BTC-USDT",
        #                 "notional":"",
        #                 "order_id":"2500723297813504",
        #                 "order_type":"0",
        #                 "price":"4013",
        #                 "product_id":"BTC-USDT",
        #                 "side":"buy",
        #                 "size":"0.001",
        #                 "status":"filled",
        #                 "state": "2",
        #                 "timestamp":"2019-03-18T07:26:49.000Z",
        #                 "type":"limit"
        #             },
        #         ],
        #         {
        #             "before":"2500723297813504",
        #             "after":"2500650881647616"
        #         }
        #     ]
        #
        # futures, swap
        #
        #     {
        #         "result":true,  # missing in swap orders
        #         "order_info": [
        #             {
        #                 "instrument_id":"EOS-USD-190628",
        #                 "size":"10",
        #                 "timestamp":"2019-03-20T10:04:55.000Z",
        #                 "filled_qty":"10",
        #                 "fee":"-0.00841043",
        #                 "order_id":"2512669605501952",
        #                 "price":"3.668",
        #                 "price_avg":"3.567",
        #                 "status":"2",
        #                 "state": "2",
        #                 "type":"4",
        #                 "contract_val":"10",
        #                 "leverage":"10",  # missing in swap orders
        #                 "client_oid":"",
        #                 "pnl":"1.09510794",  # missing in swap orders
        #                 "order_type":"0"
        #             },
        #         ]
        #     }
        #
        orders = None
        if market['type'] == 'swap' or market['type'] == 'futures':
            orders = self.safe_value(response, 'order_info', [])
        else:
            orders = response
            responseLength = len(response)
            if responseLength < 1:
                return []
            # in fact, self documented API response does not correspond
            # to their actual API response for spot markets
            # OKEX v3 API returns a plain array of orders
            if responseLength > 1:
                before = self.safe_value(response[1], 'before')
                if before is not None:
                    orders = response[0]
        return self.parse_orders(orders, market, since, limit)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        # '-2': failed,
        # '-1': cancelled,
        #  '0': open ,
        #  '1': partially filled,
        #  '2': fully filled,
        #  '3': submitting,
        #  '4': cancelling,
        #  '6': incomplete（open+partially filled),
        #  '7': complete（cancelled+fully filled),
        return self.fetch_orders_by_state('6', symbol, since, limit, params)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        # '-2': failed,
        # '-1': cancelled,
        #  '0': open ,
        #  '1': partially filled,
        #  '2': fully filled,
        #  '3': submitting,
        #  '4': cancelling,
        #  '6': incomplete（open+partially filled),
        #  '7': complete（cancelled+fully filled),
        return self.fetch_orders_by_state('7', symbol, since, limit, params)

    def parse_deposit_addresses(self, addresses):
        result = []
        for i in range(0, len(addresses)):
            result.append(self.parse_deposit_address(addresses[i]))
        return result

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        #         currency: 'eth'
        #         tag: 'abcde12345',  # will be missing if the token does not require a deposit tag
        #         payment_id: 'abcde12345',  # will not be returned if the token does not require a payment_id
        #         # can_deposit: 1,  # 0 or 1, documented but missing
        #         # can_withdraw: 1,  # 0 or 1, documented but missing
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string_2(depositAddress, 'tag', 'payment_id')
        tag = self.safe_string(depositAddress, 'memo', tag)
        currencyId = self.safe_string(depositAddress, 'currency')
        code = self.safe_currency_code(currencyId)
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': depositAddress,
        }

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.accountGetDepositAddress(self.extend(request, params))
        #
        #     [
        #         {
        #             address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        #             currency: 'eth'
        #         }
        #     ]
        #
        addresses = self.parse_deposit_addresses(response)
        numAddresses = len(addresses)
        if numAddresses < 1:
            raise InvalidAddress(self.id + ' fetchDepositAddress cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first')
        return addresses[0]

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        if tag:
            address = address + ':' + tag
        fee = self.safe_string(params, 'fee')
        if fee is None:
            raise ExchangeError(self.id + " withdraw() requires a `fee` string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.")
        request = {
            'currency': currency['id'],
            'to_address': address,
            'destination': '4',  # 2 = OKCoin International, 3 = OKEx 4 = others
            'amount': self.number_to_string(amount),
            'fee': fee,  # String. Network transaction fee ≥ 0. Withdrawals to OKCoin or OKEx are fee-free, please set as 0. Withdrawal to external digital asset address requires network transaction fee.
        }
        if self.password:
            request['trade_pwd'] = self.password
        elif 'password' in params:
            request['trade_pwd'] = params['password']
        elif 'trade_pwd' in params:
            request['trade_pwd'] = params['trade_pwd']
        query = self.omit(params, ['fee', 'password', 'trade_pwd'])
        if not('trade_pwd' in list(request.keys())):
            raise ExchangeError(self.id + ' withdraw() requires self.password set on the exchange instance or a password / trade_pwd parameter')
        response = self.accountPostWithdrawal(self.extend(request, query))
        #
        #     {
        #         "amount":"0.1",
        #         "withdrawal_id":"67485",
        #         "currency":"btc",
        #         "result":true
        #     }
        #
        return {
            'info': response,
            'id': self.safe_string(response, 'withdraw_id'),
        }

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        method = 'accountGetDepositHistory'
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['code'] = currency['code']
            method += 'Currency'
        response = getattr(self, method)(self.extend(request, params))
        return self.parseTransactions(response, currency, since, limit, params)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        method = 'accountGetWithdrawalHistory'
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['code'] = currency['code']
            method += 'Currency'
        response = getattr(self, method)(self.extend(request, params))
        return self.parseTransactions(response, currency, since, limit, params)

    def parse_transaction_status(self, status):
        #
        # deposit statuses
        #
        #     {
        #         '0': 'waiting for confirmation',
        #         '1': 'confirmation account',
        #         '2': 'recharge success'
        #     }
        #
        # withdrawal statues
        #
        #     {
        #        '-3': 'pending cancel',
        #        '-2': 'cancelled',
        #        '-1': 'failed',
        #         '0': 'pending',
        #         '1': 'sending',
        #         '2': 'sent',
        #         '3': 'email confirmation',
        #         '4': 'manual confirmation',
        #         '5': 'awaiting identity confirmation'
        #     }
        #
        statuses = {
            '-3': 'pending',
            '-2': 'pending',
            '-1': 'failed',
            '0': 'pending',
            '1': 'pending',
            '2': 'ok',
            '3': 'pending',
            '4': 'pending',
            '5': 'pending',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # withdraw
        #
        #     {
        #         "amount":"0.1",
        #         "withdrawal_id":"67485",
        #         "currency":"btc",
        #         "result":true
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #         amount: "4.72100000",
        #         withdrawal_id: "1729116",
        #         fee: "0.01000000eth",
        #         txid: "0xf653125bbf090bcfe4b5e8e7b8f586a9d87aa7de94598702758c0802b…",
        #         currency: "ETH",
        #         from: "7147338839",
        #         to: "0x26a3CB49578F07000575405a57888681249c35Fd",
        #         timestamp: "2018-08-17T07:03:42.000Z",
        #         status: "2"
        #     }
        #
        # fetchDeposits
        #
        #     {
        #         amount: "0.47847546",
        #         txid: "1723573_3_0_0_WALLET",
        #         currency: "BTC",
        #         to: "",
        #         timestamp: "2018-08-16T03:41:10.000Z",
        #         status: "2"
        #     }
        #
        type = None
        id = None
        address = None
        withdrawalId = self.safe_string(transaction, 'withdrawal_id')
        addressFrom = self.safe_string(transaction, 'from')
        addressTo = self.safe_string(transaction, 'to')
        if withdrawalId is not None:
            type = 'withdrawal'
            id = withdrawalId
            address = addressTo
        else:
            type = 'deposit'
            address = addressFrom
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId)
        amount = self.safe_float(transaction, 'amount')
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        txid = self.safe_string(transaction, 'txid')
        timestamp = self.parse8601(self.safe_string(transaction, 'timestamp'))
        feeCost = None
        if type == 'deposit':
            feeCost = 0
        else:
            if currencyId is not None:
                feeWithCurrencyId = self.safe_string(transaction, 'fee')
                if feeWithCurrencyId is not None:
                    feeWithoutCurrencyId = feeWithCurrencyId.replace(currencyId, '')
                    feeCost = float(feeWithoutCurrencyId)
        # todo parse tags
        return {
            'info': transaction,
            'id': id,
            'currency': code,
            'amount': amount,
            'addressFrom': addressFrom,
            'addressTo': addressTo,
            'address': address,
            'tag': None,
            'status': status,
            'type': type,
            'updated': None,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrderTrades requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        if (limit is None) or (limit > 100):
            limit = 100
        request = {
            'instrument_id': market['id'],
            'order_id': id,
            # from: '1',  # return the page after the specified page number
            # to: '1',  # return the page before the specified page number
            'limit': limit,  # optional, number of results per request, default = maximum = 100
        }
        defaultType = self.safe_string_2(self.options, 'fetchMyTrades', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        query = self.omit(params, 'type')
        method = type + 'GetFills'
        response = getattr(self, method)(self.extend(request, query))
        #
        # spot trades, margin trades
        #
        #     [
        #         [
        #             {
        #                 "created_at":"2019-03-15T02:52:56.000Z",
        #                 "exec_type":"T",  # whether the order is taker or maker
        #                 "fee":"0.00000082",
        #                 "instrument_id":"BTC-USDT",
        #                 "ledger_id":"3963052721",
        #                 "liquidity":"T",  # whether the order is taker or maker
        #                 "order_id":"2482659399697408",
        #                 "price":"3888.6",
        #                 "product_id":"BTC-USDT",
        #                 "side":"buy",
        #                 "size":"0.00055306",
        #                 "timestamp":"2019-03-15T02:52:56.000Z"
        #             },
        #         ],
        #         {
        #             "before":"3963052722",
        #             "after":"3963052718"
        #         }
        #     ]
        #
        # futures trades, swap trades
        #
        #     [
        #         {
        #             "trade_id":"197429674631450625",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "order_id":"6a-7-54d663a28-0",
        #             "price":"3.633",
        #             "order_qty":"1.0000",
        #             "fee":"-0.000551",
        #             "created_at":"2019-03-21T04:41:58.0Z",  # missing in swap trades
        #             "timestamp":"2019-03-25T05:56:31.287Z",  # missing in futures trades
        #             "exec_type":"M",  # whether the order is taker or maker
        #             "side":"short",  # "buy" in futures trades
        #         }
        #     ]
        #
        trades = None
        if market['type'] == 'swap' or market['type'] == 'futures':
            trades = response
        else:
            responseLength = len(response)
            if responseLength < 1:
                return []
            trades = response[0]
        return self.parse_trades(trades, market, since, limit)

    def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        defaultType = self.safe_string_2(self.options, 'fetchLedger', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        query = self.omit(params, 'type')
        suffix = '' if (type == 'account') else 'Accounts'
        argument = ''
        request = {
            # 'from': 'id',
            # 'to': 'id',
        }
        if limit is not None:
            request['limit'] = limit
        currency = None
        if (type == 'spot') or (type == 'futures'):
            if code is None:
                raise ArgumentsRequired(self.id + " fetchLedger requires a currency code argument for '" + type + "' markets")
            argument = 'Currency'
            currency = self.currency(code)
            request['currency'] = currency['id']
        elif (type == 'margin') or (type == 'swap'):
            if code is None:
                raise ArgumentsRequired(self.id + " fetchLedger requires a code argument(a market symbol) for '" + type + "' markets")
            argument = 'InstrumentId'
            market = self.market(code)  # we intentionally put a market inside here for the margin and swap ledgers
            currency = self.currency(market['base'])
            request['instrument_id'] = market['id']
            #
            #     if type == 'margin':
            #         #
            #         #      3. Borrow
            #         #      4. Repayment
            #         #      5. Interest
            #         #      7. Buy
            #         #      8. Sell
            #         #      9. From capital account
            #         #     10. From C2C
            #         #     11. From Futures
            #         #     12. From Spot
            #         #     13. From ETT
            #         #     14. To capital account
            #         #     15. To C2C
            #         #     16. To Spot
            #         #     17. To Futures
            #         #     18. To ETT
            #         #     19. Mandatory Repayment
            #         #     20. From Piggybank
            #         #     21. To Piggybank
            #         #     22. From Perpetual
            #         #     23. To Perpetual
            #         #     24. Liquidation Fee
            #         #     54. Clawback
            #         #     59. Airdrop Return.
            #         #
            #         request['type'] = 'number'  # All types will be returned if self filed is left blank
            #     }
            #
        elif type == 'account':
            if code is not None:
                currency = self.currency(code)
                request['currency'] = currency['id']
            #
            #     #
            #     #      1. deposit
            #     #      2. withdrawal
            #     #     13. cancel withdrawal
            #     #     18. into futures account
            #     #     19. out of futures account
            #     #     20. into sub account
            #     #     21. out of sub account
            #     #     28. claim
            #     #     29. into ETT account
            #     #     30. out of ETT account
            #     #     31. into C2C account
            #     #     32. out of C2C account
            #     #     33. into margin account
            #     #     34. out of margin account
            #     #     37. into spot account
            #     #     38. out of spot account
            #     #
            #     request['type'] = 'number'
            #
        else:
            raise NotSupported(self.id + " fetchLedger does not support the '" + type + "' type(the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")
        method = type + 'Get' + suffix + argument + 'Ledger'
        response = getattr(self, method)(self.extend(request, query))
        #
        # transfer     funds transfer in/out
        # trade        funds moved as a result of a trade, spot and margin accounts only
        # rebate       fee rebate as per fee schedule, spot and margin accounts only
        # match        open long/open short/close long/close short(futures) or a change in the amount because of trades(swap)
        # fee          fee, futures only
        # settlement   settlement/clawback/settle long/settle short
        # liquidation  force close long/force close short/deliver close long/deliver close short
        # funding      funding fee, swap only
        # margin       a change in the amount after adjusting margin, swap only
        #
        # account
        #
        #     [
        #         {
        #             "amount":0.00051843,
        #             "balance":0.00100941,
        #             "currency":"BTC",
        #             "fee":0,
        #             "ledger_id":8987285,
        #             "timestamp":"2018-10-12T11:01:14.000Z",
        #             "typename":"Get from activity"
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             "timestamp":"2019-03-18T07:08:25.000Z",
        #             "ledger_id":"3995334780",
        #             "created_at":"2019-03-18T07:08:25.000Z",
        #             "currency":"BTC",
        #             "amount":"0.0009985",
        #             "balance":"0.0029955",
        #             "type":"trade",
        #             "details":{
        #                 "instrument_id":"BTC-USDT",
        #                 "order_id":"2500650881647616",
        #                 "product_id":"BTC-USDT"
        #             }
        #         }
        #     ]
        #
        # margin
        #
        #     [
        #         [
        #             {
        #                 "created_at":"2019-03-20T03:45:05.000Z",
        #                 "ledger_id":"78918186",
        #                 "timestamp":"2019-03-20T03:45:05.000Z",
        #                 "currency":"EOS",
        #                 "amount":"0",  # ?
        #                 "balance":"0.59957711",
        #                 "type":"transfer",
        #                 "details":{
        #                     "instrument_id":"EOS-USDT",
        #                     "order_id":"787057",
        #                     "product_id":"EOS-USDT"
        #                 }
        #             }
        #         ],
        #         {
        #             "before":"78965766",
        #             "after":"78918186"
        #         }
        #     ]
        #
        # futures
        #
        #     [
        #         {
        #             "ledger_id":"2508090544914461",
        #             "timestamp":"2019-03-19T14:40:24.000Z",
        #             "amount":"-0.00529521",
        #             "balance":"0",
        #             "currency":"EOS",
        #             "type":"fee",
        #             "details":{
        #                 "order_id":"2506982456445952",
        #                 "instrument_id":"EOS-USD-190628"
        #             }
        #         }
        #     ]
        #
        # swap
        #
        #     [
        #         {
        #             "amount":"0.004742",
        #             "fee":"-0.000551",
        #             "type":"match",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "ledger_id":"197429674941902848",
        #             "timestamp":"2019-03-25T05:56:31.286Z"
        #         },
        #     ]
        #
        entries = response[0] if (type == 'margin') else response
        return self.parse_ledger(entries, currency, since, limit)

    def parse_ledger_entry_type(self, type):
        types = {
            'transfer': 'transfer',  # # funds transfer in/out
            'trade': 'trade',  # funds moved as a result of a trade, spot and margin accounts only
            'rebate': 'rebate',  # fee rebate as per fee schedule, spot and margin accounts only
            'match': 'trade',  # open long/open short/close long/close short(futures) or a change in the amount because of trades(swap)
            'fee': 'fee',  # fee, futures only
            'settlement': 'trade',  # settlement/clawback/settle long/settle short
            'liquidation': 'trade',  # force close long/force close short/deliver close long/deliver close short
            'funding': 'fee',  # funding fee, swap only
            'margin': 'margin',  # a change in the amount after adjusting margin, swap only
        }
        return self.safe_string(types, type, type)

    def parse_ledger_entry(self, item, currency=None):
        #
        #
        # account
        #
        #     {
        #         "amount":0.00051843,
        #         "balance":0.00100941,
        #         "currency":"BTC",
        #         "fee":0,
        #         "ledger_id":8987285,
        #         "timestamp":"2018-10-12T11:01:14.000Z",
        #         "typename":"Get from activity"
        #     }
        #
        # spot
        #
        #     {
        #         "timestamp":"2019-03-18T07:08:25.000Z",
        #         "ledger_id":"3995334780",
        #         "created_at":"2019-03-18T07:08:25.000Z",
        #         "currency":"BTC",
        #         "amount":"0.0009985",
        #         "balance":"0.0029955",
        #         "type":"trade",
        #         "details":{
        #             "instrument_id":"BTC-USDT",
        #             "order_id":"2500650881647616",
        #             "product_id":"BTC-USDT"
        #         }
        #     }
        #
        # margin
        #
        #     {
        #         "created_at":"2019-03-20T03:45:05.000Z",
        #         "ledger_id":"78918186",
        #         "timestamp":"2019-03-20T03:45:05.000Z",
        #         "currency":"EOS",
        #         "amount":"0",  # ?
        #         "balance":"0.59957711",
        #         "type":"transfer",
        #         "details":{
        #             "instrument_id":"EOS-USDT",
        #             "order_id":"787057",
        #             "product_id":"EOS-USDT"
        #         }
        #     }
        #
        # futures
        #
        #     {
        #         "ledger_id":"2508090544914461",
        #         "timestamp":"2019-03-19T14:40:24.000Z",
        #         "amount":"-0.00529521",
        #         "balance":"0",
        #         "currency":"EOS",
        #         "type":"fee",
        #         "details":{
        #             "order_id":"2506982456445952",
        #             "instrument_id":"EOS-USD-190628"
        #         }
        #     }
        #
        # swap
        #
        #     {
        #         "amount":"0.004742",
        #         "fee":"-0.000551",
        #         "type":"match",
        #         "instrument_id":"EOS-USD-SWAP",
        #         "ledger_id":"197429674941902848",
        #         "timestamp":"2019-03-25T05:56:31.286Z"
        #     },
        #
        id = self.safe_string(item, 'ledger_id')
        account = None
        details = self.safe_value(item, 'details', {})
        referenceId = self.safe_string(details, 'order_id')
        referenceAccount = None
        type = self.parse_ledger_entry_type(self.safe_string(item, 'type'))
        code = self.safe_currency_code(self.safe_string(item, 'currency'), currency)
        amount = self.safe_float(item, 'amount')
        timestamp = self.parse8601(self.safe_string(item, 'timestamp'))
        fee = {
            'cost': self.safe_float(item, 'fee'),
            'currency': code,
        }
        before = None
        after = self.safe_float(item, 'balance')
        status = 'ok'
        return {
            'info': item,
            'id': id,
            'account': account,
            'referenceId': referenceId,
            'referenceAccount': referenceAccount,
            'type': type,
            'currency': code,
            'amount': amount,
            'before': before,  # balance before
            'after': after,  # balance after
            'status': status,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': fee,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        request = '/api' + '/' + api + '/' + self.version + '/' + self.implode_params(path, params)
        url = self.urls['api'] + request
        query = self.omit(params, self.extract_params(path))
        type = self.get_path_authentication_type(path)
        if type == 'public':
            if query:
                url += '?' + self.urlencode(query)
        elif type == 'private':
            self.check_required_credentials()
            timestamp = self.iso8601(self.milliseconds())
            headers = {
                'OK-ACCESS-KEY': self.apiKey,
                'OK-ACCESS-PASSPHRASE': self.password,
                'OK-ACCESS-TIMESTAMP': timestamp,
                # 'OK-FROM': '',
                # 'OK-TO': '',
                # 'OK-LIMIT': '',
            }
            auth = timestamp + method + request
            if method == 'GET':
                if query:
                    urlencodedQuery = '?' + self.urlencode(query)
                    url += urlencodedQuery
                    auth += urlencodedQuery
            else:
                if query:
                    body = self.json(query)
                    auth += body
                headers['Content-Type'] = 'application/json'
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            headers['OK-ACCESS-SIGN'] = self.decode(signature)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def get_path_authentication_type(self, path):
        auth = self.safe_value(self.options, 'auth', {})
        key = self.findBroadlyMatchedKey(auth, path)
        return self.safe_string(auth, key, 'private')

    def handle_errors(self, code, reason, url, method, headers, body, response=None):
        feedback = self.id + ' ' + body
        if code == 503:
            raise ExchangeError(feedback)
        exact = self.exceptions['exact']
        message = self.safe_string(response, 'message')
        errorCode = self.safe_string_2(response, 'code', 'error_code')
        if errorCode in exact:
            raise exact[errorCode](feedback)
        if message is not None:
            if message in exact:
                raise exact[message](feedback)
            broad = self.exceptions['broad']
            broadKey = self.findBroadlyMatchedKey(broad, message)
            if broadKey is not None:
                raise broad[broadKey](feedback)
            raise ExchangeError(feedback)  # unknown message
