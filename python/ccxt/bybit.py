# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
import hashlib
import json
import re
from collections import defaultdict

from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import ExchangeError, SameLeverage, OrderCancelled, MaxStopAllowed, PositionNotFound, \
    ExchangeNotAvailable, NotSupported, TradesNotFound
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotChanged
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.exchange import Exchange

PERMISSION_TO_VALUE = {"spot": ["SpotTrade"], "futures": ["Position", "Order"],
                       "withdrawal": ["Withdrawal"]}
NOT_CHANGED_ERROR_CODES = {'30083', '34026', '134026'}
MIN_HEDGE_MODE_COUNT_THRESHOLD = 3


class bybit(Exchange):

    def describe(self):
        return self.deep_extend(super(bybit, self).describe(), {
            'id': 'bybit',
            'name': 'ByBit',
            'countries': ['VG'],  # British Virgin Islands
            'version': 'v2',
            'userAgent': None,
            # 50 requests per second for GET requests, 1000ms / 50 = 20ms between requests
            # 20 requests per second for POST requests, cost = 50 / 20 = 2.5
            'rateLimit': 20,
            'hostname': 'bybit.com',  # bybit.com, bytick.com
            'pro': True,
            'certified': True,
            'has': {
                'cancelOrder': True,
                'CORS': True,
                'cancelAllOrders': True,
                'createOrder': True,
                'editOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchDeposits': True,
                'fetchLedger': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTransactions': False,
                'fetchWithdrawals': True,
            },
            'timeframes': {
                '1m': '1',
                '3m': '3',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '6h': '360',
                '12h': '720',
                '1d': 'D',
                '1w': 'W',
                '1M': 'M',
                '1y': 'Y',
            },
            'urls': {
                'test': {
                    'spot': 'https://api-testnet.{hostname}',
                    'futures': 'https://api-testnet.{hostname}',
                    'v2': 'https://api-testnet.{hostname}',
                    'public': 'https://api-testnet.{hostname}',
                    'private': 'https://api-testnet.{hostname}',
                },
                'logo': 'https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg',
                'api': {
                    'spot': 'https://api.{hostname}',
                    'futures': 'https://api.{hostname}',
                    'v2': 'https://api.{hostname}',
                    'public': 'https://api.{hostname}',
                    'private': 'https://api.{hostname}',
                },
                'www': 'https://www.bybit.com',
                'doc': [
                    'https://bybit-exchange.github.io/docs/inverse/',
                    'https://bybit-exchange.github.io/docs/linear/',
                    'https://github.com/bybit-exchange',
                ],
                'fees': 'https://help.bybit.com/hc/en-us/articles/360039261154',
                'referral': 'https://partner.bybit.com/b/ccxt',
            },
            'api': {
                'public': {
                    'get': [
                        'v2/public/orderBook/L2',
                        'v2/public/kline/list',
                        'v2/public/tickers',
                        'v2/public/trading-records',
                        'v2/public/symbols',
                        'v2/public/time',
                        'v2/public/announcement',
                        'v2/public/risk-limit/list',
                        'v5/market/kline',
                        'spot/v3/public/time',
                        'spot/v3/public/symbols',
                        'spot/v3/public/quote/depth',
                        'spot/v3/public/quote/merged',
                        'spot/v3/public/quote/trades',
                        'spot/v3/public/quote/kline',
                        'spot/v3/public/quote/ticker/24hr',
                        'spot/v3/public/quote/ticker/price',
                        'spot/v3/public/quote/ticker/book_ticker',
                        'public/linear/kline',
                        'public/linear/recent-trading-records',
                        'public/linear/risk-limit',
                        'public/linear/funding/prev-funding-rate',
                        'public/linear/mark-price-kline',
                        'public/linear/index-price-kline',
                        'public/linear/premium-index-kline',
                    ],
                },
                'private': {
                    'get': [
                        'v2/private/order',
                        'v2/private/stop-order',
                        'v2/private/order/list',
                        'v2/private/stop-order/list',
                        'v2/private/position/list',
                        'v2/private/wallet/balance',
                        'v2/private/execution/list',
                        'v2/private/wallet/fund/records',
                        'v2/private/wallet/withdraw/list',
                        'v2/private/account/api-key',
                        'spot/v3/private/account',
                        'spot/v3/private/order',
                        'spot/v3/private/open-orders',
                        'spot/v3/private/history-orders',
                        'spot/v3/private/my-trades',
                        'spot/v3/private/cross-margin/order',
                        'spot/v3/private/cross-margin/accounts/balance',
                        'spot/v3/private/cross-margin/loan-info',
                        'spot/v3/private/cross-margin/repay/history',
                        'private/linear/order/list',
                        'private/linear/order/search',
                        'private/linear/stop-order/list',
                        'private/linear/stop-order/search',
                        'private/linear/position/list',
                        'private/linear/trade/execution/list',
                        'private/linear/trade/closed-pnl/list',
                        'public/linear/risk-limit',
                        'private/linear/funding/predicted-funding',
                        'private/linear/funding/prev-funding',
                    ],
                    'post': [
                        'spot/v3/private/order',
                        'spot/v3/private/cancel-order',
                        'spot/v3/private/cross-margin-loan',
                        'spot/v3/private/cross-margin-repay',
                        'private/linear/order/create',
                        'private/linear/order/cancel',
                        'private/linear/order/cancel-all',
                        'private/linear/order/replace',
                        'private/linear/stop-order/create',
                        'private/linear/stop-order/cancel',
                        'private/linear/stop-order/cancel-all',
                        'private/linear/stop-order/replace',
                        'private/linear/position/set-auto-add-margin',
                        'private/linear/position/switch-isolated',
                        'private/linear/position/switch-mode',
                        'private/linear/tpsl/switch-mode',
                        'private/linear/position/add-margin',
                        'private/linear/position/set-leverage',
                        'private/linear/position/trading-stop',
                        'private/linear/position/set-risk',
                        'v2/private/order/create',
                        'v2/private/order/cancel',
                        'v2/private/order/cancelAll',
                        'v2/private/order/replace',
                        'v2/private/stop-order/create',
                        'v2/private/stop-order/cancel',
                        'v2/private/stop-order/replace',
                        'v2/private/stop-order/cancelAll',
                        'v2/private/position/change-position-margin',
                        'v2/private/position/leverage/save',
                        'v2/private/position/risk-limit',
                    ],
                    'delete': [
                        'spot/v3/private/order',
                        'spot/v3/private/order/fast',
                        'spot/order/batch-cancel',
                        'spot/order/batch-fast-cancel',
                        'spot/order/batch-cancel-by-ids']
                },
                'openapi': {
                    'get': [
                        'wallet/risk-limit/list',
                        'wallet/risk-limit',
                        'funding/prev-funding-rate',
                        'funding/prev-funding',
                        'funding/predicted-funding',
                        'api-key',
                    ],
                    'post': [
                        'position/trading-stop',
                    ],
                }
            },
            'httpExceptions': {
                '403': RateLimitExceeded,  # Forbidden -- You request too many times
            },
            'exceptions': {
                'exact': {
                    '10001': BadRequest,  # parameter error
                    '10002': InvalidNonce,  # request expired, check your timestamp and recv_window
                    '10003': AuthenticationError,  # Invalid apikey
                    '10004': AuthenticationError,  # invalid sign
                    '10005': PermissionDenied,  # permission denied for current apikey
                    '10006': RateLimitExceeded,  # too many requests
                    '10007': AuthenticationError,  # api_key not found in your request parameters
                    '10010': PermissionDenied,  # request ip mismatch
                    '10016': ExchangeNotAvailable,  # Service not available.
                    '10017': BadRequest,  # request path not found or request method is invalid
                    '10018': RateLimitExceeded,  # Exceeded IP rate limit.
                    '10020': NotSupported,  # Request not supported.
                    '10024': AuthenticationError,  # Compliance rules triggered
                    '12168': AuthenticationError,  # To proceed with trading, users must read through and confirm...
                    '20001': OrderNotFound,  # Order not exists
                    '20003': InvalidOrder,  # missing parameter side
                    '20004': InvalidOrder,  # invalid parameter side
                    '20005': InvalidOrder,  # missing parameter symbol
                    '20006': InvalidOrder,  # invalid parameter symbol
                    '20007': InvalidOrder,  # missing parameter order_type
                    '20008': InvalidOrder,  # invalid parameter order_type
                    '20009': InvalidOrder,  # missing parameter qty
                    '20010': InvalidOrder,  # qty must be greater than 0
                    '20011': InvalidOrder,  # qty must be an integer
                    '20012': InvalidOrder,  # qty must be greater than zero and less than 1 million
                    '20013': InvalidOrder,  # missing parameter price
                    '20014': InvalidOrder,  # price must be greater than 0
                    '20015': InvalidOrder,  # missing parameter time_in_force
                    '20016': InvalidOrder,  # invalid value for parameter time_in_force
                    '20017': InvalidOrder,  # missing parameter order_id
                    '20018': InvalidOrder,  # invalid date format
                    '20019': InvalidOrder,  # missing parameter stop_px
                    '20020': InvalidOrder,  # missing parameter base_price
                    '20021': InvalidOrder,  # missing parameter stop_order_id
                    '20022': BadRequest,  # missing parameter leverage
                    '20023': BadRequest,  # leverage must be a number
                    '20031': BadRequest,  # leverage must be greater than zero
                    '20070': BadRequest,  # missing parameter margin
                    '20071': BadRequest,  # margin must be greater than zero
                    '20084': BadRequest,  # order_id or order_link_id is required
                    '30001': BadRequest,  # order_link_id is repeated
                    '30003': InvalidOrder,  # qty must be more than the minimum allowed
                    '30004': InvalidOrder,  # qty must be less than the maximum allowed
                    '30005': InvalidOrder,  # price exceeds maximum allowed
                    '30007': InvalidOrder,  # price exceeds minimum allowed
                    '30008': InvalidOrder,  # invalid order_type
                    '30009': ExchangeError,  # no position found
                    '30010': InsufficientFunds,  # insufficient wallet balance
                    '30011': InvalidOrder,  # operation not allowed as position is undergoing liquidation
                    '30012': InvalidOrder,  # operation not allowed as position is undergoing ADL
                    '30013': InvalidOrder,  # position is in liq or adl status
                    '30014': InvalidOrder,  # invalid closing order, qty should not greater than size
                    '30015': InvalidOrder,  # invalid closing order, side should be opposite
                    '30016': ExchangeError,  # TS and SL must be cancelled first while closing position
                    '30017': InvalidOrder,  # estimated fill price cannot be lower than current Buy liq_price
                    '30018': InvalidOrder,  # estimated fill price cannot be higher than current Sell liq_price
                    '30019': InvalidOrder,  # cannot attach TP/SL params for non-zero position when placing non-opening position order
                    '30020': InvalidOrder,  # position already has TP/SL params
                    '30021': InsufficientFunds,  # cannot afford estimated position_margin
                    '30022': InvalidOrder,  # estimated buy liq_price cannot be higher than current mark_price
                    '30023': InvalidOrder,  # estimated sell liq_price cannot be lower than current mark_price
                    '30024': InvalidOrder,  # cannot set TP/SL/TS for zero-position
                    '30025': InvalidOrder,  # trigger price should bigger than 10% of last price
                    '30026': InvalidOrder,  # price too high
                    '30027': InvalidOrder,  # price set for Take profit should be higher than Last Traded Price
                    '30028': InvalidOrder,  # price set for Stop loss should be between Liquidation price and Last Traded Price
                    '30029': InvalidOrder,  # price set for Stop loss should be between Last Traded Price and Liquidation price
                    '30030': InvalidOrder,  # price set for Take profit should be lower than Last Traded Price
                    '30031': InsufficientFunds,  # insufficient available balance for order cost
                    '30032': OrderNotFound,  # order has been filled or cancelled
                    '30033': MaxStopAllowed,  # The number of stop orders exceeds maximum limit allowed
                    '30034': OrderNotFound,  # no order found
                    '30035': RateLimitExceeded,  # too fast to cancel
                    '30036': ExchangeError,  # the expected position value after order execution exceeds the current risk limit
                    '30037': OrderCancelled,
                    '30041': ExchangeError,  # no position found
                    '30042': InsufficientFunds,  # insufficient wallet balance
                    '30043': ExchangeError,  # operation not allowed as position is undergoing liquidation
                    '30044': ExchangeError,  # operation not allowed as position is undergoing AD
                    '30045': ExchangeError,  # operation not allowed as position is not normal status
                    '30049': InsufficientFunds,  # insufficient available balance
                    '30050': ExchangeError,  # any adjustments made will trigger immediate liquidation
                    '30051': ExchangeError,  # due to risk limit, cannot adjust leverage
                    '30052': ExchangeError,  # leverage can not less than 1
                    '30054': ExchangeError,  # position margin is invalid
                    '30057': InvalidOrder,  # requested quantity of contracts exceeds risk limit
                    '30063': InvalidOrder,  # reduce-only rule not satisfied
                    '30067': InsufficientFunds,  # insufficient available balance
                    '30068': ExchangeError,  # exit value must be positive
                    '31003': PermissionDenied,  # user has been banned
                    '33004': PermissionDenied,  # key expired
                    '34015': SameLeverage,
                    '34026': ExchangeError,  # the limit is no change
                    '34036': SameLeverage,
                    '130001': ExchangeError,  # Not get position
                    '130002': ExchangeError,  # wallet is nil
                    '130003': ExchangeError,  # the pz status is not normal
                    '130004': InvalidOrder,  # Order number is out of permissible range
                    '130005': InvalidOrder,  # Order price is out of permissible range
                    '130006': InvalidOrder,  # order qty is out of permissible range
                    '130007': InvalidOrder,  # Order price is out of permissible range
                    '130008': InvalidOrder,  # order_type invalid
                    '130009': ExchangeError,  # The number of contracts below min limit allowed
                    '130010': OrderNotFound,  # order not exists or Too late to operate
                    '130011': ExchangeError,  # Operation not allowed as position is undergoing liquidation
                    '130012': ExchangeError,  # Operation not allowed as position is undergoing ADL
                    '130013': ExchangeError,  # stop_order trail value invalid
                    '130014': ExchangeError,  # stop_order trigger price invalid
                    '130015': ExchangeError,  # stop_order expected_direction or base_price invalid
                    '130016': ExchangeError,  # invalid stop_order_type, cannot replace price
                    '130017': ExchangeError,  # invalid stop_order_type, cannot replace qty
                    '130018': ExchangeError,  # invalid trail_value
                    '130019': ExchangeError,  # invalid stop_order_type, cannot replace trigger_price
                    '130020': ExchangeError,  # invalid stop_order_type, cannot replace trail_value
                    '130021': InsufficientFunds,  # order cost not available
                    '130024': ExchangeError,  # cannot set tp_sl_ts for zero position
                    '130025': ExchangeError,  # below < 10% of base price
                    '130026': ExchangeError,  # the price is too high
                    '130027': ExchangeError,  # the price set for Buy position should be higher than base_price
                    '130028': ExchangeError,  # the price set for Sell position should be between base_price and liq_price
                    '130029': ExchangeError,  # the price set for Buy position should be between liq_price and base_price
                    '130030': ExchangeError,  # the price set for Sell position should be lower than base_price
                    '130032': ExchangeError,  # invalid order_status, cannot cancel or execute trigger
                    '130033': MaxStopAllowed,  # number of stop order >= 10
                    '130034': ExchangeError,  # stop_order cannot replace
                    '130035': ExchangeError,  # Too freq to cancel, Try it later
                    '130037': ExchangeError,  # Order already cancelled
                    '130040': ExchangeError,  # position will be liq
                    '130041': ExchangeError,  # AvailableBalanceE8 less than 0
                    '130049': InsufficientFunds,  # available balance not enough
                    '130050': ExchangeError,  # Any adjustments made will trigger liq
                    '130051': ExchangeError,  # cannot set leverage ,due to risk limit,
                    '130052': ExchangeError,  # cannot set leverage , below the lower limit
                    '130056': ExchangeError,  # the position is in cross_margin
                    '130057': ExchangeError,  # the position size is 0
                    '130058': ExchangeError,  # can not set margin less than minPositionCost
                    '130059': ExchangeError,  # can not set pz open limit more than symbol limit
                    '130060': ExchangeError,  # autoAddMargin not changed
                    '130061': ExchangeError,  # not change feeï¼Œinvalid req
                    '130062': ExchangeError,  # can not set pz open limit less than current buy pz value
                    '130063': ExchangeError,  # can not set pz open limit less than current sell pz value
                    '130064': ExchangeError,  # just support usdt
                    '130074': ExchangeError,  # expect Rising, trigger_price <= current
                    '130075': ExchangeError,  # expect Falling, trigger_price >= current
                    '130076': ExchangeError,  # replace params invalid
                    '130077': ExchangeError,  # the deposit req has handled
                    '130078': ExchangeError,  # the withdraw req has handled
                    '130079': ExchangeError,  # the rotate req has handled
                    '130101': ExchangeError,  # unknown request for create order
                    '130102': ExchangeError,  # unknown request for cancel order
                    '130103': ExchangeError,  # unknown request for cancelAll
                    '130104': ExchangeError,  # unknown request for LiqExecuteReq, req param not match liqExecuteReq
                    '130105': ExchangeError,  # unknown request for pre create order
                    '130106': ExchangeError,  # unknown req for query order
                    '130107': ExchangeError,  # unmatch request for triggeredToActiveImpl
                    '130108': ExchangeError,  # unknown request for addMargin
                    '130109': ExchangeError,  # unknown request for calculatePositionPnl
                    '130110': ExchangeError,  # unknown request for qryAssetImpl
                    '130111': ExchangeError,  # unknown request for query_position_list
                    '130112': ExchangeError,  # unknown request for setAutoAddMargin
                    '130113': ExchangeError,  # unknown request for setFeeRate
                    '130114': ExchangeError,  # unknown request for setLeverage
                    '130115': ExchangeError,  # unknown request for setMargin
                    '130116': ExchangeError,  # unknown request for setOpenLimit
                    '130117': ExchangeError,  # unknown request for setTpSlTs
                    '130118': ExchangeError,  # unknown request for settleFundingFeeReq
                    '130119': ExchangeError,  # unknown request for setPositionMode
                    '130120': ExchangeError,  # unknown request for walletDeposit
                    '130121': ExchangeError,  # unknown request for walletWithDraw
                    '130122': ExchangeError,  # unknown request for rotateRealisedPnl
                    '130123': ExchangeError,  # unknown request for AdlExecute
                    '130124': ExchangeError,  # unknown request for AdlCleanReq
                    '130125': ExchangeError,  # No change made for TP/SL price
                    '130126': ExchangeError,  # No orders
                    '130023': ExchangeError,  # Will be triggered Liq after order is completed
                    '130127': ExchangeError,  # Take Profit, Stop Loss and Trailing Stop Loss are not modified
                    '130134': SameLeverage,
                    '130149': ExchangeError,  # Order creation successful but SL/TP setting failed
                    '130150': RateLimitExceeded,  # Please try again later.
                    '130151': ExchangeError,  # Switching failed. Please cancel the current SL/TP setting
                    '130152': ExchangeError,  # Switching failed. Please cancel the current SL/TP setting
                    '130153': ExchangeError,  # Switching failed. Please cancel the current SL/TP setting
                    '130154': ExchangeError,  # Switching failed. Please cancel the SL/TP setting of active orders
                    '130155': ExchangeError,  # Insufficient quantity required to set TP/SL
                    '130156': ExchangeError,  # Replacing active order price and qty simultaneously is not allowed
                    '130157': ExchangeError,  # Amendment failed. SL/TP price cannot be amended as order is partially filled
                    '130158': ExchangeError,  # SL/TP price cannot be amended under 'Full' position mode
                    '130159': ExchangeError,  # Max SL/TP orders under 'Partial' mode is 20
                },
                'broad': {
                    'unknown orderInfo': OrderNotFound,  # {"ret_code":-1,"ret_msg":"unknown orderInfo","ext_code":"","ext_info":"","result":null,"time_now":"1584030414.005545","rate_limit_status":99,"rate_limit_reset_ms":1584030414003,"rate_limit":100}
                },
            },
            'precisionMode': TICK_SIZE,
            'options': {
                'defaultType': None,  # 'inverse', 'linear', 'spot', None
                'marketTypes': {
                    'BTC/USDT': 'linear',
                },
                'code': 'BTC',
                'fetchBalance': {
                    'code': 'BTC',
                },
                'cancelAllOrders': {
                    'method': 'privatePostV2PrivateOrderCancelAll',  # privatePostV2PrivateStopOrderCancelAll
                },
                'recvWindow': 5 * 1000,  # 5 sec default
                'timeDifference': 0,  # the difference between system clock and Binance clock
                'adjustForTimeDifference': False,  # controls the adjustment logic upon instantiation
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': 0.00075,
                    'maker': -0.00025,
                },
                'funding': {
                    'tierBased': False,
                    'percentage': False,
                    'withdraw': {},
                    'deposit': {},
                },
            },
        })

    def nonce(self):
        return self.milliseconds() - self.options['timeDifference']

    def load_time_difference(self, params={}):
        serverTime = self.fetch_time(params)
        after = self.milliseconds()
        self.options['timeDifference'] = after - serverTime
        return self.options['timeDifference']

    def fetch_time(self, params={}):
        response = self.publicGetV2PublicTime(params)
        #
        #     {
        #         ret_code: 0,
        #         ret_msg: 'OK',
        #         ext_code: '',
        #         ext_info: '',
        #         result: {},
        #         time_now: '1583933682.448826'
        #     }
        #
        return self.safe_timestamp(response, 'time_now')

    def is_inverse(self):
        default_type = self.safe_string(self.options, 'defaultType')
        return default_type == "inverse"
    
    def is_linear(self):
        default_type = self.safe_string(self.options, 'defaultType')
        return default_type == "linear"

    def is_spot(self):
        default_type = self.safe_string(self.options, 'defaultType')
        return default_type == "spot"

    def _change_margin_type(self, symbol, _id, is_isolated, long_leverage, short_leverage):
        try:
            return self.privatePostPrivateLinearPositionSwitchIsolated(
                {"symbol": _id, "is_isolated": is_isolated, "buy_leverage": long_leverage,
                 "sell_leverage": short_leverage})
        except Exception as e:
            args = e.args
            if args:
                if re.search('\"ret_code\":\s?130056', e.args[0]):
                    raise SameLeverage(args[0])
                elif re.search('\"ret_code\":\s?130129', e.args[0]):
                    self.set_leverage(symbol, long_leverage=long_leverage, short_leverage=short_leverage)
            raise e

    def get_change_margin_input(self, positions, is_cross, leverage, is_long):
        long_leverage = short_leverage = leverage
        if is_long is not None:
            for position in positions:
                _is_long = position["is_long"]
                _leverage = position["leverage"]
                _is_cross = position["margin_type"] == "cross"
                _maintenance_margin = position["maintenance_margin"]
                if is_long != _is_long:
                    if _is_long:
                        long_leverage = _leverage
                    else:
                        short_leverage = _leverage
        long_leverage, short_leverage = self.is_int_format(long_leverage), self.is_int_format(short_leverage)
        return long_leverage, short_leverage

    def change_position_mode(self, is_hedge_mode, symbol=None, pair=None):
        _type = self.safe_string(self.options, 'defaultType')
        try:
            if _type == "linear":
                self.load_markets()
                mode = "BothSide" if is_hedge_mode else "MergedSingle"
                data = {'mode': mode}
                if symbol:
                    symbol = self.find_symbol(symbol)
                    _id = self.market(symbol)["id"]
                    data["symbol"] = _id
                elif pair:
                    data["coin"] = pair
                response = self.privatePostPrivateLinearPositionSwitchMode(data)
                return_message = self.safe_string(response, "ret_msg")
                if return_message and return_message.lower().startswith("partial symbols switched"):
                    feedback = self.id + ' ' + json.dumps(response)
                    raise ExchangeError(feedback)
            else:
                raise NotSupported()
        except NotChanged:
            pass

    def count_position_modes_usages(self, positions):
        open_positions_mode_count = {"BothSide": 0, "MergedSingle": 0}
        all_symbols_mode_count = {"BothSide": 0, "MergedSingle": 0}
        for _position in positions:
            position = self.safe_value(_position, "data", _position)
            if position:
                mode = self.safe_string(position, "mode")
                if self.safe_integer(position, "size", 0):
                    open_positions_mode_count[mode] += 1
                all_symbols_mode_count[mode] += 1
        return open_positions_mode_count, all_symbols_mode_count

    def get_position_mode(self):
        _type = self.safe_string(self.options, 'defaultType')
        if _type == "linear":
            self.load_markets()
            response = self.privateGetPrivateLinearPositionList()
            positions = self.safe_value(response, 'result')
            open_positions_mode_count, all_symbols_mode_count = self.count_position_modes_usages(positions)
            if open_positions_mode_count["BothSide"] == open_positions_mode_count["MergedSingle"]:
                return all_symbols_mode_count["BothSide"] > MIN_HEDGE_MODE_COUNT_THRESHOLD
            return open_positions_mode_count["BothSide"] > open_positions_mode_count["MergedSingle"]
        else:
            raise NotSupported()

    @staticmethod
    def get_same_direction_position(positions, is_long):
        for position in positions:
            _is_long = position["is_long"]
            if is_long == _is_long or _is_long is None:
                return position

    def classify_change_margin(self, symbol, _id, is_long, is_cross, leverage):
        positions = self.get_positions(symbol)
        same_direction_position = self.get_same_direction_position(positions, is_long)
        if same_direction_position is None:
            raise PositionNotFound(f"Couldn't find position for symbol: {symbol} is_long: {is_long}")

        _is_long = same_direction_position["is_long"]
        _leverage = same_direction_position["leverage"]
        _is_cross = same_direction_position["margin_type"] == "cross"
        long_leverage, short_leverage = self.get_change_margin_input(positions, is_cross, leverage, _is_long)

        if is_cross == _is_cross and (leverage == _leverage):
            return
        elif is_cross != _is_cross:
            return self._change_margin_type(symbol, _id, not is_cross, long_leverage, short_leverage)
        else:
            return self.set_leverage(symbol, long_leverage=long_leverage, short_leverage=short_leverage)

    def change_margin_type(self, symbol, is_cross, leverage, is_long):
        leverage = self.validate_float(leverage)
        assert is_cross is not None and leverage is not None and is_long is not None
        self.load_markets()
        symbol = self.find_symbol(symbol)
        _id = self.find_market(symbol)["id"]
        return self.classify_change_margin(symbol, _id, is_long, is_cross, leverage)

    def set_leverage(self, symbol, leverage=None, long_leverage=None, short_leverage=None):
        leverage = self.validate_float(leverage)
        long_leverage = self.validate_float(long_leverage)
        short_leverage = self.validate_float(short_leverage)
        assert leverage is not None or (long_leverage is not None and short_leverage is not None)
        self.load_markets()
        symbol = self.find_symbol(symbol)
        _id = self.market(symbol)["id"]
        method = 'privatePostPrivateLinearPositionSetLeverage' \
            if self.is_linear() else 'privatePostV2PrivatePositionLeverageSave'
        params = {"symbol": _id}
        if self.is_linear():
            params["buy_leverage"] = self.is_int_format(long_leverage)
            params["sell_leverage"] = self.is_int_format(short_leverage)
        else:
            params["leverage"] = self.is_int_format(leverage)

        try:
            return getattr(self, method)(params)
        except Exception as e:
            args = e.args
            if args and re.search('\"ret_code\":\s?(?:30052|130129)', e.args[0]) and leverage == 0:
                raise SameLeverage(args[0])
            raise e

    def get_position_side(self, position):
        side = self.safe_string(position, 'side')
        if side is not None:
            if side == 'Buy':
                side = 'long'
            elif side == 'Sell':
                side = 'short'
            else:
                side = None
        return side

    def get_positions(self, symbol=None):
        self.load_markets()
        if symbol:
            method = 'privateGetPrivateLinearPositionList' if self.is_linear() else 'privateGetV2PrivatePositionList'
            response = getattr(self, method)({"symbol": self.market_id(symbol)})
            positions = self.safe_value(response, 'result')
            positions = positions if type(positions) is list else [positions]
        else:
            positions = list()
            if self.is_linear():
                response = getattr(self, 'privateGetPrivateLinearPositionList')()
                linear_positions = self.safe_value(response, 'result')
                positions.extend(linear_positions)
            if self.is_inverse():
                response = getattr(self, 'privateGetV2PrivatePositionList')()
                inverse_positions = self.safe_value(response, 'result')
                positions.extend(inverse_positions)

        positions_to_return = list()
        for _position in positions:
            position = self.safe_value(_position, "data", _position)
            if position:
                liq_price = self.safe_float(position, "liq_price", 0)
                size = self.safe_float(position, "size")
                if size is not None:
                    market = self.find_market(position["symbol"])
                    if type(market) is dict:
                        _symbol = market["symbol"]
                        side = position.get("side", "buy").lower()
                        if side == "sell":
                            size = -size
                        leverage = self.safe_float(position, "leverage")
                        if self.is_linear():
                            maintenance_margin = self.safe_float(position, "position_value") / leverage
                        else:
                            maintenance_margin = self.safe_float(position, "position_margin")
                        is_isolated = self.safe_value(position, "is_isolated")
                        if not self.is_linear() and is_isolated is False:
                            leverage = 0
                        margin_type = "isolated" if is_isolated else "cross"
                        risk_id = self.safe_integer(position, "risk_id")
                        result = {"info": position, "symbol": _symbol,
                                  "quantity": size, "leverage": leverage, "margin_type": margin_type,
                                  "maintenance_margin": maintenance_margin,
                                  "liquidation_price": max(liq_price, 0),
                                  "is_long": None if side == "none" else side == "buy",
                                  "risk_id": risk_id, "side": self.get_position_side(position)}
                        positions_to_return.append(result)
        return positions_to_return

    def fetch_spot_markets(self, params):
        response = self.publicGetSpotV3PublicSymbols(params)
        #
        #     {
        #         "ret_code":0,
        #         "ret_msg":"",
        #         "ext_code":null,
        #         "ext_info":null,
        #         "result":[
        #             {
        #                 "name":"BTCUSDT",
        #                 "alias":"BTCUSDT",
        #                 "baseCurrency":"BTC",
        #                 "quoteCurrency":"USDT",
        #                 "basePrecision":"0.000001",
        #                 "quotePrecision":"0.00000001",
        #                 "minTradeQuantity":"0.000158",
        #                 "minTradeAmount":"10",
        #                 "maxTradeQuantity":"4",
        #                 "maxTradeAmount":"100000",
        #                 "minPricePrecision":"0.01",
        #                 "category":1,
        #                 "showStatus":true
        #             },
        #         ]
        #     }
        markets_dict = self.safe_value(response, 'result', dict())
        markets = self.safe_value(markets_dict, "list", list())
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            _id = self.safe_string(market, 'name')
            base_id = self.safe_string(market, 'baseCoin')
            quote_id = self.safe_string(market, 'quoteCoin')
            base = self.safe_currency_code(base_id)
            quote = self.safe_currency_code(quote_id)
            symbol = base + '/' + quote
            active = self.safe_value(market, 'showStatus')
            quote_precision = self.safe_number(market, 'quotePrecision')
            result.append({
                'id': _id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': base_id,
                'quoteId': quote_id,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': None,
                'swap': False,
                'future': False,
                'option': False,
                'active': active,
                'contract': False,
                'linear': None,
                'inverse': None,
                'taker': 0.001,
                'maker': 0.001,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': self.safe_number(market, 'basePrecision'),
                    'price': self.safe_number(market, 'minPricePrecision', quote_precision),
                },
                'limits': {
                    'leverage': {
                        'min': 1.,
                        'max': None,
                    },
                    'amount': {
                        'min': self.safe_number(market, 'minTradeQty'),
                        'max': self.safe_number(market, 'maxTradeQty'),
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': self.safe_number(market, 'minTradeAmt'),
                        'max': self.safe_number(market, 'maxTradeAmt'),
                    },
                    'orders': {
                        'max': 500
                    },
                    'conditional_orders': {
                        'max': 10
                    },
                },
                'info': market,
            })
        return result

    def get_symbol_id_to_risk_limits(self):
        risk_limits = self.get_risk_limits()
        symbol_id_to_risk_limits = defaultdict(list)
        for risk_limit in risk_limits:
            symbol_id = self.safe_string(risk_limit, "symbol")
            symbol_id_to_risk_limits[symbol_id].append(risk_limit)
        return symbol_id_to_risk_limits

    def get_unified_risk_limits_for_symbol(self, symbol_id_to_risk_limits, _id):
        risk_limits = self.safe_value(symbol_id_to_risk_limits, _id, list())
        unified_risk_limits = list()
        for risk_limit in risk_limits:
            limit = self.safe_float(risk_limit, "limit")
            max_leverage = self.safe_float(risk_limit, "max_leverage")
            risk_id = self.safe_integer(risk_limit, "id")
            unified_risk_limits.append({"id": risk_id, "limit": limit, "max_leverage": max_leverage})
        return sorted(unified_risk_limits, key=lambda risk_limit_dict: risk_limit_dict["limit"])

    def fetch_contract_markets(self, params={}):
        response = self.publicGetV2PublicSymbols(params)
        #
        #     {
        #         ret_code: 0,
        #         ret_msg: 'OK',
        #         ext_code: '',
        #         ext_info: '',
        #         result: [
        #             {
        #                 name: 'BTCUSD',
        #                 base_currency: 'BTC',
        #                 quote_currency: 'USD',
        #                 price_scale: 2,
        #                 taker_fee: '0.00075',
        #                 maker_fee: '-0.00025',
        #                 leverage_filter: {min_leverage: 1, max_leverage: 100, leverage_step: '0.01'},
        #                 price_filter: {min_price: '0.5', max_price: '999999.5', tick_size: '0.5'},
        #                 lot_size_filter: {max_trading_qty: 1000000, min_trading_qty: 1, qty_step: 1}
        #             },
        #         ],
        #         time_now: '1583930495.454196'
        #     }
        #
        is_linear_client = self.is_linear()
        is_inverse_client = self.is_inverse()
        symbol_id_to_risk_limits = self.get_symbol_id_to_risk_limits()
        markets = self.safe_value(response, 'result', [])
        options = self.safe_value(self.options, 'fetchMarkets', {})
        linearQuoteCurrencies = self.safe_value(options, 'linear', {'USDT': True})
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'name')
            baseId = self.safe_string(market, 'base_currency')
            quoteId = self.safe_string(market, 'quote_currency')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            linear = (quote in linearQuoteCurrencies)
            inverse = not linear
            if (is_inverse_client and linear) or (is_linear_client and inverse):
                continue
            symbol = base + '/' + quote
            baseQuote = base + quote
            if baseQuote != id:
                symbol = id
            lotSizeFilter = self.safe_value(market, 'lot_size_filter', {})
            priceFilter = self.safe_value(market, 'price_filter', {})
            precision = {
                'amount': self.safe_float(lotSizeFilter, 'qty_step'),
                'price': self.safe_float(priceFilter, 'tick_size'),
            }
            risk_limits = self.get_unified_risk_limits_for_symbol(symbol_id_to_risk_limits, id)

            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': True,
                'precision': precision,
                'taker': self.safe_float(market, 'taker_fee'),
                'maker': self.safe_float(market, 'maker_fee'),
                'type': 'future',
                'spot': False,
                'future': True,
                'option': False,
                'linear': linear,
                'inverse': inverse,
                'limits': {
                    'amount': {
                        'min': self.safe_float(lotSizeFilter, 'min_trading_qty'),
                        'max': self.safe_float(lotSizeFilter, 'max_trading_qty'),
                    },
                    'price': {
                        'min': self.safe_float(priceFilter, 'min_price'),
                        'max': self.safe_float(priceFilter, 'max_price'),
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'orders': {
                        'max': 500
                    },
                    'conditional_orders': {
                        'max': 10
                    },
                    'risk': risk_limits
                },
                'info': market,
            })
        return result

    def fetch_markets(self, params={}):
        if self.options['adjustForTimeDifference']:
            self.load_time_difference()
        if self.is_linear() or self.is_inverse():
            return self.fetch_contract_markets(params)
        elif self.is_spot():
            return self.fetch_spot_markets(params)
        else:
            raise NotImplementedError

    def parse_balance(self, response):
        result = {
            'info': response,
        }
        data = self.safe_value(response, 'result', {})
        balances = self.safe_value(data, 'balances')
        if self.is_spot():
            for i in range(0, len(balances)):
                balance = balances[i]
                currencyId = self.safe_string(balance, 'coin')
                code = self.safe_currency_code(currencyId)
                account = self.account()
                account['free'] = self.safe_string(balance, 'availableBalance')
                account['used'] = self.safe_string(balance, 'locked')
                account['total'] = self.safe_string(balance, 'total')
                result[code] = account
        elif self.is_linear() or self.is_inverse():
            currencyIds = list(data.keys())
            linearQuoteCurrencies = self.safe_value(self.options, 'linear', {'USDT': True})
            is_linear_client = self.is_linear()
            is_inverse_client = self.is_inverse()
            for i in range(0, len(currencyIds)):
                currencyId = currencyIds[i]
                balance = data[currencyId]
                code = self.safe_currency_code(currencyId)
                linear = (code in linearQuoteCurrencies)
                inverse = not linear
                if (is_inverse_client and linear) or (is_linear_client and inverse):
                    continue
                account = self.account()
                account['free'] = self.safe_string(balance, 'available_balance')
                account['total'] = self.safe_string(balance, 'wallet_balance')
                result[code] = account
        else:
            raise NotImplementedError
        return self.safe_balance(result)

    def fetch_balance(self, params={}):
        self.load_markets()
        request = {}
        if self.is_spot():
            response = self.privateGetSpotV3PrivateAccount(self.extend(request, params))
        else:
            response = self.privateGetV2PrivateWalletBalance(self.extend(request, params))
        return self.parse_balance(response)

    def parse_ticker(self, ticker, market=None):
        #
        # fetchTicker
        #
        #     {
        #         symbol: 'BTCUSD',
        #         bid_price: '7680',
        #         ask_price: '7680.5',
        #         last_price: '7680.00',
        #         last_tick_direction: 'MinusTick',
        #         prev_price_24h: '7870.50',
        #         price_24h_pcnt: '-0.024204',
        #         high_price_24h: '8035.00',
        #         low_price_24h: '7671.00',
        #         prev_price_1h: '7780.00',
        #         price_1h_pcnt: '-0.012853',
        #         mark_price: '7683.27',
        #         index_price: '7682.74',
        #         open_interest: 188829147,
        #         open_value: '23670.06',
        #         total_turnover: '25744224.90',
        #         turnover_24h: '102997.83',
        #         total_volume: 225448878806,
        #         volume_24h: 809919408,
        #         funding_rate: '0.0001',
        #         predicted_funding_rate: '0.0001',
        #         next_funding_time: '2020-03-12T00:00:00Z',
        #         countdown_hour: 7
        #     }
        #
        timestamp = self.safe_integer(ticker, 't')
        marketId = self.safe_string_2(ticker, 'symbol', 's')
        symbol = None
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        if market is not None:
            symbol = market['symbol']
        last = self.safe_float_2(ticker, 'last_price', 'lp')
        open = self.safe_float_2(ticker, 'prev_price_24h', 'o')
        percentage = self.safe_float_2(ticker, 'price_24h_pcnt', 'change24h')
        if percentage is not None:
            percentage *= 100
        change = None
        average = None
        if (last is not None) and (open is not None):
            change = last - open
            average = self.sum(open, last) / 2
        base_volume = quote_volume = 0.
        if self.is_inverse():
            base_volume = self.safe_float(ticker, "turnover_24h")
            quote_volume = self.safe_float(ticker, "volume_24h")
        elif self.is_linear():
            base_volume = self.safe_float(ticker, "volume_24h")
            quote_volume = self.safe_float(ticker, "turnover_24h")
        elif self.is_spot():
            base_volume = self.safe_float(ticker, 'v')
            quote_volume = self.safe_float(ticker, 'qv')
        vwap = None
        if quote_volume is not None and base_volume is not None:
            vwap = quote_volume / base_volume if base_volume else 0.
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float_2(ticker, 'high_price_24h', 'h'),
            'low': self.safe_float_2(ticker, 'low_price_24h', 'l'),
            'bid': self.safe_float_2(ticker, 'bid_price', 'bp'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'ask_price', 'ap'),
            'askVolume': None,
            'vwap': vwap,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': base_volume,
            'quoteVolume': quote_volume,
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if self.is_spot():
            response = self.publicGetSpotV3PublicQuoteTicker24hr(self.extend(request, params))
        else:
            response = self.publicGetV2PublicTickers(self.extend(request, params))

        result = self.safe_value(response, 'result', [])
        result = self.safe_value(result, 'list', result)
        first = self.safe_value(result, 0)
        timestamp = self.safe_timestamp(response, 'time_now')
        ticker = self.parse_ticker(first, market)
        ticker['timestamp'] = timestamp
        ticker['datetime'] = self.iso8601(timestamp)
        return ticker

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        if self.is_spot():
            response = self.publicGetSpotV3PublicQuoteTicker24hr(params)
        else:
            response = self.publicGetV2PublicTickers(params)

        result = self.safe_value(response, 'result', [])
        result = self.safe_value(result, 'list', result)
        tickers = {}
        for i in range(0, len(result)):
            ticker = self.parse_ticker(result[i])
            symbol = ticker['symbol']
            tickers[symbol] = ticker
        return self.filter_by_array(tickers, 'symbol', symbols)

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     [
        #         "1621162800",
        #         "49592.43",
        #         "49644.91",
        #         "49342.37",
        #         "49349.42",
        #         "1451.59",
        #         "2.4343353100000003"
        #     ]
        #
        return [
            self.safe_integer(ohlcv, 0),
            self.safe_number(ohlcv, 1),
            self.safe_number(ohlcv, 2),
            self.safe_number(ohlcv, 3),
            self.safe_number(ohlcv, 4),
            self.safe_number(ohlcv, 5),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'interval': self.timeframes[timeframe],
        }
        duration = self.parse_timeframe(timeframe)
        now = self.seconds()
        if since is None:
            if limit:
                request['start'] = now - limit * duration
        else:
            request['start'] = int(since)
        if limit is not None:
            request['limit'] = limit  # max 200, default 200

        method = 'publicGetV5MarketKline'
        if self.is_spot():
            request['category'] = 'spot'
        elif self.is_linear():
            request['category'] = 'linear'
        elif self.is_inverse():
            request['category'] = 'inverse'
        else:
            raise NotSupported(self.id + ' fetchOHLCV() is not supported for option markets')
        response = getattr(self, method)(self.extend(request, params))
        #
        # inverse perpetual BTC/USD
        #
        #     {
        #         ret_code: 0,
        #         ret_msg: 'OK',
        #         ext_code: '',
        #         ext_info: '',
        #         result: [
        #             {
        #                 symbol: 'BTCUSD',
        #                 interval: '1',
        #                 open_time: 1583952540,
        #                 open: '7760.5',
        #                 high: '7764',
        #                 low: '7757',
        #                 close: '7763.5',
        #                 volume: '1259766',
        #                 turnover: '162.32773718999994'
        #             },
        #         ],
        #         time_now: '1583953082.397330'
        #     }
        #
        # linear perpetual BTC/USDT
        #
        #     {
        #         "ret_code":0,
        #         "ret_msg":"OK",
        #         "ext_code":"",
        #         "ext_info":"",
        #         "result":[
        #             {
        #                 "id":143536,
        #                 "symbol":"BTCUSDT",
        #                 "period":"15",
        #                 "start_at":1587883500,
        #                 "volume":1.035,
        #                 "open":7540.5,
        #                 "high":7541,
        #                 "low":7540.5,
        #                 "close":7541
        #             }
        #         ],
        #         "time_now":"1587884120.168077"
        #     }
        #
        result = self.safe_value(response, 'result', {})
        ohlcvs = self.safe_value(result, 'list', [])
        return self.parse_ohlcvs(ohlcvs, market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        _id = self.safe_string_2(trade, 'id', 'exec_id')
        symbol = None
        base = None
        marketId = self.safe_string(trade, 'symbol')
        amount = self.safe_float_n(trade, ['qty', 'exec_qty', 'orderQty'])
        cost = self.safe_float(trade, 'exec_value')
        price = self.safe_float_n(trade, ['exec_price', 'price', 'orderPrice'])
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
            symbol = market['symbol']
            base = market['base']
        if market is not None:
            if symbol is None:
                symbol = market['symbol']
                base = market['base']
        if cost is None:
            if amount is not None:
                if price is not None:
                    cost = amount * price
        timestamp = self.parse8601(self.safe_string(trade, 'time'))
        if timestamp is None:
            timestamp = self.safe_integer_n(trade, ['trade_time_ms', 'time', 'creatTime', 'createTime'])
        side = self.safe_string_lower(trade, 'side')
        if side is None:
            is_buyer = self.safe_value(trade, 'isBuyer')
            if is_buyer is not None:
                side = 'buy' if is_buyer else 'sell'
        is_maker = self.safe_float(trade, 'isMaker')
        if is_maker is not None:
            taker_or_maker = 'maker' if is_maker else 'taker'
        else:
            last_liquidity_ind = self.safe_string(trade, 'last_liquidity_ind')
            taker_or_maker = 'maker' if (last_liquidity_ind == 'AddedLiquidity') else 'taker'
        fee_cost = self.safe_float_n(trade, ['exec_fee', 'commission', 'execFee'])
        fee = None
        if fee_cost is not None:
            if market['spot']:
                fee_currency_code = self.safe_string_2(trade, 'commissionAsset', 'feeTokenId')
            else:
                fee_currency_code = market['base'] if market['inverse'] else market['quote']
            fee = {
                'cost': fee_cost,
                'currency': fee_currency_code,
                'rate': self.safe_string(trade, 'fee_rate'),
            }
        return {
            'id': _id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': self.safe_string_2(trade, 'order_id', 'orderId'),
            'type': self.safe_string_lower(trade, 'order_type'),
            'side': side,
            'takerOrMaker': taker_or_maker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            # 'from': 123,  # from id
        }
        if limit is not None:
            request['count'] = limit  # default 500, max 1000
        if self.is_linear():
            method = 'publicGetPublicLinearRecentTradingRecords'
        elif self.is_inverse():
            method = 'publicGetV2PublicTradingRecords'
        elif self.is_spot():
            method = 'publicGetSpotV3PublicQuoteTrades'
        else:
            raise NotImplementedError

        response = getattr(self, method)(self.extend(request, params))
        #
        #     {
        #         ret_code: 0,
        #         ret_msg: 'OK',
        #         ext_code: '',
        #         ext_info: '',
        #         result: [
        #             {
        #                 id: 43785688,
        #                 symbol: 'BTCUSD',
        #                 price: 7786,
        #                 qty: 67,
        #                 side: 'Sell',
        #                 time: '2020-03-11T19:18:30.123Z'
        #             },
        #         ],
        #         time_now: '1583954313.393362'
        #     }
        #
        trades = self.safe_value(response, 'result', {})
        if not isinstance(trades, list):
            trades = self.safe_value_2(trades, 'dataList', 'list', [])
        return self.parse_trades(trades, market, since, limit)

    def parse_order_book(self, orderbook, timestamp=None, bidsKey='Buy', asksKey='Sell', priceKey='price', amountKey='size'):
        bids = []
        asks = []
        for i in range(0, len(orderbook)):
            bidask = orderbook[i]
            side = self.safe_string(bidask, 'side')
            if side == 'Buy':
                bids.append(self.parse_bid_ask(bidask, priceKey, amountKey))
            elif side == 'Sell':
                asks.append(self.parse_bid_ask(bidask, priceKey, amountKey))
            else:
                raise ExchangeError(self.id + ' parseOrderBook encountered an unrecognized bidask format: ' + self.json(bidask))
        return {
            'bids': self.sort_by(bids, 0, True),
            'asks': self.sort_by(asks, 0),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'nonce': None,
        }

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = self.publicGetV2PublicOrderBookL2(self.extend(request, params))
        #
        #     {
        #         ret_code: 0,
        #         ret_msg: 'OK',
        #         ext_code: '',
        #         ext_info: '',
        #         result: [
        #             {symbol: 'BTCUSD', price: '7767.5', size: 677956, side: 'Buy'},
        #             {symbol: 'BTCUSD', price: '7767', size: 580690, side: 'Buy'},
        #             {symbol: 'BTCUSD', price: '7766.5', size: 475252, side: 'Buy'},
        #             {symbol: 'BTCUSD', price: '7768', size: 330847, side: 'Sell'},
        #             {symbol: 'BTCUSD', price: '7768.5', size: 97159, side: 'Sell'},
        #             {symbol: 'BTCUSD', price: '7769', size: 6508, side: 'Sell'},
        #         ],
        #         time_now: '1583954829.874823'
        #     }
        #
        result = self.safe_value(response, 'result', [])
        timestamp = self.safe_timestamp(response, 'time_now')
        return self.parse_order_book(result, timestamp, 'Buy', 'Sell', 'price', 'size')

    def parse_order_status(self, status):
        statuses = {
            # basic orders
            'Created': 'open',
            'Rejected': 'rejected',  # order is triggered but failed upon being placed
            'New': 'open',
            'Partiallyfilled': 'open',
            'PartiallyFilled': 'open',
            'Filled': 'closed',
            'Cancelled': 'canceled',
            'Pendingcancel': 'canceling',
            # the engine has received the cancellation but there is no guarantee that it will be successful
            'CREATED': 'open',
            'REJECTED': 'rejected',
            'NEW': 'open',
            'ORDER_NEW': 'open',
            'PENDING_NEW': 'open',
            'PARTIALLYFILLED': 'open',
            'PARTIALLY_FILLED': 'open',
            'PARTIALLY_FILLED_CANCELED': 'closed',
            'ORDER_FILLED': 'closed',  # means that the conditional order was triggered but not necessarily filled
            'FILLED': 'closed',
            'CANCELED': 'canceled',
            'ORDER_CANCELED': 'canceled',
            'PENDINGCANCEL': 'canceling',
            'PENDING_CANCEL': 'canceling',
            # conditional orders
            'Active': 'open',  # order is triggered and placed successfully
            'Untriggered': 'open',  # order waits to be triggered
            'Triggered': 'open',
            'NotActive': 'inactive',
            # 'Cancelled': 'canceled',  # order is cancelled
            # 'Rejected': 'rejected',  # order is triggered but fail to be placed
            'Deactivated': 'canceled',  # conditional order was cancelled before triggering
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        marketId = self.safe_string(order, 'symbol')
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        timestamp = self.parse8601(
            self.safe_string_n(order, ['created_at', 'created_time', 'create_time', 'timestamp']))
        if timestamp is None:
            timestamp = self.safe_number_n(order, ['time', 'transactTime', 'createTime'])
        _id = self.safe_string_n(order, ['order_id', 'stop_order_id', 'orderId'])
        side = self.safe_string_lower(order, 'side')
        _type = self.safe_string_lower_n(order, ['order_type', 'type', 'orderType'])
        price = self.safe_float_2(order, 'price', 'orderPrice')
        average = self.safe_float_2(order, 'average_price', 'avgPrice')
        cost = self.safe_float_n(order, ['cum_exec_value', 'cumExecValue', 'cummulativeQuoteQty'])
        filled = self.safe_float_n(order, ['cum_exec_qty', 'executedQty', 'cumExecQty', 'execQty'])
        if (market['spot'] and _type == 'market') and (side == 'buy'):
            amount = filled
        else:
            amount = self.safe_float_n(order, ['qty', 'origQty', 'orderQty'])
        remaining = self.safe_float_2(order, 'leaves_qty', 'leavesQty')
        lastTradeTimestamp = self.safe_timestamp(order, 'last_exec_time')
        if lastTradeTimestamp == 0:
            lastTradeTimestamp = None
        elif lastTradeTimestamp is None:
            lastTradeTimestamp = self.parse8601(
                self.safe_string_n(order, ['updated_time', 'updated_at', 'update_time', 'updateTime']))
        if (filled is None) and (amount is not None) and (remaining is not None):
            filled = amount - remaining
        if filled is not None:
            if (remaining is None) and (amount is not None):
                remaining = amount - filled
            if cost is None:
                if price is not None:
                    cost = price * filled
        if average is None and filled and cost:
            if self.is_linear() or self.is_spot():
                average = cost / filled
            else:
                average = filled / cost
            average = float(self.price_to_precision(symbol, average))
        raw_status = self.safe_string_n(order, ['order_status', 'stop_order_status', 'status', 'orderStatus'])
        status = self.parse_order_status(raw_status)
        fee = None
        fee_cost = self.safe_float_2(order, 'cum_exec_fee', 'cumExecFee')
        if fee_cost is not None:
            fee_cost = abs(fee_cost)
            fee_currency = market['quote'] if market['linear'] else market['base']
            fee = {
                'cost': fee_cost,
                'currency': fee_currency,
            }
        clientOrderId = self.safe_string_2(order, 'order_link_id', 'orderLinkId')
        if (clientOrderId is not None) and (len(clientOrderId) < 1):
            clientOrderId = None
        stop_price = self.safe_float_n(order, ['trigger_price', 'stop_px', 'stopPrice'])
        if not stop_price:
            stop_price = self.safe_float(order, 'triggerPrice')
        return {
            'info': order,
            'id': _id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': _type,
            'side': side,
            'price': price,
            'stopPrice': stop_price,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': None,
        }

    def handle_stop_execution_order(self, func, result, symbol, is_conditional):
        if self.is_spot() and is_conditional and self.safe_string(result, "status") == "ORDER_FILLED":
            order_link_id = self.safe_string(result, "orderLinkId")
            order_execution_id = self.safe_string(result, "executedOrderId")
            if order_link_id:
                return func(None, symbol=symbol, params={"order_link_id": order_link_id})
            elif order_execution_id:
                return func(order_execution_id, symbol=symbol)
            else:
                raise Exception("Missing executedOrderId / orderLinkId")

    def parse_trades_cost_fee(self, symbol, trades):
        cost, fees, fee = 0., defaultdict(lambda: {'cost': 0.}), None
        for trade in trades:
            trade_cost = self.safe_float(trade, 'cost')
            if trade_cost:
                cost += trade_cost
            trade_fee = trade['fee']
            _fee_cost = self.safe_float(trade_fee, 'cost')
            if _fee_cost is not None:
                _fee_currency = trade_fee['currency']
                fees[_fee_currency]['currency'] = _fee_currency
                fees[_fee_currency]['cost'] += _fee_cost

        if fees:
            base_currency = self.get_currency(symbol)
            pair = self.get_pair(symbol)
            fee = fees.get(base_currency) or fees.get(pair)
            if fee is None:
                fee = list(fees.values())[0]
        return cost, fee

    def fetch_order_fee(self, _id, symbol, validate_filled=True):
        order_trades = self.fetch_my_trades(params={"order_id": _id})
        if validate_filled and not order_trades:
            raise TradesNotFound("Couldn't get order's trades for external_order_id: %s" % _id)
        _, fee = self.parse_trades_cost_fee(symbol, order_trades)
        return fee

    def fetch_order(self, _id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            # 'order_link_id': 'string',  # one of order_id, stop_order_id or order_link_id is required
            # regular orders ---------------------------------------------
            # 'order_id': id,  # one of order_id or order_link_id is required for regular orders
            # conditional orders ---------------------------------------------
            # 'stop_order_id': id,  # one of stop_order_id or order_link_id is required for conditional orders
        }
        order_type = self.safe_string_lower(params, 'type')
        params = self.omit(params, ["type"])
        is_conditional = order_type == 'stop'
        if self.is_linear():
            if is_conditional:
                request['stop_order_id'] = _id
                method = 'privateGetPrivateLinearStopOrderSearch'
            else:
                request['order_id'] = _id
                method = 'privateGetPrivateLinearOrderSearch'
        elif self.is_inverse():
            if is_conditional:
                request['stop_order_id'] = _id
                method = 'privateGetV2PrivateStopOrder'
            else:
                request['order_id'] = _id
                method = 'privateGetV2PrivateOrder'
        elif self.is_spot():
            order_link_id = self.safe_string(params, 'order_link_id')
            if order_link_id:
                request['orderLinkId'] = order_link_id
                params = self.omit(params, "order_link_id")
            else:
                request['orderId'] = _id
            if is_conditional:
                request["orderCategory"] = 1
            method = 'privateGetSpotV3PrivateOrder'
        else:
            raise NotImplementedError

        response = getattr(self, method)(self.extend(request, params))
        result = self.safe_value(response, 'result', {})
        parsed_order = self.handle_stop_execution_order(self.fetch_order, result, symbol, is_conditional)
        if parsed_order:
            return parsed_order
        parsed_order = self.parse_order(result, market)
        if self.is_spot() and parsed_order['fee'] is None and parsed_order['filled'] and parsed_order['filled'] > 0:
            parsed_order['fee'] = self.fetch_order_fee(parsed_order["id"], symbol, validate_filled=True)
        return parsed_order

    def create_spot_order(self, symbol, type, side, amount, price=None, params=None):
        if params is None:
            params = {}
        self.load_markets()
        market = self.market(symbol)
        upper_case_type = type.upper()
        request = {
            'symbol': market['id'],
            'side': self.capitalize(side),
            'orderType': upper_case_type,  # limit, market or limit_maker
            'timeInForce': 'GTC',  # FOK, IOC
            # 'orderLinkId': 'string',  # unique client order id, max 36 characters
        }
        if (type == 'market') and (side == 'buy'):
            if price is None:
                raise InvalidOrder(self.id + " market buy order requires price argument to calculate cost(total amount of quote currency to spend for buying, amount * price). To switch off self warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = False. Make sure you know what you're doing.")
            else:
                # for market buy it requires the amount of quote currency to spend
                request['orderQty'] = self.cost_to_precision(symbol, float(amount) * float(price))
        else:
            request['orderQty'] = self.amount_to_precision(symbol, amount)

        if (upper_case_type == 'LIMIT') or (upper_case_type == 'LIMIT_MAKER'):
            if price is None:
                raise InvalidOrder(self.id + ' createOrder requires a price argument for a ' + type + ' order')
            request['orderPrice'] = float(self.price_to_precision(symbol, price))
        is_post_only = self.is_post_only(upper_case_type == 'MARKET', type == 'LIMIT_MAKER', params)
        if is_post_only:
            request['orderType'] = 'LIMIT_MAKER'
        client_order_id = self.safe_string(params, 'order_link_id')
        if client_order_id is not None:
            request['orderLinkId'] = client_order_id
        params = self.omit(params, ['order_link_id', 'post_only'])
        response = self.privatePostSpotV3PrivateOrder(self.extend(request, params))
        #    {
        #        "ret_code":0,
        #        "ret_msg":"",
        #        "ext_code":null,
        #        "ext_info":null,
        #        "result":{
        #           "accountId":"24478790",
        #           "symbol":"ETHUSDT",
        #           "symbolName":"ETHUSDT",
        #           "orderLinkId":"1652266305358517",
        #           "orderId":"1153687819821127168",
        #           "transactTime":"1652266305365",
        #           "price":"80",
        #           "origQty":"0.05",
        #           "executedQty":"0",
        #           "status":"NEW",
        #           "timeInForce":"GTC",
        #           "type":"LIMIT",
        #           "side":"BUY"
        #        }
        #    }
        order = self.safe_value(response, 'result', {})
        return self.parse_order(order)

    def create_contract_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        qty = self.amount_to_precision(symbol, amount)
        if market['inverse']:
            qty = int(qty)
        else:
            qty = float(qty)
            qty = self.is_int_format(qty)
        request = {
            # orders ---------------------------------------------------------
            'side': self.capitalize(side),
            'symbol': market['id'],
            'order_type': self.capitalize(type),
            'qty': qty,  # order quantity in USD, integer only
            # 'price': float(self.price_to_precision(symbol, price)),  # required for limit orders
            'time_in_force': 'GoodTillCancel',  # ImmediateOrCancel, FillOrKill, PostOnly
            # 'take_profit': 123.45,  # take profit price, only take effect upon opening the position
            # 'stop_loss': 123.45,  # stop loss price, only take effect upon opening the position
            # 'reduce_only': False,  # reduce only
            # when creating a closing order, bybit recommends a True value for
            # close_on_trigger to avoid failing due to insufficient available margin
            # 'close_on_trigger': False,
            # 'order_link_id': 'string',  # unique client order id, max 36 characters
            # conditional orders ---------------------------------------------
            # base_price is used to compare with the value of stop_px, to decide
            # whether your conditional order will be triggered by crossing trigger
            # price from upper side or lower side, mainly used to identify the
            # expected direction of the current conditional order
            # 'base_price': 123.45,  # required for conditional orders
            # 'stop_px': 123.45,  # trigger price, required for conditional orders
            # 'trigger_by': 'LastPrice',  # IndexPrice, MarkPrice
        }
        priceIsRequired = False
        if type == 'limit':
            priceIsRequired = True
        if priceIsRequired:
            if price is not None:
                request['price'] = self.is_int_format(float(self.price_to_precision(symbol, price)))
            else:
                raise ArgumentsRequired(self.id + ' createOrder requires a price argument for a ' + type + ' order')
        stopPx = self.safe_value(params, 'stop_px')
        basePrice = self.safe_value(params, 'base_price')
        method = 'privatePostPrivateLinearOrderCreate' if self.is_linear() else 'privatePostV2PrivateOrderCreate'
        if stopPx is not None:
            if basePrice is None:
                raise ArgumentsRequired(self.id + ' createOrder requires both the stop_px and base_price params for a conditional ' + type + ' order')
            else:
                method = 'privatePostPrivateLinearStopOrderCreate' if self.is_linear() else 'privatePostV2PrivateStopOrderCreate'
                request['stop_px'] = self.is_int_format(float(self.price_to_precision(symbol, stopPx)))
                request['base_price'] = self.is_int_format(float(self.price_to_precision(symbol, basePrice)))
                params = self.omit(params, ['stop_px', 'base_price'])
        elif basePrice is not None:
            raise ArgumentsRequired(self.id + ' createOrder requires both the stop_px and base_price params for a conditional ' + type + ' order')
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "OK",
        #         "ext_code": "",
        #         "ext_info": "",
        #         "result": {
        #             "user_id": 1,
        #             "order_id": "335fd977-e5a5-4781-b6d0-c772d5bfb95b",
        #             "symbol": "BTCUSD",
        #             "side": "Buy",
        #             "order_type": "Limit",
        #             "price": 8800,
        #             "qty": 1,
        #             "time_in_force": "GoodTillCancel",
        #             "order_status": "Created",
        #             "last_exec_time": 0,
        #             "last_exec_price": 0,
        #             "leaves_qty": 1,
        #             "cum_exec_qty": 0,
        #             "cum_exec_value": 0,
        #             "cum_exec_fee": 0,
        #             "reject_reason": "",
        #             "order_link_id": "",
        #             "created_at": "2019-11-30T11:03:43.452Z",
        #             "updated_at": "2019-11-30T11:03:43.455Z"
        #         },
        #         "time_now": "1575111823.458705",
        #         "rate_limit_status": 98,
        #         "rate_limit_reset_ms": 1580885703683,
        #         "rate_limit": 100
        #     }
        #
        # conditional orders
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {
        #             "user_id": 1,
        #             "symbol": "BTCUSD",
        #             "side": "Buy",
        #             "order_type": "Limit",
        #             "price": 8000,
        #             "qty": 1,
        #             "time_in_force": "GoodTillCancel",
        #             "stop_order_type": "Stop",
        #             "trigger_by": "LastPrice",
        #             "base_price": 7000,
        #             "order_status": "Untriggered",
        #             "ext_fields": {
        #                 "stop_order_type": "Stop",
        #                 "trigger_by": "LastPrice",
        #                 "base_price": 7000,
        #                 "expected_direction": "Rising",
        #                 "trigger_price": 7500,
        #                 "op_from": "api",
        #                 "remark": "127.0.01",
        #                 "o_req_num": 0
        #             },
        #             "leaves_qty": 1,
        #             "leaves_value": 0.00013333,
        #             "reject_reason": null,
        #             "cross_seq": -1,
        #             "created_at": "2019-12-27T12:48:24.000Z",
        #             "updated_at": "2019-12-27T12:48:24.000Z",
        #             "stop_px": 7500,
        #             "stop_order_id": "a85cd1c0-a9a4-49d3-a1bd-bab5ebe946d5"
        #         },
        #         "ext_info": null,
        #         "time_now": "1577450904.327654",
        #         "rate_limit_status": 99,
        #         "rate_limit_reset_ms": 1577450904335,
        #         "rate_limit": "100"
        #     }
        #
        result = self.safe_value(response, 'result')
        return self.parse_order(result, market)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if params is None:
            params = {}
        self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        if self.is_spot():
            return self.create_spot_order(symbol, type, side, amount, price=price, params=params)
        elif self.is_linear() or self.is_inverse():
            return self.create_contract_order(symbol, type, side, amount, price=price, params=params)
        else:
            raise NotImplementedError

    def edit_contract_order(self, id, symbol, type, side, amount=None, price=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' editOrder requires an symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            # 'order_id': id,  # only for non-conditional orders
            'symbol': market['id'],
            # 'p_r_qty': self.amount_to_precision(symbol, amount),  # new order quantity, optional
            # 'p_r_price' self.priceToprecision(symbol, price),  # new order price, optional
            # ----------------------------------------------------------------
            # conditional orders
            # 'stop_order_id': id,  # only for conditional orders
            # 'p_r_trigger_price': 123.45,  # new trigger price also known as stop_px
        }
        method = 'privatePostPrivateLinearOrderReplace' if self.is_linear() else 'privatePostV2PrivateOrderReplace'
        stopOrderId = self.safe_string(params, 'stop_order_id')
        if stopOrderId is not None:
            method = 'privatePostPrivateLinearStopOrderReplace' if self.is_linear() else 'privatePostV2PrivateStopOrderReplace'
            request['stop_order_id'] = stopOrderId
            params = self.omit(params, ['stop_order_id'])
        else:
            request['order_id'] = id
        if amount is not None:
            request['p_r_qty'] = int(self.amount_to_precision(symbol, amount))
        if price is not None:
            request['p_r_price'] = float(self.price_to_precision(symbol, price))
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {"order_id": "efa44157-c355-4a98-b6d6-1d846a936b93"},
        #         "time_now": "1539778407.210858",
        #         "rate_limit_status": 99,  # remaining number of accesses in one minute
        #         "rate_limit_reset_ms": 1580885703683,
        #         "rate_limit": 100
        #     }
        #
        # conditional orders
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {"stop_order_id": "378a1bbc-a93a-4e75-87f4-502ea754ba36"},
        #         "ext_info": null,
        #         "time_now": "1577475760.604942",
        #         "rate_limit_status": 96,
        #         "rate_limit_reset_ms": 1577475760612,
        #         "rate_limit": "100"
        #     }
        #
        result = self.safe_value(response, 'result', {})
        return {
            'info': response,
            'id': self.safe_string_2(result, 'order_id', 'stop_order_id'),
            'order_id': self.safe_string(result, 'order_id'),
            'stop_order_id': self.safe_string(result, 'stop_order_id'),
        }

    def edit_order(self, _id, symbol, type, side, amount=None, price=None, params=None):
        if params is None:
            params = {}
        if symbol is None:
            raise ArgumentsRequired(self.id + ' editOrder() requires an symbol argument')
        self.load_markets()
        if self.is_spot():
            raise NotSupported(self.id + ' editOrder() does not support spot markets')
        elif self.is_linear() or self.is_inverse():
            return self.edit_contract_order(_id, symbol, type, side, amount, price, params)
        else:
            raise NotImplementedError

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            # 'order_link_id': 'string',  # one of order_id, stop_order_id or order_link_id is required
            # regular orders ---------------------------------------------
            # 'order_id': id,  # one of order_id or order_link_id is required for regular orders
            # conditional orders ---------------------------------------------
            # 'stop_order_id': id,  # one of stop_order_id or order_link_id is required for conditional orders
        }
        stop_order_id = self.safe_string(params, 'stop_order_id')
        params = self.omit(params, ['stop_order_id'])
        is_conditional = stop_order_id is not None
        if self.is_linear():
            if is_conditional:
                request["stop_order_id"] = stop_order_id
                method = 'privatePostPrivateLinearStopOrderCancel'
            else:
                request['order_id'] = id
                method = 'privatePostPrivateLinearOrderCancel'
        elif self.is_inverse():
            if is_conditional:
                request["stop_order_id"] = stop_order_id
                method = 'privatePostV2PrivateStopOrderCancel'
            else:
                request['order_id'] = id
                method = 'privatePostV2PrivateOrderCancel'
        elif self.is_spot():
            order_link_id = self.safe_string(params, 'order_link_id')
            if order_link_id:
                request['orderLinkId'] = order_link_id
                params = self.omit(params, "order_link_id")
            else:
                request['orderId'] = id
            if is_conditional:
                request['orderCategory'] = 1
            method = 'privatePostSpotV3PrivateCancelOrder'
        else:
            raise NotImplementedError
        response = getattr(self, method)(self.extend(request, params))
        result = self.safe_value(response, 'result', {})
        parsed_order = self.handle_stop_execution_order(self.cancel_order, result, symbol, is_conditional)
        if parsed_order:
            return parsed_order
        return self.parse_order(result, market)

    def cancel_all_orders(self, symbol=None, params={}):
        raise NotImplementedError

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'order_id': 'string'
            # 'order_link_id': 'string',  # unique client order id, max 36 characters
            # 'symbol': market['id'],  # default BTCUSD
            # 'order': 'desc',  # asc
            # 'page': 1,
            # 'limit': 20,  # max 50
            # 'order_status': 'Created,New'
            # conditional orders ---------------------------------------------
            # 'stop_order_id': 'string',
            # 'stop_order_status': 'Untriggered',
        }
        if self.is_spot():
            raise NotSupported(self.id + ' fetchOrders() does not support spot markets, '
                                         'use exchange.fetch_open_orders() and exchange.fetchClosedOrders() instead')
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if limit is not None:
            request['limit'] = limit
        options = self.safe_value(self.options, 'fetchOrders', {})

        if self.is_linear():
            default_method = 'privateGetPrivateLinearOrderList'
        else:
            default_method = 'privateGetV2PrivateOrderList'
        query = params
        if ('stop_order_id' in params) or ('stop_order_status' in params):
            stopOrderStatus = self.safe_value(params, 'stopOrderStatus')
            if stopOrderStatus is not None:
                if isinstance(stopOrderStatus, list):
                    stopOrderStatus = ','.join(stopOrderStatus)
                request['stop_order_status'] = stopOrderStatus
                query = self.omit(params, 'stop_order_status')
            default_method = 'privateGetPrivateLinearStopOrderList' if self.is_linear() else 'privateGetV2PrivateStopOrderList'
        method = self.safe_string(options, 'method', default_method)
        response = getattr(self, method)(self.extend(request, query))
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {
        #             "current_page": 1,
        #             "last_page": 6,
        #             "data": [
        #                 {
        #                     "user_id": 1,
        #                     "symbol": "BTCUSD",
        #                     "side": "Sell",
        #                     "order_type": "Market",
        #                     "price": 7074,
        #                     "qty": 2,
        #                     "time_in_force": "ImmediateOrCancel",
        #                     "order_status": "Filled",
        #                     "ext_fields": {
        #                         "close_on_trigger": True,
        #                         "orig_order_type": "BLimit",
        #                         "prior_x_req_price": 5898.5,
        #                         "op_from": "pc",
        #                         "remark": "127.0.0.1",
        #                         "o_req_num": -34799032763,
        #                         "xreq_type": "x_create"
        #                     },
        #                     "last_exec_time": "1577448481.696421",
        #                     "last_exec_price": 7070.5,
        #                     "leaves_qty": 0,
        #                     "leaves_value": 0,
        #                     "cum_exec_qty": 2,
        #                     "cum_exec_value": 0.00028283,
        #                     "cum_exec_fee": 0.00002,
        #                     "reject_reason": "NoError",
        #                     "order_link_id": "",
        #                     "created_at": "2019-12-27T12:08:01.000Z",
        #                     "updated_at": "2019-12-27T12:08:01.000Z",
        #                     "order_id": "f185806b-b801-40ff-adec-52289370ed62"
        #                 }
        #             ]
        #         },
        #         "ext_info": null,
        #         "time_now": "1577448922.437871",
        #         "rate_limit_status": 98,
        #         "rate_limit_reset_ms": 1580885703683,
        #         "rate_limit": 100
        #     }
        #
        # conditional orders
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {
        #             "current_page": 1,
        #             "last_page": 1,
        #             "data": [
        #                 {
        #                     "user_id": 1,
        #                     "stop_order_status": "Untriggered",
        #                     "symbol": "BTCUSD",
        #                     "side": "Buy",
        #                     "order_type": "Limit",
        #                     "price": 8000,
        #                     "qty": 1,
        #                     "time_in_force": "GoodTillCancel",
        #                     "stop_order_type": "Stop",
        #                     "trigger_by": "LastPrice",
        #                     "base_price": 7000,
        #                     "order_link_id": "",
        #                     "created_at": "2019-12-27T12:48:24.000Z",
        #                     "updated_at": "2019-12-27T12:48:24.000Z",
        #                     "stop_px": 7500,
        #                     "stop_order_id": "a85cd1c0-a9a4-49d3-a1bd-bab5ebe946d5"
        #                 },
        #             ]
        #         },
        #         "ext_info": null,
        #         "time_now": "1577451658.755468",
        #         "rate_limit_status": 599,
        #         "rate_limit_reset_ms": 1577451658762,
        #         "rate_limit": 600
        #     }
        #
        result = self.safe_value(response, 'result', {})
        data = self.safe_value(result, 'data', [])
        return self.parse_orders(data, market, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()

        order_type = self.safe_string_lower(params, 'type')
        params = self.omit(params, ["type"])
        is_conditional = order_type == 'stop'
        if self.is_linear() or self.is_inverse():
            statuses = [
                'Rejected',
                'Filled',
                'Cancelled',
                # conditional orders
                # 'Active',
                # 'Triggered',
                # 'Cancelled',
                # 'Rejected',
                # 'Deactivated',
            ]
            request = {}
            if is_conditional:
                statuses.append('Deactivated')
                status = ','.join(statuses)
                request['stop_order_status'] = status
            else:
                status = ','.join(statuses)
                request['order_status'] = status
            return self.fetch_orders(symbol, since, limit, self.extend(request, params))
        elif self.is_spot():
            request = {}
            if is_conditional:
                request["orderCategory"] = 1
            if symbol is not None:
                market = self.market(symbol)
                request['symbol'] = market['id']
            orders = self.privateGetSpotV3PrivateHistoryOrders(self.extend(request, params))
            result = self.safe_value(orders, 'result', [])
            if not isinstance(result, list):
                result = self.safe_value_2(result, 'dataList', 'list', [])
            return self.parse_orders(result, since=since, limit=limit)
        else:
            raise NotImplementedError

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()

        order_type = self.safe_string_lower(params, 'type')
        params = self.omit(params, ["type"])
        is_conditional = order_type == 'stop'
        if self.is_linear() or self.is_inverse():
            statuses = [
                'Created',
                'New',
                'PartiallyFilled',
                'PendingCancel',
                # conditional orders
                # 'Untriggered',
            ]
            request = {}
            if is_conditional:
                statuses.append('Untriggered')
                status = ','.join(statuses)
                request['stop_order_status'] = status
            else:
                status = ','.join(statuses)
                request['order_status'] = status
            return self.fetch_orders(symbol, since, limit, self.extend(request, params))
        elif self.is_spot():
            request = {}
            if is_conditional:
                request["orderCategory"] = 1
            if symbol is not None:
                market = self.market(symbol)
                request['symbol'] = market['id']
            orders = self.privateGetSpotV3PrivateOpenOrders(self.extend(request, params))
            result = self.safe_value(orders, 'result', [])
            if not isinstance(result, list):
                result = self.safe_value_2(result, 'dataList', 'list', [])
            return self.parse_orders(result, since=since, limit=limit)
        else:
            raise NotImplementedError

    def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        request = {
            'order_id': id,
        }
        return self.fetch_my_trades(symbol, since, limit, self.extend(request, params))

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'order_id': 'f185806b-b801-40ff-adec-52289370ed62',  # if not provided will return user's trading records
            # 'symbol': market['id'],
            # 'start_time': int(since / 1000),
            # 'page': 1,
            # 'limit' 20,  # max 50
        }
        market = None
        if symbol is None:
            orderId = self.safe_string(params, 'order_id')
            if orderId is None:
                raise ArgumentsRequired(self.id + ' fetchMyTrades requires a symbol argument or an order_id param')
            else:
                if self.is_linear() or self.is_inverse():
                    request['order_id'] = orderId
                else:
                    request['orderId'] = orderId
                params = self.omit(params, 'order_id')
        else:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            if self.is_linear() or self.is_inverse():
                request['start_time'] = since
            else:
                request['startTime'] = since
        if limit is not None:
            request['limit'] = limit  # default 20, max 50

        if self.is_linear():
            method = 'privateGetPrivateLinearTradeExecutionList'
        elif self.is_inverse():
            method = 'privateGetV2PrivateExecutionList'
        elif self.is_spot():
            method = 'privateGetSpotV3PrivateMyTrades'
        else:
            raise NotImplementedError
        response = getattr(self, method)(self.extend(request, params))

        result = self.safe_value(response, 'result', {})
        if not isinstance(result, list):
            result = self.safe_value_n(result, ['trade_list', 'data', 'list'], [])
        return self.parse_trades(result, market, since, limit)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        if code is None:
            raise ArgumentsRequired(self.id + ' fetchWithdrawals() requires a currency code argument')
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        if limit is not None:
            request['count'] = limit
        response = self.privateGetV2PrivateGetDeposits(self.extend(request, params))
        #
        #     {
        #         "jsonrpc": "2.0",
        #         "id": 5611,
        #         "result": {
        #             "count": 1,
        #             "data": [
        #                 {
        #                     "address": "2N35qDKDY22zmJq9eSyiAerMD4enJ1xx6ax",
        #                     "amount": 5,
        #                     "currency": "BTC",
        #                     "received_timestamp": 1549295017670,
        #                     "state": "completed",
        #                     "transaction_id": "230669110fdaf0a0dbcdc079b6b8b43d5af29cc73683835b9bc6b3406c065fda",
        #                     "updated_timestamp": 1549295130159
        #                 }
        #             ]
        #         }
        #     }
        #
        result = self.safe_value(response, 'result', {})
        data = self.safe_value(result, 'data', [])
        return self.parse_transactions(data, currency, since, limit, params)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'coin': currency['id'],
            # 'start_date': self.iso8601(since),
            # 'end_date': self.iso8601(till),
            # 'status': 'Pending',  # ToBeConfirmed, UnderReview, Pending, Success, CancelByUser, Reject, Expire
            # 'page': 1,
            # 'limit': 20,  # max 50
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['coin'] = currency['id']
        if since is not None:
            request['start_date'] = self.iso8601(since)
        if limit is not None:
            request['limit'] = limit
        response = self.privateGetV2PrivateWalletWithdrawList(self.extend(request, params))
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {
        #             "data": [
        #                 {
        #                     "id": 137,
        #                     "user_id": 1,
        #                     "coin": "XRP",  # Coin Enum
        #                     "status": "Pending",  # Withdraw Status Enum
        #                     "amount": "20.00000000",
        #                     "fee": "0.25000000",
        #                     "address": "rH7H595XYEVTEHU2FySYsWnmfACBnZS9zM",
        #                     "tx_id": "",
        #                     "submited_at": "2019-06-11T02:20:24.000Z",
        #                     "updated_at": "2019-06-11T02:20:24.000Z"
        #                 },
        #             ],
        #             "current_page": 1,
        #             "last_page": 1
        #         },
        #         "ext_info": null,
        #         "time_now": "1577482295.125488",
        #         "rate_limit_status": 119,
        #         "rate_limit_reset_ms": 1577482295132,
        #         "rate_limit": 120
        #     }
        #
        result = self.safe_value(response, 'result', {})
        data = self.safe_value(result, 'data', [])
        return self.parse_transactions(data, currency, since, limit, params)

    def parse_transaction_status(self, status):
        statuses = {
            'ToBeConfirmed': 'pending',
            'UnderReview': 'pending',
            'Pending': 'pending',
            'Success': 'ok',
            'CancelByUser': 'canceled',
            'Reject': 'rejected',
            'Expire': 'expired',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # fetchWithdrawals
        #
        #     {
        #         "id": 137,
        #         "user_id": 1,
        #         "coin": "XRP",  # Coin Enum
        #         "status": "Pending",  # Withdraw Status Enum
        #         "amount": "20.00000000",
        #         "fee": "0.25000000",
        #         "address": "rH7H595XYEVTEHU2FySYsWnmfACBnZS9zM",
        #         "tx_id": "",
        #         "submited_at": "2019-06-11T02:20:24.000Z",
        #         "updated_at": "2019-06-11T02:20:24.000Z"
        #     }
        #
        currencyId = self.safe_string(transaction, 'coin')
        code = self.safe_currency_code(currencyId, currency)
        timestamp = self.parse8601(self.safe_string(transaction, 'submited_at'))
        updated = self.parse8601(self.safe_string(transaction, 'updated_at'))
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        address = self.safe_string(transaction, 'address')
        feeCost = self.safe_float(transaction, 'fee')
        fee = None
        if feeCost is not None:
            fee = {
                'cost': feeCost,
                'currency': code,
            }
        return {
            'info': transaction,
            'id': self.safe_string(transaction, 'id'),
            'txid': self.safe_string(transaction, 'tx_id'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'addressTo': None,
            'addressFrom': None,
            'tag': None,
            'tagTo': None,
            'tagFrom': None,
            'type': 'withdrawal',
            'amount': self.safe_float(transaction, 'amount'),
            'currency': code,
            'status': status,
            'updated': updated,
            'fee': fee,
        }

    def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {
            # 'coin': currency['id'],
            # 'currency': currency['id'],  # alias
            # 'start_date': self.iso8601(since),
            # 'end_date': self.iso8601(till),
            # 'wallet_fund_type': 'Deposit',  # Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
            # 'page': 1,
            # 'limit': 20,  # max 50
        }
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['coin'] = currency['id']
        if since is not None:
            request['start_date'] = self.iso8601(since)
        if limit is not None:
            request['limit'] = limit
        response = self.privateGetV2PrivateWalletFundRecords(self.extend(request, params))
        #
        #     {
        #         "ret_code": 0,
        #         "ret_msg": "ok",
        #         "ext_code": "",
        #         "result": {
        #             "data": [
        #                 {
        #                     "id": 234467,
        #                     "user_id": 1,
        #                     "coin": "BTC",
        #                     "wallet_id": 27913,
        #                     "type": "Realized P&L",
        #                     "amount": "-0.00000006",
        #                     "tx_id": "",
        #                     "address": "BTCUSD",
        #                     "wallet_balance": "0.03000330",
        #                     "exec_time": "2019-12-09T00:00:25.000Z",
        #                     "cross_seq": 0
        #                 }
        #             ]
        #         },
        #         "ext_info": null,
        #         "time_now": "1577481867.115552",
        #         "rate_limit_status": 119,
        #         "rate_limit_reset_ms": 1577481867122,
        #         "rate_limit": 120
        #     }
        #
        result = self.safe_value(response, 'result', {})
        data = self.safe_value(result, 'data', [])
        return self.parse_ledger(data, currency, since, limit)

    def parse_ledger_entry(self, item, currency=None):
        #
        #     {
        #         "id": 234467,
        #         "user_id": 1,
        #         "coin": "BTC",
        #         "wallet_id": 27913,
        #         "type": "Realized P&L",
        #         "amount": "-0.00000006",
        #         "tx_id": "",
        #         "address": "BTCUSD",
        #         "wallet_balance": "0.03000330",
        #         "exec_time": "2019-12-09T00:00:25.000Z",
        #         "cross_seq": 0
        #     }
        #
        currencyId = self.safe_string(item, 'coin')
        code = self.safe_currency_code(currencyId, currency)
        amount = self.safe_float(item, 'amount')
        after = self.safe_float(item, 'wallet_balance')
        direction = 'out' if (amount < 0) else 'in'
        before = None
        if after is not None and amount is not None:
            difference = amount if (direction == 'out') else -amount
            before = self.sum(after, difference)
        timestamp = self.parse8601(self.safe_string(item, 'exec_time'))
        type = self.parse_ledger_entry_type(self.safe_string(item, 'type'))
        id = self.safe_string(item, 'id')
        referenceId = self.safe_string(item, 'tx_id')
        return {
            'id': id,
            'currency': code,
            'account': self.safe_string(item, 'wallet_id'),
            'referenceAccount': None,
            'referenceId': referenceId,
            'status': None,
            'amount': amount,
            'before': before,
            'after': after,
            'fee': None,
            'direction': direction,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'type': type,
            'info': item,
        }

    def parse_ledger_entry_type(self, type):
        types = {
            'Deposit': 'transaction',
            'Withdraw': 'transaction',
            'RealisedPNL': 'trade',
            'Commission': 'fee',
            'Refund': 'cashback',
            'Prize': 'prize',  # ?
            'ExchangeOrderWithdraw': 'transaction',
            'ExchangeOrderDeposit': 'transaction',
        }
        return self.safe_string(types, type, type)

    def get_api_account_details(self):
        response = self.privateGetV2PrivateAccountApiKey()
        result = self.safe_value(response, 'result')
        result = result[0] if result and type(result) == list else result
        ips = self.safe_value(result, "ips")
        exchange_permissions = self.safe_value(result, "permissions")
        read_only = self.safe_value(result, "read_only", default_value=False)
        permissions = list()
        allow_all = type(ips) == list and "*" in ips
        if read_only is False:
            permissions = self.extract_trading_permissions(PERMISSION_TO_VALUE, permissions_list=exchange_permissions)
        return {
            "creation": self.parse8601(self.safe_string(result, "created_at")),
            "expiration": self.parse8601(self.safe_string(result, "expired_at")),
            "permissions": permissions,
            "ip_restrict": not allow_all
        }

    def change_position_mode(self, is_hedge_mode, symbol=None, pair=None):
        _type = self.safe_string(self.options, 'defaultType')
        try:
            if _type == "linear":
                self.load_markets()
                mode = "BothSide" if is_hedge_mode else "MergedSingle"
                data = {'mode': mode}
                if symbol:
                    symbol = self.find_symbol(symbol)
                    _id = self.market(symbol)["id"]
                    data["symbol"] = _id
                elif pair:
                    data["coin"] = pair
                response = self.privatePostPrivateLinearPositionSwitchMode(data)
                return_message = self.safe_string(response, "ret_msg")
                if return_message and return_message.lower().startswith("partial symbols switched"):
                    feedback = self.id + ' ' + json.dumps(response)
                    raise ExchangeError(feedback)
            else:
                raise NotSupported()
        except NotChanged:
            pass

    def get_risk_limits(self, symbol=None):
        if symbol:
            self.load_markets()
            request = {"symbol": self.market_id(symbol)}
        else:
            request = dict()
        if self.is_linear():
            response = self.publicGetPublicLinearRiskLimit(request)
        elif self.is_inverse():
            response = self.publicGetV2PublicRiskLimitList(request)
        else:
            raise NotSupported()

        result = self.safe_value(response, 'result')
        return result

    @staticmethod
    def _get_best_risk_id(risk_limits, desired_limit):
        sorted_limits = sorted(risk_limits, key=lambda x: x["limit"])
        for risk_limit in sorted_limits:
            if desired_limit <= risk_limit["limit"]:
                return risk_limit["id"]

    def set_risk_limit(self, symbol, is_long=None, limit=None, risk_id=None):
        self.load_markets()
        assert limit or risk_id
        if risk_id is None:
            risk_limits = self.get_risk_limits(symbol)
            risk_id = self._get_best_risk_id(risk_limits, limit)

        request = {"symbol": self.market_id(symbol), "risk_id": risk_id}
        try:
            if self.is_linear():
                request["side"] = "Buy" if is_long else "Sell"
                response = self.privatePostPrivateLinearPositionSetRisk(request)
            elif self.is_inverse():
                response = self.privatePostV2PrivatePositionRiskLimit(request)
            else:
                raise NotSupported()
        except NotChanged:
            return risk_id

        result = self.safe_value(response, 'result')
        return self.safe_integer(result, 'risk_id')

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.implode_hostname(self.urls['api'][api]) + '/' + path
        if api == 'public':
            if params:
                url += '?' + self.rawencode(params)
        elif api == 'private':
            self.check_required_credentials()
            isOpenapi = url.find('openapi') >= 0
            timestamp = str(self.nonce())
            if isOpenapi:
                if params:
                    body = self.json(params)
                else:
                    # self fix for PHP is required otherwise it generates
                    # '[]' on empty arrays even when forced to use objects
                    body = '{}'
                payload = timestamp + self.apiKey + body
                signature = self.hmac(self.encode(payload), self.encode(self.secret), hashlib.sha256, 'hex')
                headers = {
                    'Content-Type': 'application/json',
                    'X-BAPI-API-KEY': self.apiKey,
                    'X-BAPI-TIMESTAMP': timestamp,
                    'X-BAPI-SIGN': signature,
                }
            else:
                query = self.extend(params, {
                    'api_key': self.apiKey,
                    'recv_window': self.options['recvWindow'],
                    'timestamp': timestamp,
                })
                sortedQuery = self.keysort(query)
                auth = self.rawencode(sortedQuery)
                signature = self.hmac(self.encode(auth), self.encode(self.secret))
                if method == 'POST':
                    isSpot = url.find('spot') >= 0
                    extendedQuery = self.extend(query, {
                        'sign': signature,
                    })
                    if isSpot:
                        body = self.urlencode(extendedQuery)
                        headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        }
                    else:
                        body = self.json(extendedQuery)
                        headers = {
                            'Content-Type': 'application/json',
                        }
                    if self.partner_name:
                        headers["Referer"] = self.partner_name
                else:
                    url += '?' + self.urlencode(sortedQuery) + '&sign=' + signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        #
        #     {
        #         ret_code: 10001,
        #         ret_msg: 'ReadMapCB: expect {or n, but found \u0000, error ' +
        #         'found in  #0 byte of ...||..., bigger context ' +
        #         '...||...',
        #         ext_code: '',
        #         ext_info: '',
        #         result: null,
        #         time_now: '1583934106.590436'
        #     }
        #
        error_code = self.safe_value_2(response, 'ret_code', 'retCode')
        if error_code:
            errorCode = str(error_code)
            return_message = self.safe_value_2(response, "ret_msg", "retMsg")
            return_message = return_message.lower() if return_message else return_message
            feedback = self.id + ' ' + body
            if errorCode in NOT_CHANGED_ERROR_CODES:
                raise NotChanged(feedback)
            if any(error in return_message for error in ["order not exists", "order does not exist"]):
                raise OrderNotFound(feedback)
            if "unknown order_status" in return_message:
                if "untriggered" in return_message:
                    raise OrderNotFound(feedback)
                else:
                    raise OrderCancelled(feedback)
            if "api key has expired" in return_message:
                raise AuthenticationError(feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], body, feedback)
            raise ExchangeError(feedback)  # unknown message
