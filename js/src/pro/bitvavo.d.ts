import bitvavoRest from '../bitvavo.js';
import { Int, Str, OrderSide, OrderType, OrderBook, Ticker, Trade, Order, OHLCV, Balances, Num, TradingFees } from '../base/types.js';
import Client from '../base/ws/Client.js';
export default class bitvavo extends bitvavoRest {
    describe(): any;
    watchPublic(name: any, symbol: any, params?: {}): Promise<any>;
    watchTicker(symbol: string, params?: {}): Promise<Ticker>;
    handleTicker(client: Client, message: any): any;
    watchTrades(symbol: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    handleTrade(client: Client, message: any): void;
    watchOHLCV(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    handleFetchOHLCV(client: Client, message: any): void;
    handleOHLCV(client: Client, message: any): void;
    watchOrderBook(symbol: string, limit?: Int, params?: {}): Promise<OrderBook>;
    handleDelta(bookside: any, delta: any): void;
    handleDeltas(bookside: any, deltas: any): void;
    handleOrderBookMessage(client: Client, message: any, orderbook: any): any;
    handleOrderBook(client: Client, message: any): void;
    watchOrderBookSnapshot(client: any, message: any, subscription: any): Promise<any>;
    handleOrderBookSnapshot(client: Client, message: any): void;
    handleOrderBookSubscription(client: Client, message: any, subscription: any): void;
    handleOrderBookSubscriptions(client: Client, message: any, marketIds: any): void;
    watchOrders(symbol?: Str, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    watchMyTrades(symbol?: Str, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    createOrderWs(symbol: string, type: OrderType, side: OrderSide, amount: number, price?: Num, params?: {}): Promise<Order>;
    editOrderWs(id: string, symbol: string, type: OrderType, side: OrderSide, amount?: Num, price?: Num, params?: {}): Promise<Order>;
    cancelOrderWs(id: string, symbol?: Str, params?: {}): Promise<any>;
    cancelAllOrdersWs(symbol?: Str, params?: {}): Promise<any>;
    handleMultipleOrders(client: Client, message: any): void;
    fetchOrderWs(id: string, symbol?: Str, params?: {}): Promise<Order>;
    fetchOrdersWs(symbol?: Str, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    watchRequest(action: any, request: any): Promise<any>;
    fetchOpenOrdersWs(symbol?: Str, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    fetchMyTradesWs(symbol?: Str, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    handleMyTrades(client: Client, message: any): void;
    withdrawWs(code: string, amount: any, address: any, tag?: any, params?: {}): Promise<any>;
    handleWithdraw(client: Client, message: any): void;
    fetchWithdrawalsWs(code?: Str, since?: Int, limit?: Int, params?: {}): Promise<any>;
    handleWithdraws(client: Client, message: any): void;
    fetchOHLCVWs(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    fetchDepositsWs(code?: Str, since?: Int, limit?: Int, params?: {}): Promise<any>;
    handleDeposits(client: Client, message: any): void;
    fetchTradingFeesWs(params?: {}): Promise<TradingFees>;
    fetchMarketsWs(params?: {}): Promise<any>;
    fetchCurrenciesWs(params?: {}): Promise<any>;
    handleFetchCurrencies(client: Client, message: any): void;
    handleTradingFees(client: any, message: any): void;
    fetchBalanceWs(params?: {}): Promise<Balances>;
    handleFetchBalance(client: Client, message: any): void;
    handleSingleOrder(client: Client, message: any): void;
    handleMarkets(client: Client, message: any): void;
    buildMessageHash(action: any, params?: {}): any;
    checkMessageHashDoesNotExist(messageHash: any): void;
    actionAndMarketMessageHash(action: any, params?: {}): string;
    actionAndOrderIdMessageHash(action: any, params?: {}): string;
    handleOrder(client: Client, message: any): void;
    handleMyTrade(client: Client, message: any): void;
    handleSubscriptionStatus(client: Client, message: any): any;
    authenticate(params?: {}): Promise<any>;
    handleAuthenticationMessage(client: Client, message: any): void;
    handleErrorMessage(client: Client, message: any): void;
    handleMessage(client: Client, message: any): void;
}
