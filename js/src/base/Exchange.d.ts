import * as functions from './functions.js';
import { // eslint-disable-line object-curly-newline
ExchangeError, AuthenticationError, DDoSProtection, RequestTimeout, ExchangeNotAvailable, RateLimitExceeded } from "./errors.js";
import WsClient from './ws/WsClient.js';
import { Future } from './ws/Future.js';
import { OrderBook as WsOrderBook, IndexedOrderBook, CountedOrderBook } from './ws/OrderBook.js';
import { Market, Trade, Ticker, OHLCV, OHLCVC, Order, OrderBook, Balance, Balances, Dictionary, DepositAddressResponse, Currency, MinMax, IndexType, Int, OrderType, OrderSide, Position, FundingRateHistory, OpenInterest, Liquidation, OrderRequest, FundingHistory, MarginMode, Tickers, Greeks, Str, Num, MarketInterface, CurrencyInterface, Account } from './types.js';
export { Market, Trade, Fee, Ticker, OHLCV, OHLCVC, Order, OrderBook, Balance, Balances, Dictionary, Transaction, DepositAddressResponse, Currency, MinMax, IndexType, Int, OrderType, OrderSide, Position, FundingRateHistory, Liquidation, FundingHistory, Greeks } from './types.js';
/**
 * @class Exchange
 */
export default class Exchange {
    options: {
        [key: string]: any;
    };
    api: any;
    proxy: any;
    proxyUrl: string;
    proxy_url: string;
    proxyUrlCallback: any;
    proxy_url_callback: any;
    httpProxy: string;
    http_proxy: string;
    httpProxyCallback: any;
    http_proxy_callback: any;
    httpsProxy: string;
    https_proxy: string;
    httpsProxyCallback: any;
    https_proxy_callback: any;
    socksProxy: string;
    socks_proxy: string;
    socksProxyCallback: any;
    socks_proxy_callback: any;
    userAgent: {
        'User-Agent': string;
    } | false;
    user_agent: {
        'User-Agent': string;
    } | false;
    userAgents: any;
    headers: any;
    origin: string;
    agent: any;
    minFundingAddressLength: number;
    substituteCommonCurrencyCodes: boolean;
    quoteJsonNumbers: boolean;
    number: (numberString: string) => number;
    handleContentTypeApplicationZip: boolean;
    reduceFees: boolean;
    fetchImplementation: any;
    AbortError: any;
    FetchError: any;
    validateServerSsl: boolean;
    validateClientSsl: boolean;
    timeout: number;
    verbose: boolean;
    twofa: any;
    apiKey: string;
    secret: string;
    uid: string;
    login: string;
    password: string;
    privateKey: string;
    walletAddress: string;
    token: string;
    balance: {};
    orderbooks: {};
    tickers: {};
    orders: any;
    triggerOrders: any;
    trades: any;
    transactions: {};
    ohlcvs: any;
    myTrades: any;
    positions: any;
    urls: {
        logo?: string;
        api?: string | Dictionary<string>;
        test?: string | Dictionary<string>;
        www?: string;
        doc?: string[];
        api_management?: string;
        fees?: string;
        referral?: string;
    };
    requiresWeb3: boolean;
    requiresEddsa: boolean;
    precision: {
        amount: number | undefined;
        price: number | undefined;
    };
    enableLastJsonResponse: boolean;
    enableLastHttpResponse: boolean;
    enableLastResponseHeaders: boolean;
    last_http_response: any;
    last_json_response: any;
    last_response_headers: any;
    last_request_headers: any;
    last_request_body: any;
    last_request_url: any;
    last_request_path: any;
    id: string;
    markets: Dictionary<any>;
    has: Dictionary<boolean | 'emulated'>;
    status: any;
    requiredCredentials: {
        apiKey: boolean;
        secret: boolean;
        uid: boolean;
        login: boolean;
        password: boolean;
        twofa: boolean;
        privateKey: boolean;
        walletAddress: boolean;
        token: boolean;
    };
    rateLimit: number;
    tokenBucket: any;
    throttler: any;
    enableRateLimit: boolean;
    httpExceptions: any;
    limits: {
        amount?: MinMax;
        cost?: MinMax;
        leverage?: MinMax;
        price?: MinMax;
    };
    fees: object;
    markets_by_id: Dictionary<any>;
    symbols: string[];
    ids: string[];
    currencies: Dictionary<Currency>;
    baseCurrencies: any;
    quoteCurrencies: any;
    currencies_by_id: any;
    codes: any;
    reloadingMarkets: any;
    marketsLoading: any;
    accounts: any;
    accountsById: any;
    commonCurrencies: any;
    hostname: string;
    precisionMode: number;
    paddingMode: any;
    exceptions: {};
    timeframes: Dictionary<number | string>;
    version: string;
    marketsByAltname: any;
    name: string;
    lastRestRequestTimestamp: number;
    targetAccount: any;
    stablePairs: {};
    clients: {};
    newUpdates: boolean;
    streaming: {};
    deepExtend: (...xs: any[]) => any;
    isNode: boolean;
    keys: {
        (o: object): string[];
        (o: {}): string[];
    };
    values: (x: any) => any[];
    extend: (...args: any[]) => any;
    clone: (x: any) => any;
    flatten: (x: any, out?: any[]) => any[];
    unique: (x: any) => any[];
    indexBy: (x: any, k: any, out?: {}) => {};
    sortBy: (array: any, key: any, descending?: boolean, defaultValue?: any, direction?: number) => any;
    sortBy2: (array: any, key1: any, key2: any, descending?: boolean, direction?: number) => any;
    groupBy: (x: any, k: any, out?: {}) => {};
    aggregate: typeof functions.aggregate;
    uuid: (a?: any) => string;
    unCamelCase: (s: string) => string;
    precisionFromString: typeof functions.precisionFromString;
    capitalize: (s: string) => string;
    now: () => number;
    decimalToPrecision: (x: any, roundingMode: any, numPrecisionDigits: any, countingMode?: number, paddingMode?: number) => any;
    safeValue: (o: any, k: IndexType, $default?: any) => any;
    safeValue2: (o: any, k1: IndexType, k2: IndexType, $default?: any) => any;
    safeString: (o: any, k: IndexType, $default?: string) => string;
    safeString2: (o: any, k1: IndexType, k2: IndexType, $default?: string) => string;
    safeFloat: (o: any, k: IndexType, $default?: number) => number;
    safeFloat2: (o: any, k1: IndexType, k2: IndexType, $default?: number) => number;
    seconds: () => number;
    milliseconds: () => number;
    binaryToBase16: (data: Uint8Array) => string;
    numberToBE: (n: number, padding: number) => Uint8Array;
    base16ToBinary: (str: string) => Uint8Array;
    iso8601: (timestamp: any) => string;
    omit: (x: any, ...args: any[]) => any;
    isJsonEncodedObject: (object: any) => boolean;
    safeInteger: (o: any, k: IndexType, $default?: number) => number;
    sum: (...xs: any[]) => any;
    omitZero: typeof functions.omitZero;
    implodeParams: (string: any, params: any) => any;
    extractParams: (string: any) => any[];
    json: (data: any, params?: any) => string;
    vwap: typeof functions.vwap;
    merge: (target: any, ...args: any[]) => any;
    binaryConcat: typeof import("../static_dependencies/noble-curves/abstract/utils.js").concatBytes;
    hash: (request: import("../static_dependencies/noble-hashes/utils.js").Input, hash: {
        (message: import("../static_dependencies/noble-hashes/utils.js").Input): Uint8Array;
        outputLen: number;
        blockLen: number;
        create(): import("../static_dependencies/noble-hashes/utils.js").Hash<import("../static_dependencies/noble-hashes/utils.js").Hash<any>>;
    }, digest?: "binary" | "hex" | "base64") => any;
    arrayConcat: (a: any, b: any) => any;
    encode: (str: string) => Uint8Array;
    urlencode: (object: any) => string;
    hmac: (request: import("../static_dependencies/noble-hashes/utils.js").Input, secret: import("../static_dependencies/noble-hashes/utils.js").Input, hash: {
        (message: import("../static_dependencies/noble-hashes/utils.js").Input): Uint8Array;
        outputLen: number;
        blockLen: number;
        create(): import("../static_dependencies/noble-hashes/utils.js").Hash<import("../static_dependencies/noble-hashes/utils.js").Hash<any>>;
    }, digest?: "binary" | "hex" | "base64") => any;
    numberToString: typeof functions.numberToString;
    parseTimeframe: (timeframe: string) => number;
    safeInteger2: (o: any, k1: IndexType, k2: IndexType, $default?: number) => number;
    safeStringLower: (o: any, k: IndexType, $default?: string) => string;
    parse8601: (x: any) => number;
    yyyymmdd: (timestamp: any, infix?: string) => string;
    safeStringUpper: (o: any, k: IndexType, $default?: string) => string;
    safeTimestamp: (o: any, k: IndexType, $default?: number) => number;
    binaryConcatArray: (arr: any) => Uint8Array;
    uuidv1: () => string;
    numberToLE: (n: number, padding: number) => Uint8Array;
    ymdhms: (timestamp: any, infix?: string) => string;
    yymmdd: (timestamp: any, infix?: string) => string;
    stringToBase64: (string: any) => string;
    decode: (data: Uint8Array) => string;
    uuid22: (a?: any) => string;
    safeIntegerProduct2: (o: any, k1: IndexType, k2: IndexType, $factor: number, $default?: number) => number;
    safeIntegerProduct: (o: any, k: IndexType, $factor: number, $default?: number) => number;
    binaryToBase58: (data: Uint8Array) => string;
    base58ToBinary: (str: string) => Uint8Array;
    base64ToBinary: (str: string) => Uint8Array;
    safeTimestamp2: (o: any, k1: IndexType, k2: IndexType, $default?: any) => number;
    rawencode: (object: any) => string;
    keysort: (x: any, out?: {}) => {};
    inArray: (needle: any, haystack: any) => any;
    safeStringLower2: (o: any, k1: IndexType, k2: IndexType, $default?: string) => string;
    safeStringUpper2: (o: any, k1: IndexType, k2: IndexType, $default?: string) => string;
    isEmpty: (object: any) => boolean;
    ordered: (x: any) => any;
    filterBy: (x: any, k: any, value?: any, out?: any[]) => any[];
    uuid16: (a?: any) => string;
    urlencodeWithArrayRepeat: (object: any) => string;
    microseconds: () => number;
    binaryToBase64: (data: Uint8Array) => string;
    strip: (s: string) => string;
    toArray: (object: any) => unknown[];
    safeFloatN: (o: any, k: IndexType[], $default?: number) => number;
    safeIntegerN: (o: any, k: IndexType[], $default?: number) => number;
    safeIntegerProductN: (o: any, k: IndexType[], $factor: number, $default?: number) => number;
    safeTimestampN: (o: any, k: IndexType[], $default?: number) => number;
    safeValueN: (o: any, k: IndexType[], $default?: any) => any;
    safeStringN: (o: any, k: IndexType[], $default?: string) => string;
    safeStringLowerN: (o: any, k: IndexType[], $default?: string) => string;
    safeStringUpperN: (o: any, k: IndexType[], $default?: string) => string;
    urlencodeNested: (object: any) => string;
    parseDate: (x: any) => number;
    ymd: (timestamp: any, infix: any, fullYear?: boolean) => string;
    base64ToString: (string: any) => string;
    crc32: typeof functions.crc32;
    describe(): {
        id: any;
        name: any;
        countries: any;
        enableRateLimit: boolean;
        rateLimit: number;
        certified: boolean;
        pro: boolean;
        alias: boolean;
        has: {
            publicAPI: boolean;
            privateAPI: boolean;
            CORS: any;
            spot: any;
            margin: any;
            swap: any;
            future: any;
            option: any;
            addMargin: any;
            cancelAllOrders: any;
            cancelOrder: boolean;
            cancelOrders: any;
            createDepositAddress: any;
            createLimitOrder: boolean;
            createMarketOrder: boolean;
            createOrder: boolean;
            createOrders: any;
            createPostOnlyOrder: any;
            createReduceOnlyOrder: any;
            createStopOrder: any;
            createStopLimitOrder: any;
            createStopMarketOrder: any;
            createOrderWs: any;
            editOrderWs: any;
            fetchOpenOrdersWs: any;
            fetchOrderWs: any;
            cancelOrderWs: any;
            cancelOrdersWs: any;
            cancelAllOrdersWs: any;
            fetchTradesWs: any;
            fetchBalanceWs: any;
            editOrder: string;
            fetchAccounts: any;
            fetchBalance: boolean;
            fetchBidsAsks: any;
            fetchBorrowInterest: any;
            fetchBorrowRateHistory: any;
            fetchCanceledOrders: any;
            fetchClosedOrder: any;
            fetchClosedOrders: any;
            fetchCrossBorrowRate: any;
            fetchCrossBorrowRates: any;
            fetchCurrencies: string;
            fetchDeposit: any;
            fetchDepositAddress: any;
            fetchDepositAddresses: any;
            fetchDepositAddressesByNetwork: any;
            fetchDeposits: any;
            fetchDepositsWithdrawals: any;
            fetchTransactionFee: any;
            fetchTransactionFees: any;
            fetchFundingHistory: any;
            fetchFundingRate: any;
            fetchFundingRateHistory: any;
            fetchFundingRates: any;
            fetchIndexOHLCV: any;
            fetchIsolatedBorrowRate: any;
            fetchIsolatedBorrowRates: any;
            fetchL2OrderBook: boolean;
            fetchLastPrices: any;
            fetchLedger: any;
            fetchLedgerEntry: any;
            fetchLeverageTiers: any;
            fetchMarketLeverageTiers: any;
            fetchMarkets: boolean;
            fetchMarkOHLCV: any;
            fetchMyTrades: any;
            fetchOHLCV: any;
            fetchOpenInterest: any;
            fetchOpenInterestHistory: any;
            fetchOpenOrder: any;
            fetchOpenOrders: any;
            fetchOrder: any;
            fetchOrderBook: boolean;
            fetchOrderBooks: any;
            fetchOrders: any;
            fetchOrderTrades: any;
            fetchPermissions: any;
            fetchPosition: any;
            fetchPositions: any;
            fetchPositionsBySymbol: any;
            fetchPositionsRisk: any;
            fetchPremiumIndexOHLCV: any;
            fetchStatus: string;
            fetchTicker: boolean;
            fetchTickers: any;
            fetchTime: any;
            fetchTrades: boolean;
            fetchTradingFee: any;
            fetchTradingFees: any;
            fetchTradingLimits: any;
            fetchTransactions: any;
            fetchTransfers: any;
            fetchWithdrawAddresses: any;
            fetchWithdrawal: any;
            fetchWithdrawals: any;
            reduceMargin: any;
            setLeverage: any;
            setMargin: any;
            setMarginMode: any;
            setPositionMode: any;
            signIn: any;
            transfer: any;
            withdraw: any;
            watchOrderBook: any;
            watchOrders: any;
            watchMyTrades: any;
            watchTickers: any;
            watchTicker: any;
            watchTrades: any;
            watchTradesForSymbols: any;
            watchOrderBookForSymbols: any;
            watchOHLCVForSymbols: any;
            watchBalance: any;
            watchOHLCV: any;
        };
        urls: {
            logo: any;
            api: any;
            www: any;
            doc: any;
            fees: any;
        };
        api: any;
        requiredCredentials: {
            apiKey: boolean;
            secret: boolean;
            uid: boolean;
            login: boolean;
            password: boolean;
            twofa: boolean;
            privateKey: boolean;
            walletAddress: boolean;
            token: boolean;
        };
        markets: any;
        currencies: {};
        timeframes: any;
        fees: {
            trading: {
                tierBased: any;
                percentage: any;
                taker: any;
                maker: any;
            };
            funding: {
                tierBased: any;
                percentage: any;
                withdraw: {};
                deposit: {};
            };
        };
        status: {
            status: string;
            updated: any;
            eta: any;
            url: any;
        };
        exceptions: any;
        httpExceptions: {
            '422': typeof ExchangeError;
            '418': typeof DDoSProtection;
            '429': typeof RateLimitExceeded;
            '404': typeof ExchangeNotAvailable;
            '409': typeof ExchangeNotAvailable;
            '410': typeof ExchangeNotAvailable;
            '451': typeof ExchangeNotAvailable;
            '500': typeof ExchangeNotAvailable;
            '501': typeof ExchangeNotAvailable;
            '502': typeof ExchangeNotAvailable;
            '520': typeof ExchangeNotAvailable;
            '521': typeof ExchangeNotAvailable;
            '522': typeof ExchangeNotAvailable;
            '525': typeof ExchangeNotAvailable;
            '526': typeof ExchangeNotAvailable;
            '400': typeof ExchangeNotAvailable;
            '403': typeof ExchangeNotAvailable;
            '405': typeof ExchangeNotAvailable;
            '503': typeof ExchangeNotAvailable;
            '530': typeof ExchangeNotAvailable;
            '408': typeof RequestTimeout;
            '504': typeof RequestTimeout;
            '401': typeof AuthenticationError;
            '407': typeof AuthenticationError;
            '511': typeof AuthenticationError;
        };
        commonCurrencies: {
            XBT: string;
            BCC: string;
            BCHSV: string;
        };
        precisionMode: number;
        paddingMode: number;
        limits: {
            leverage: {
                min: any;
                max: any;
            };
            amount: {
                min: any;
                max: any;
            };
            price: {
                min: any;
                max: any;
            };
            cost: {
                min: any;
                max: any;
            };
        };
    };
    constructor(userConfig?: {});
    encodeURIComponent(...args: any[]): string;
    checkRequiredVersion(requiredVersion: any, error?: boolean): boolean;
    checkAddress(address: any): any;
    initRestRateLimiter(): void;
    throttle(cost?: any): any;
    defineRestApiEndpoint(methodName: any, uppercaseMethod: any, lowercaseMethod: any, camelcaseMethod: any, path: any, paths: any, config?: {}): void;
    defineRestApi(api: any, methodName: any, paths?: any[]): void;
    log(...args: any[]): void;
    fetch(url: any, method?: string, headers?: any, body?: any): Promise<any>;
    parseJson(jsonString: any): any;
    getResponseHeaders(response: any): {};
    handleRestResponse(response: any, url: any, method?: string, requestHeaders?: any, requestBody?: any): any;
    onRestResponse(statusCode: any, statusText: any, url: any, method: any, responseHeaders: any, responseBody: any, requestHeaders: any, requestBody: any): any;
    onJsonResponse(responseBody: any): any;
    loadMarketsHelper(reload?: boolean, params?: {}): Promise<Dictionary<any>>;
    loadMarkets(reload?: boolean, params?: {}): Promise<Dictionary<Market>>;
    fetchCurrencies(params?: {}): Promise<unknown>;
    fetchMarkets(params?: {}): Promise<Market[]>;
    checkRequiredDependencies(): void;
    parseNumber(value: any, d?: number): number;
    checkOrderArguments(market: any, type: any, side: any, amount: any, price: any, params: any): void;
    handleHttpStatusCode(code: any, reason: any, url: any, method: any, body: any): void;
    remove0xPrefix(hexData: any): any;
    spawn(method: any, ...args: any[]): Future;
    delay(timeout: any, method: any, ...args: any[]): void;
    orderBook(snapshot?: {}, depth?: number): WsOrderBook;
    indexedOrderBook(snapshot?: {}, depth?: number): IndexedOrderBook;
    countedOrderBook(snapshot?: {}, depth?: number): CountedOrderBook;
    handleMessage(client: any, message: any): void;
    client(url: any): WsClient;
    watch(url: any, messageHash: any, message?: any, subscribeHash?: any, subscription?: any): any;
    onConnected(client: any, message?: any): void;
    onError(client: any, error: any): void;
    onClose(client: any, error: any): void;
    close(): Promise<any[]>;
    loadOrderBook(client: any, messageHash: any, symbol: any, limit?: any, params?: {}): Promise<void>;
    convertToBigInt(value: string): bigint;
    stringToCharsArray(value: any): any;
    valueIsDefined(value: any): boolean;
    arraySlice(array: any, first: any, second?: any): any;
    getProperty(obj: any, property: any, defaultValue?: any): any;
    axolotl(payload: any, hexKey: any, ed25519: any): string;
    handleDeltas(orderbook: any, deltas: any): void;
    handleDelta(bookside: any, delta: any): void;
    getCacheIndex(orderbook: any, deltas: any): number;
    findTimeframe(timeframe: any, timeframes?: any): string;
    checkProxySettings(url: any, method: any, headers: any, body: any): string[];
    findMessageHashes(client: any, element: string): string[];
    filterByLimit(array: object[], limit?: Int, key?: IndexType): any;
    filterBySinceLimit(array: object[], since?: Int, limit?: Int, key?: IndexType, tail?: boolean): any;
    filterByValueSinceLimit(array: object[], field: IndexType, value?: any, since?: Int, limit?: Int, key?: string, tail?: boolean): any;
    setSandboxMode(enabled: any): void;
    sign(path: any, api?: any, method?: string, params?: {}, headers?: any, body?: any): {};
    fetchAccounts(params?: {}): Promise<any>;
    fetchTrades(symbol: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    fetchTradesWs(symbol: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchTrades(symbol: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchTradesForSymbols(symbols: string[], since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchMyTradesForSymbols(symbols: string[], since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchOrdersForSymbols(symbols: string[], since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchOHLCVForSymbols(symbolsAndTimeframes: string[][], since?: Int, limit?: Int, params?: {}): Promise<Dictionary<Dictionary<OHLCV[]>>>;
    watchOrderBookForSymbols(symbols: string[], limit?: Int, params?: {}): Promise<OrderBook>;
    fetchDepositAddresses(codes?: string[], params?: {}): Promise<any>;
    fetchOrderBook(symbol: string, limit?: Int, params?: {}): Promise<OrderBook>;
    fetchMarginMode(symbol?: string, params?: {}): Promise<MarginMode>;
    fetchRestOrderBookSafe(symbol: any, limit?: any, params?: {}): Promise<OrderBook>;
    watchOrderBook(symbol: string, limit?: Int, params?: {}): Promise<OrderBook>;
    fetchTime(params?: {}): Promise<Int>;
    fetchTradingLimits(symbols?: string[], params?: {}): Promise<any>;
    parseMarket(market: any): Market;
    parseMarkets(markets: any): Market[];
    parseTicker(ticker: object, market?: Market): Ticker;
    parseDepositAddress(depositAddress: any, currency?: Currency): void;
    parseTrade(trade: object, market?: Market): Trade;
    parseTransaction(transaction: any, currency?: Currency): void;
    parseTransfer(transfer: any, currency?: Currency): void;
    parseAccount(account: any): void;
    parseLedgerEntry(item: any, currency?: Currency): void;
    parseOrder(order: any, market?: Market): Order;
    fetchCrossBorrowRates(params?: {}): Promise<any>;
    fetchIsolatedBorrowRates(params?: {}): Promise<any>;
    parseMarketLeverageTiers(info: any, market?: Market): void;
    fetchLeverageTiers(symbols?: string[], params?: {}): Promise<any>;
    parsePosition(position: any, market?: Market): void;
    parseFundingRateHistory(info: any, market?: Market): FundingRateHistory;
    parseBorrowInterest(info: any, market?: Market): void;
    parseWsTrade(trade: any, market?: Market): Trade;
    parseWsOrder(order: any, market?: Market): Order;
    parseWsOrderTrade(trade: any, market?: Market): Trade;
    parseWsOHLCV(ohlcv: any, market?: Market): OHLCV;
    fetchFundingRates(symbols?: string[], params?: {}): Promise<any>;
    transfer(code: string, amount: any, fromAccount: any, toAccount: any, params?: {}): Promise<any>;
    withdraw(code: string, amount: any, address: any, tag?: any, params?: {}): Promise<any>;
    createDepositAddress(code: string, params?: {}): Promise<DepositAddressResponse>;
    setLeverage(leverage: any, symbol?: string, params?: {}): Promise<any>;
    parseToInt(number: any): number;
    parseToNumeric(number: any): number;
    isRoundNumber(value: any): boolean;
    afterConstruct(): void;
    createNetworksByIdObject(): void;
    getDefaultOptions(): {
        defaultNetworkCodeReplacements: {
            ETH: {
                ERC20: string;
            };
            TRX: {
                TRC20: string;
            };
            CRO: {
                CRC20: string;
            };
        };
    };
    safeLedgerEntry(entry: object, currency?: Currency): {
        id: string;
        timestamp: number;
        datetime: string;
        direction: string;
        account: string;
        referenceId: string;
        referenceAccount: string;
        type: string;
        currency: string;
        amount: number;
        before: number;
        after: number;
        status: string;
        fee: any;
        info: object;
    };
    safeCurrencyStructure(currency: object): any;
    safeMarketStructure(market?: any): MarketInterface;
    setMarkets(markets: any, currencies?: any): Dictionary<any>;
    safeBalance(balance: object): Balances;
    safeOrder(order: object, market?: Market): Order;
    parseOrders(orders: object, market?: Market, since?: Int, limit?: Int, params?: {}): Order[];
    calculateFee(symbol: string, type: string, side: string, amount: number, price: number, takerOrMaker?: string, params?: {}): {
        type: string;
        currency: any;
        rate: number;
        cost: number;
    };
    safeLiquidation(liquidation: object, market?: Market): Liquidation;
    safeTrade(trade: object, market?: Market): Trade;
    invertFlatStringDictionary(dict: any): {};
    reduceFeesByCurrency(fees: any): any[];
    safeTicker(ticker: object, market?: Market): Ticker;
    fetchOHLCV(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    watchOHLCV(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    convertTradingViewToOHLCV(ohlcvs: any, timestamp?: string, open?: string, high?: string, low?: string, close?: string, volume?: string, ms?: boolean): any[];
    convertOHLCVToTradingView(ohlcvs: any, timestamp?: string, open?: string, high?: string, low?: string, close?: string, volume?: string, ms?: boolean): {};
    fetchWebEndpoint(method: any, endpointMethod: any, returnAsJson: any, startRegex?: any, endRegex?: any): Promise<any>;
    marketIds(symbols: any): any;
    marketSymbols(symbols: any, type?: string, allowEmpty?: boolean, sameTypeOnly?: boolean, sameSubTypeOnly?: boolean): any;
    marketCodes(codes: any): any;
    parseBidsAsks(bidasks: any, priceKey?: IndexType, amountKey?: IndexType): any[];
    fetchL2OrderBook(symbol: string, limit?: Int, params?: {}): Promise<any>;
    filterBySymbol(objects: any, symbol?: string): any;
    parseOHLCV(ohlcv: any, market?: Market): OHLCV;
    networkCodeToId(networkCode: any, currencyCode?: any): string;
    networkIdToCode(networkId: any, currencyCode?: any): string;
    handleNetworkCodeAndParams(params: any): any[];
    defaultNetworkCode(currencyCode: any): any;
    selectNetworkCodeFromUnifiedNetworks(currencyCode: any, networkCode: any, indexedNetworkEntries: any): any;
    selectNetworkIdFromRawNetworks(currencyCode: any, networkCode: any, indexedNetworkEntries: any): any;
    selectNetworkKeyFromNetworks(currencyCode: any, networkCode: any, indexedNetworkEntries: any, isIndexedByUnifiedNetworkCode?: boolean): any;
    safeNumber2(dictionary: any, key1: any, key2: any, d?: any): number;
    parseOrderBook(orderbook: object, symbol: string, timestamp?: Int, bidsKey?: string, asksKey?: string, priceKey?: IndexType, amountKey?: IndexType): OrderBook;
    parseOHLCVs(ohlcvs: object[], market?: any, timeframe?: string, since?: Int, limit?: Int): OHLCV[];
    parseLeverageTiers(response: any, symbols?: string[], marketIdKey?: any): {};
    loadTradingLimits(symbols?: string[], reload?: boolean, params?: {}): Promise<Dictionary<any>>;
    safePosition(position: any): Position;
    parsePositions(positions: any, symbols?: string[], params?: {}): Position[];
    parseAccounts(accounts: any, params?: {}): any[];
    parseTrades(trades: any, market?: Market, since?: Int, limit?: Int, params?: {}): Trade[];
    parseTransactions(transactions: any, currency?: Currency, since?: Int, limit?: Int, params?: {}): any;
    parseTransfers(transfers: any, currency?: Currency, since?: Int, limit?: Int, params?: {}): any;
    parseLedger(data: any, currency?: Currency, since?: Int, limit?: Int, params?: {}): any;
    nonce(): number;
    setHeaders(headers: any): any;
    marketId(symbol: string): string;
    symbol(symbol: string): string;
    resolvePath(path: any, params: any): any[];
    filterByArray(objects: any, key: IndexType, values?: any, indexed?: boolean): any;
    fetch2(path: any, api?: any, method?: string, params?: {}, headers?: any, body?: any, config?: {}): Promise<any>;
    request(path: any, api?: any, method?: string, params?: {}, headers?: any, body?: any, config?: {}): Promise<any>;
    loadAccounts(reload?: boolean, params?: {}): Promise<any>;
    buildOHLCVC(trades: Trade[], timeframe?: string, since?: number, limit?: number): OHLCVC[];
    parseTradingViewOHLCV(ohlcvs: any, market?: any, timeframe?: string, since?: Int, limit?: Int): OHLCV[];
    editLimitBuyOrder(id: any, symbol: any, amount: any, price?: any, params?: {}): Promise<Order>;
    editLimitSellOrder(id: any, symbol: any, amount: any, price?: any, params?: {}): Promise<Order>;
    editLimitOrder(id: any, symbol: any, side: any, amount: any, price?: any, params?: {}): Promise<Order>;
    editOrder(id: string, symbol: any, type: any, side: any, amount?: any, price?: any, params?: {}): Promise<Order>;
    editOrderWs(id: string, symbol: string, type: OrderType, side: OrderSide, amount: number, price?: number, params?: {}): Promise<Order>;
    fetchPermissions(params?: {}): Promise<void>;
    fetchPosition(symbol: string, params?: {}): Promise<Position>;
    watchPosition(symbol?: string, params?: {}): Promise<Position>;
    watchPositions(symbols?: string[], since?: Int, limit?: Int, params?: {}): Promise<Position[]>;
    watchPositionForSymbols(symbols?: string[], since?: Int, limit?: Int, params?: {}): Promise<Position[]>;
    fetchPositionsBySymbol(symbol: string, params?: {}): Promise<Position[]>;
    fetchPositions(symbols?: string[], params?: {}): Promise<Position[]>;
    fetchPositionsRisk(symbols?: string[], params?: {}): Promise<Position[]>;
    fetchBidsAsks(symbols?: string[], params?: {}): Promise<Dictionary<Ticker>>;
    parseBidAsk(bidask: any, priceKey?: IndexType, amountKey?: IndexType): number[];
    safeCurrency(currencyId: Str, currency?: Currency): CurrencyInterface;
    safeMarket(marketId: Str, market?: Market, delimiter?: Str, marketType?: Str): MarketInterface;
    checkRequiredCredentials(error?: boolean): boolean;
    oath(): string;
    fetchBalance(params?: {}): Promise<Balances>;
    fetchBalanceWs(params?: {}): Promise<Balances>;
    parseBalance(response: any): Balances;
    watchBalance(params?: {}): Promise<Balances>;
    fetchPartialBalance(part: any, params?: {}): Promise<Balance>;
    fetchFreeBalance(params?: {}): Promise<Balance>;
    fetchUsedBalance(params?: {}): Promise<Balance>;
    fetchTotalBalance(params?: {}): Promise<Balance>;
    fetchStatus(params?: {}): Promise<any>;
    fetchFundingFee(code: string, params?: {}): Promise<any>;
    fetchFundingFees(codes?: string[], params?: {}): Promise<any>;
    fetchTransactionFee(code: string, params?: {}): Promise<any>;
    fetchTransactionFees(codes?: string[], params?: {}): Promise<any>;
    fetchDepositWithdrawFees(codes?: string[], params?: {}): Promise<any>;
    fetchDepositWithdrawFee(code: string, params?: {}): Promise<any>;
    getSupportedMapping(key: any, mapping?: {}): any;
    fetchCrossBorrowRate(code: string, params?: {}): Promise<any>;
    fetchIsolatedBorrowRate(symbol: string, params?: {}): Promise<any>;
    handleOptionAndParams(params: any, methodName: any, optionName: any, defaultValue?: any): any[];
    handleOption(methodName: any, optionName: any, defaultValue?: any): any;
    handleMarketTypeAndParams(methodName: string, market?: Market, params?: {}): any;
    handleSubTypeAndParams(methodName: any, market?: any, params?: {}, defaultValue?: any): any[];
    handleMarginModeAndParams(methodName: any, params?: {}, defaultValue?: any): any[];
    throwExactlyMatchedException(exact: any, string: any, message: any): void;
    throwBroadlyMatchedException(broad: any, string: any, message: any): void;
    findBroadlyMatchedKey(broad: any, string: any): string;
    handleErrors(statusCode: any, statusText: any, url: any, method: any, responseHeaders: any, responseBody: any, response: any, requestHeaders: any, requestBody: any): any;
    calculateRateLimiterCost(api: any, method: any, path: any, params: any, config?: {}): any;
    fetchTicker(symbol: string, params?: {}): Promise<Ticker>;
    watchTicker(symbol: string, params?: {}): Promise<Ticker>;
    fetchTickers(symbols?: string[], params?: {}): Promise<Tickers>;
    fetchOrderBooks(symbols?: string[], limit?: Int, params?: {}): Promise<Dictionary<OrderBook>>;
    watchTickers(symbols?: string[], params?: {}): Promise<Dictionary<Ticker>>;
    fetchOrder(id: string, symbol?: string, params?: {}): Promise<Order>;
    fetchOrderWs(id: string, symbol?: string, params?: {}): Promise<Order>;
    fetchOrderStatus(id: string, symbol?: string, params?: {}): Promise<string>;
    fetchUnifiedOrder(order: any, params?: {}): Promise<Order>;
    createOrder(symbol: string, type: OrderType, side: OrderSide, amount: any, price?: any, params?: {}): Promise<Order>;
    createOrders(orders: OrderRequest[], params?: {}): Promise<Order[]>;
    createOrderWs(symbol: string, type: OrderType, side: OrderSide, amount: number, price?: number, params?: {}): Promise<Order>;
    cancelOrder(id: string, symbol?: string, params?: {}): Promise<any>;
    cancelOrderWs(id: string, symbol?: string, params?: {}): Promise<any>;
    cancelOrdersWs(ids: string[], symbol?: string, params?: {}): Promise<any>;
    cancelAllOrders(symbol?: string, params?: {}): Promise<any>;
    cancelAllOrdersWs(symbol?: string, params?: {}): Promise<any>;
    cancelUnifiedOrder(order: any, params?: {}): Promise<any>;
    fetchOrders(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    fetchOrderTrades(id: string, symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchOrders(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    fetchOpenOrders(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    fetchOpenOrdersWs(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    fetchClosedOrders(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Order[]>;
    fetchMyTrades(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    fetchMyLiquidations(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Liquidation[]>;
    fetchLiquidations(symbol: string, since?: Int, limit?: Int, params?: {}): Promise<Liquidation[]>;
    fetchMyTradesWs(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    watchMyTrades(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<Trade[]>;
    fetchOHLCVWs(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    fetchGreeks(symbol: string, params?: {}): Promise<Greeks>;
    fetchDepositsWithdrawals(code?: string, since?: Int, limit?: Int, params?: {}): Promise<any>;
    fetchDeposits(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<any>;
    fetchWithdrawals(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<any>;
    fetchOpenInterest(symbol: string, params?: {}): Promise<OpenInterest>;
    fetchFundingRateHistory(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<FundingRateHistory[]>;
    fetchFundingHistory(symbol?: string, since?: Int, limit?: Int, params?: {}): Promise<FundingHistory[]>;
    parseLastPrice(price: any, market?: Market): any;
    fetchDepositAddress(code: string, params?: {}): Promise<any>;
    account(): Account;
    commonCurrencyCode(currency: string): string;
    currency(code: any): any;
    market(symbol: string): MarketInterface;
    handleWithdrawTagAndParams(tag: any, params: any): any;
    createLimitOrder(symbol: string, side: OrderSide, amount: any, price: any, params?: {}): Promise<Order>;
    createMarketOrder(symbol: string, side: OrderSide, amount: any, price?: any, params?: {}): Promise<Order>;
    createLimitBuyOrder(symbol: string, amount: any, price: any, params?: {}): Promise<Order>;
    createLimitSellOrder(symbol: string, amount: any, price: any, params?: {}): Promise<Order>;
    createMarketBuyOrder(symbol: string, amount: any, params?: {}): Promise<Order>;
    createMarketSellOrder(symbol: string, amount: any, params?: {}): Promise<Order>;
    costToPrecision(symbol: string, cost: any): any;
    priceToPrecision(symbol: string, price: any): string;
    amountToPrecision(symbol: string, amount: any): any;
    feeToPrecision(symbol: string, fee: any): any;
    currencyToPrecision(code: string, fee: any, networkCode?: any): any;
    forceString(value: any): any;
    isTickPrecision(): boolean;
    isDecimalPrecision(): boolean;
    isSignificantPrecision(): boolean;
    safeNumber(obj: object, key: IndexType, defaultNumber?: number): Num;
    safeNumberN(obj: object, arr: IndexType[], defaultNumber?: number): Num;
    parsePrecision(precision?: string): string;
    loadTimeDifference(params?: {}): Promise<any>;
    implodeHostname(url: string): any;
    fetchMarketLeverageTiers(symbol: string, params?: {}): Promise<any>;
    createPostOnlyOrder(symbol: string, type: OrderType, side: OrderSide, amount: any, price: any, params?: {}): Promise<Order>;
    createReduceOnlyOrder(symbol: string, type: OrderType, side: OrderSide, amount: any, price: any, params?: {}): Promise<Order>;
    createStopOrder(symbol: string, type: OrderType, side: OrderSide, amount: any, price?: any, stopPrice?: any, params?: {}): Promise<Order>;
    createStopLimitOrder(symbol: string, side: OrderSide, amount: any, price: any, stopPrice: any, params?: {}): Promise<Order>;
    createStopMarketOrder(symbol: string, side: OrderSide, amount: any, stopPrice: any, params?: {}): Promise<Order>;
    safeCurrencyCode(currencyId: Str, currency?: Currency): string;
    filterBySymbolSinceLimit(array: any, symbol?: string, since?: Int, limit?: Int, tail?: boolean): any;
    filterByCurrencySinceLimit(array: any, code?: any, since?: Int, limit?: Int, tail?: boolean): any;
    filterBySymbolsSinceLimit(array: any, symbols?: string[], since?: Int, limit?: Int, tail?: boolean): any;
    parseLastPrices(pricesData: any, symbols?: string[], params?: {}): any;
    parseTickers(tickers: any, symbols?: string[], params?: {}): Dictionary<Ticker>;
    parseDepositAddresses(addresses: any, codes?: string[], indexed?: boolean, params?: {}): {};
    parseBorrowInterests(response: any, market?: Market): any[];
    parseFundingRateHistories(response: any, market?: any, since?: Int, limit?: Int): FundingRateHistory[];
    safeSymbol(marketId: Str, market?: Market, delimiter?: Str, marketType?: Str): string;
    parseFundingRate(contract: string, market?: Market): void;
    parseFundingRates(response: any, market?: Market): {};
    isTriggerOrder(params: any): any[];
    isPostOnly(isMarketOrder: boolean, exchangeSpecificParam: any, params?: {}): boolean;
    handlePostOnly(isMarketOrder: boolean, exchangeSpecificPostOnlyOption: boolean, params?: any): any[];
    fetchLastPrices(symbols?: string[], params?: {}): Promise<void>;
    fetchTradingFees(params?: {}): Promise<any>;
    fetchTradingFee(symbol: string, params?: {}): Promise<any>;
    parseOpenInterest(interest: any, market?: Market): OpenInterest;
    parseOpenInterests(response: any, market?: any, since?: Int, limit?: Int): OpenInterest[];
    fetchFundingRate(symbol: string, params?: {}): Promise<any>;
    fetchMarkOHLCV(symbol: any, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    fetchIndexOHLCV(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    fetchPremiumIndexOHLCV(symbol: string, timeframe?: string, since?: Int, limit?: Int, params?: {}): Promise<OHLCV[]>;
    handleTimeInForce(params?: {}): string;
    convertTypeToAccount(account: any): any;
    checkRequiredArgument(methodName: any, argument: any, argumentName: any, options?: any[]): void;
    checkRequiredMarginArgument(methodName: string, symbol: string, marginMode: string): void;
    parseDepositWithdrawFees(response: any, codes?: string[], currencyIdKey?: any): any;
    parseDepositWithdrawFee(fee: any, currency?: Currency): any;
    depositWithdrawFee(info: any): any;
    assignDefaultDepositWithdrawFees(fee: any, currency?: any): any;
    parseIncome(info: any, market?: Market): void;
    parseIncomes(incomes: any, market?: any, since?: Int, limit?: Int): FundingHistory[];
    getMarketFromSymbols(symbols?: string[]): MarketInterface;
    parseWsOHLCVs(ohlcvs: object[], market?: any, timeframe?: string, since?: Int, limit?: Int): any[];
    fetchTransactions(code?: string, since?: Int, limit?: Int, params?: {}): Promise<any>;
    filterByArrayPositions(objects: any, key: IndexType, values?: any, indexed?: boolean): Position[];
    filterByArrayTickers(objects: any, key: IndexType, values?: any, indexed?: boolean): Dictionary<Ticker>;
    resolvePromiseIfMessagehashMatches(client: any, prefix: string, symbol: string, data: any): void;
    resolveMultipleOHLCV(client: any, prefix: string, symbol: string, timeframe: string, data: any): void;
    createOHLCVObject(symbol: string, timeframe: string, data: any): Dictionary<Dictionary<OHLCV[]>>;
    handleMaxEntriesPerRequestAndParams(method: string, maxEntriesPerRequest?: Int, params?: {}): [Int, any];
    fetchPaginatedCallDynamic(method: string, symbol?: string, since?: Int, limit?: Int, params?: {}, maxEntriesPerRequest?: Int): Promise<any>;
    safeDeterministicCall(method: string, symbol?: string, since?: Int, limit?: Int, timeframe?: string, params?: {}): Promise<any>;
    fetchPaginatedCallDeterministic(method: string, symbol?: string, since?: Int, limit?: Int, timeframe?: string, params?: {}, maxEntriesPerRequest?: any): Promise<any>;
    fetchPaginatedCallCursor(method: string, symbol?: string, since?: any, limit?: any, params?: {}, cursorReceived?: any, cursorSent?: any, cursorIncrement?: any, maxEntriesPerRequest?: any): Promise<any>;
    fetchPaginatedCallIncremental(method: string, symbol?: string, since?: any, limit?: any, params?: {}, pageKey?: any, maxEntriesPerRequest?: any): Promise<any>;
    sortCursorPaginatedResult(result: any): any;
    removeRepeatedElementsFromArray(input: any): any;
    handleUntilOption(key: any, request: any, params: any, multiplier?: number): any[];
    safeOpenInterest(interest: any, market?: Market): OpenInterest;
    parseLiquidation(liquidation: any, market?: Market): Liquidation;
    parseLiquidations(liquidations: any, market?: any, since?: Int, limit?: Int): Liquidation[];
    parseGreeks(greeks: any, market?: Market): Greeks;
}
export { Exchange, };
