// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

// -------------------------------------------------------------------------------
// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// -------------------------------------------------------------------------------
import Exchange from './abstract/astralx.js';
import { Precise } from './base/Precise.js';
import { ExchangeError, ArgumentsRequired } from './base/errors.js';
import { sha256 } from './static_dependencies/noble-hashes/sha256.js';
import { TICK_SIZE } from './base/functions/number.js';
// -------------------------------------------------------------------------------
/**
 * @class astralx
 * @augments Exchange
 */
export default class astralx extends Exchange {
    describe() {
        return this.deepExtend(super.describe(), {
            'id': 'astralx',
            'name': 'Astralx',
            'countries': ['SG'],
            'rateLimit': 100,
            'pro': false,
            'timezone': 'UTC',
            'has': {
                'CORS': undefined,
                'spot': false,
                'margin': false,
                'swap': true,
                'future': false,
                'option': false,
                'addMargin': false,
                'cancelAllOrders': true,
                'cancelOrder': true,
                'cancelOrders': true,
                'createOrder': true,
                'createReduceOnlyOrder': true,
                'createStopLimitOrder': false,
                'createStopMarketOrder': false,
                'createStopOrder': false,
                'editOrder': false,
                'fetchBalance': true,
                'fetchBorrowInterest': false,
                'fetchBorrowRateHistories': false,
                'fetchBorrowRateHistory': false,
                'fetchClosedOrders': true,
                'fetchCrossBorrowRate': false,
                'fetchCrossBorrowRates': false,
                'fetchDepositAddress': false,
                'fetchDeposits': false,
                'fetchFundingHistory': true,
                'fetchFundingRate': true,
                'fetchFundingRateHistory': true,
                'fetchFundingRates': false,
                'fetchIndexOHLCV': false,
                'fetchIsolatedBorrowRate': false,
                'fetchIsolatedBorrowRates': false,
                'fetchLeverage': true,
                'fetchLeverageTiers': true,
                'fetchMarkets': true,
                'fetchMarkOHLCV': false,
                'fetchMyTrades': true,
                'fetchOHLCV': true,
                'fetchOpenInterest': true,
                'fetchOpenInterestHistory': false,
                'fetchOpenOrders': true,
                'fetchOrder': true,
                'fetchOrderBook': true,
                'fetchOrders': true,
                'fetchPosition': true,
                'fetchPositionHistory': true,
                'fetchPositions': true,
                'fetchPremiumIndexOHLCV': false,
                'fetchTicker': true,
                'fetchTickers': false,
                'fetchTrades': true,
                'fetchTradingFee': false,
                'fetchTradingFees': false,
                'fetchTransfer': true,
                'fetchTransfers': false,
                'fetchWithdrawals': false,
                'reduceMargin': false,
                'setLeverage': true,
                'setMarginMode': false,
                'setPositionMode': false,
                'transfer': false,
                'withdraw': false,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/000000000-0000000000000000000000000000000000000000000000000000000000000000.png',
                'api': {
                    'public': 'https://www.astralx.com',
                    'private': 'https://www.astralx.com',
                },
                'www': 'https://www.astralx.com',
                'doc': [
                    'https://docs.astralx.com',
                ],
                'fees': 'https://www.astralx.com/fees',
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1d',
                '1w': '1w',
                '1M': '1M',
            },
            'api': {
                'public': {
                    'get': {
                        'openapi/time': 1,
                        'openapi/symbol': 1,
                        'openapi/quote/depth': 1,
                        'openapi/quote/trades': 1,
                        'openapi/quote/ticker': 1,
                        'openapi/quote/klines': 1,
                        'openapi/contract/fundingRate': 1,
                        'openapi/contract/fundingRate/history': 1,
                        'openapi/quote/openInterest': 1,
                        'openapi/quote/indexPrice': 1,
                        'openapi/quote/markPrice': 1,
                        'openapi/quote/riskLimit': 1,
                        'openapi/quote/insurance': 1,
                        'openapi/quote/liquidationOrders': 1,
                    },
                },
                'private': {
                    'get': {
                        'openapi/contract/account': 1,
                        'openapi/contract/order': 1,
                        'openapi/contract/openOrders': 1,
                        'openapi/contract/order/history': 1,
                        'openapi/contract/myTrades': 1,
                        'openapi/contract/positions': 1,
                        'openapi/contract/position/history': 1,
                        'openapi/contract/asset': 1,
                        'openapi/contract/transfer': 1,
                        'openapi/contract/income': 1,
                        'openapi/contract/leverage': 1,
                        'openapi/contract/forceOrders': 1,
                        'openapi/contract/adlQuantile': 1,
                    },
                    'post': {
                        'openapi/contract/order': 1,
                        'openapi/contract/batchOrders': 1,
                        'openapi/contract/leverage': 1,
                        'openapi/contract/position/margin': 1,
                        'openapi/contract/position/riskLimit': 1,
                    },
                    'delete': {
                        'openapi/contract/order/cancel': 1,
                        'openapi/contract/batchOrders': 1,
                        'openapi/contract/allOpenOrders': 1,
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'taker': this.parseNumber('0.0006'),
                    'maker': this.parseNumber('0.0002'),
                },
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'exact': {},
                'broad': {},
            },
            'options': {
                'defaultType': 'swap', // 'swap' for USD-M perpetual contracts
            },
            'features': {
                'swap': {
                    'linear': {
                        'sandbox': false,
                        'createOrder': {
                            'marginMode': false,
                            'triggerPrice': false,
                            'triggerPriceType': {
                                'mark': false,
                                'last': false,
                                'index': false,
                            },
                            'stopLossPrice': false,
                            'takeProfitPrice': false,
                            'attachedStopLossTakeProfit': {
                                'triggerPriceType': {
                                    'last': false,
                                    'mark': false,
                                    'index': false,
                                },
                                'price': false,
                            },
                            'timeInForce': {
                                'GTC': false,
                                'IOC': false,
                                'FOK': false,
                                'PO': false,
                                'GTD': false,
                            },
                            'hedged': false,
                            'trailing': false,
                        },
                        'createOrders': {
                            'max': 5,
                        },
                        'fetchMyTrades': {
                            'marginMode': false,
                            'daysBack': 0,
                            'limit': 0,
                            'untilDays': 0,
                            'symbolRequired': false,
                        },
                        'fetchOrder': {
                            'marginMode': false,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchOpenOrders': {
                            'marginMode': false,
                            'limit': 0,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchOrders': {
                            'marginMode': false,
                            'limit': 0,
                            'daysBack': 0,
                            'untilDays': 0,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchClosedOrders': {
                            'marginMode': false,
                            'limit': 0,
                            'daysBack': 0,
                            'daysBackCanceled': 0,
                            'untilDays': 0,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchOHLCV': {
                            'limit': 0,
                        },
                    },
                    'inverse': {
                        'sandbox': false,
                        'createOrder': {
                            'marginMode': false,
                            'triggerPrice': false,
                            'triggerPriceType': {
                                'mark': false,
                                'last': false,
                                'index': false,
                            },
                            'stopLossPrice': false,
                            'takeProfitPrice': false,
                            'attachedStopLossTakeProfit': {
                                'triggerPriceType': {
                                    'last': false,
                                    'mark': false,
                                    'index': false,
                                },
                                'price': false,
                            },
                            'timeInForce': {
                                'GTC': false,
                                'IOC': false,
                                'FOK': false,
                                'PO': false,
                                'GTD': false,
                            },
                            'hedged': false,
                            'trailing': false,
                        },
                        'createOrders': {
                            'max': 5,
                        },
                        'fetchMyTrades': {
                            'marginMode': false,
                            'daysBack': 0,
                            'limit': 0,
                            'untilDays': 0,
                            'symbolRequired': false,
                        },
                        'fetchOrder': {
                            'marginMode': false,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchOpenOrders': {
                            'marginMode': false,
                            'limit': 0,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchOrders': {
                            'marginMode': false,
                            'limit': 0,
                            'daysBack': 0,
                            'untilDays': 0,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchClosedOrders': {
                            'marginMode': false,
                            'limit': 0,
                            'daysBack': 0,
                            'daysBackCanceled': 0,
                            'untilDays': 0,
                            'trigger': false,
                            'trailing': false,
                            'symbolRequired': false,
                        },
                        'fetchOHLCV': {
                            'limit': 0,
                        },
                    },
                },
            },
        });
    }
    async fetchMarkets(params = {}) {
        /**
         * @method
         * @name astralx#fetchMarkets
         * @description retrieves data on all markets for astralx
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {Market[]} an array of objects representing market data
         */
        const response = await this.publicGetOpenapiSymbol(params);
        // API直接返回数组，没有'data'字段
        const markets = response;
        const result = [];
        for (let i = 0; i < markets.length; i++) {
            const market = markets[i];
            const category = this.safeInteger(market, 'category');
            // 根据API文档，只处理category=4的swap类型市场
            if (category !== 4) {
                continue;
            }
            const id = this.safeString(market, 'symbolId');
            let baseId = this.safeString(market, 'baseTokenId');
            const quoteId = this.safeString(market, 'quoteTokenId');
            // 对于永续合约市场（category=4），使用tokenFutures.displayUnderlyingId作为baseTokenId
            const tokenFutures = this.safeDict(market, 'tokenFutures');
            if (tokenFutures !== undefined) {
                const displayUnderlyingId = this.safeString(tokenFutures, 'displayUnderlyingId');
                if (displayUnderlyingId !== undefined) {
                    baseId = displayUnderlyingId;
                }
            }
            const base = this.safeCurrencyCode(baseId);
            const quote = this.safeCurrencyCode(quoteId);
            const symbol = base + '/' + quote + ':' + quote;
            const active = this.safeValue(market, 'canTrade') === true;
            // 获取tokenFutures中的合约相关信息
            let contractSize = 1; // 默认值
            let maxLeverage = undefined;
            let minLeverage = undefined;
            let leverageLimits = undefined;
            if (tokenFutures !== undefined) {
                contractSize = this.safeNumber(tokenFutures, 'contractMultiplier', 1);
                maxLeverage = this.safeNumber(tokenFutures, 'maxLeverage');
                // 处理杠杆范围
                const levers = this.safeValue(tokenFutures, 'levers', []);
                if (levers.length > 0) {
                    let minLever = undefined;
                    let maxLever = undefined;
                    for (let j = 0; j < levers.length; j++) {
                        const lever = this.safeNumber(levers, j);
                        if (lever !== undefined) {
                            if (minLever === undefined || lever < minLever) {
                                minLever = lever;
                            }
                            if (maxLever === undefined || lever > maxLever) {
                                maxLever = lever;
                            }
                        }
                    }
                    if (minLever !== undefined && maxLever !== undefined) {
                        minLeverage = minLever;
                        maxLeverage = maxLever;
                        leverageLimits = {
                            'min': minLeverage,
                            'max': maxLeverage,
                        };
                    }
                }
            }
            result.push({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'type': 'swap',
                'spot': false,
                'margin': false,
                'swap': true,
                'future': false,
                'option': false,
                'contract': true,
                'settle': quote,
                'settleId': quoteId,
                'contractSize': contractSize,
                'linear': true,
                'inverse': false,
                'taker': this.parseNumber('0.0006'),
                'maker': this.parseNumber('0.0002'),
                'percentage': true,
                'tierBased': false,
                'maxLeverage': maxLeverage,
                'limits': {
                    'amount': {
                        'min': this.safeNumber(market, 'minTradeQuantity') * contractSize,
                        'max': undefined,
                    },
                    'price': {
                        'min': this.safeNumber(market, 'minPricePrecision'),
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.safeNumber(market, 'minTradeAmount'),
                        'max': undefined,
                    },
                    'leverage': leverageLimits,
                },
                'precision': {
                    'amount': this.safeNumber(market, 'basePrecision') * contractSize,
                    'price': this.safeNumber(market, 'quotePrecision'),
                    'cost': undefined,
                    'base': undefined,
                    'quote': undefined,
                },
                'info': market,
            });
        }
        return result;
    }
    async fetchTicker(symbol, params = {}) {
        /**
         * @method
         * @name astralx#fetchTicker
         * @description fetches a price ticker for a trading symbol
         * @param {string} symbol unified symbol of the market to fetch the ticker for
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        const response = await this.publicGetOpenapiQuoteTicker(params);
        // 根据API测试结果，响应是一个对象，键为交易对ID
        // 需要将市场ID转换为API使用的格式（如AAVEUSDT_PERP -> AAVE_USDT）
        let marketIdForTicker = market['id'];
        // 如果市场ID包含_PERP后缀，需要转换为下划线格式
        if (marketIdForTicker.endsWith('_PERP')) {
            const baseSymbol = marketIdForTicker.replace('_PERP', '');
            // 将AAVEUSDT格式转换为AAVE_USDT格式
            if (baseSymbol.length > 3) {
                const quoteCurrency = baseSymbol.slice(-4); // 取最后4个字符（USDT）
                const baseCurrency = baseSymbol.slice(0, -4); // 取除了USDT之外的部分
                marketIdForTicker = baseCurrency + '_' + quoteCurrency;
            }
        }
        const ticker = this.safeValue(response, marketIdForTicker, {});
        return this.parseTicker(ticker, market);
    }
    parseTicker(ticker, market = undefined) {
        /**
         * @method
         * @name astralx#parseTicker
         * @description parses a ticker structure from the exchange response
         * @param {object} ticker the ticker data from the exchange
         * @param {object} [market] the market to which the ticker belongs
         * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
         */
        // 使用当前时间作为时间戳，因为API返回的数据中可能没有时间戳
        const timestamp = this.milliseconds();
        const marketId = this.safeString(ticker, 'symbol');
        const symbol = this.safeSymbol(marketId, market);
        const last = this.safeNumber(ticker, 'lastPrice');
        // 根据API测试结果，ticker数据只包含lastPrice、baseVolume、quoteVolume
        // 其他字段如open、high、low、bid、ask等可能不存在
        const baseVolume = this.safeNumber(ticker, 'baseVolume');
        const quoteVolume = this.safeNumber(ticker, 'quoteVolume');
        return this.safeTicker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'high': undefined,
            'low': undefined,
            'bid': undefined,
            'bidVolume': undefined,
            'ask': undefined,
            'askVolume': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': last,
            'last': last,
            'previousClose': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }, market);
    }
    async fetchOrderBook(symbol, limit = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchOrderBook
         * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {string} symbol unified symbol of the market to fetch the order book for
         * @param {int} [limit] the maximum amount of order book entries to return
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {OrderBook} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = {
            'symbol': market['id'],
        };
        if (limit !== undefined) {
            request['limit'] = limit;
        }
        const response = await this.publicGetOpenapiQuoteDepth(this.extend(request, params));
        const timestamp = this.safeInteger(response, 'time');
        return this.parseOrderBook(response, symbol, timestamp, 'bids', 'asks', 0, 1);
    }
    async fetchOHLCV(symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchOHLCV
         * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
         * @param {string} symbol unified symbol of the market to fetch OHLCV data for
         * @param {string} timeframe the length of time each candle represents
         * @param {int} [since] timestamp in ms of the earliest candle to fetch
         * @param {int} [limit] the maximum amount of candles to fetch
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {OHLCV[]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = {
            'symbol': market['id'],
            'interval': this.timeframes[timeframe],
        };
        if (since !== undefined) {
            request['startTime'] = since;
        }
        if (limit !== undefined) {
            request['limit'] = limit;
        }
        const response = await this.publicGetOpenapiQuoteKlines(this.extend(request, params));
        // API直接返回K线数据数组，不需要额外的处理
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }
    parseOHLCV(ohlcv, market = undefined) {
        /**
         * @method
         * @name astralx#parseOHLCV
         * @description parses OHLCV data from the exchange response
         * @param {number[]} ohlcv the OHLCV data from the exchange
         * @param {object} [market] the market to which the OHLCV data belongs
         * @returns {number[]} [timestamp, open, high, low, close, volume]
         */
        return [
            this.safeInteger(ohlcv, 0),
            this.safeNumber(ohlcv, 1),
            this.safeNumber(ohlcv, 2),
            this.safeNumber(ohlcv, 3),
            this.safeNumber(ohlcv, 4),
            this.safeNumber(ohlcv, 5),
        ];
    }
    async fetchTime(params = {}) {
        /**
         * @method
         * @name astralx#fetchTime
         * @description fetches the current integer timestamp in milliseconds from the exchange server
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {int} the current integer timestamp in milliseconds from the exchange server
         */
        const response = await this.publicGetOpenapiTime(params);
        return this.safeInteger(response, 'serverTime');
    }
    async fetchFundingRate(symbol, params = {}) {
        /**
         * @method
         * @name astralx#fetchFundingRate
         * @description fetches the current funding rate
         * @param {string} symbol unified symbol of the market to fetch the funding rate for
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = {
            'symbol': market['id'],
        };
        const response = await this.publicGetOpenapiContractFundingRate(this.extend(request, params));
        // API直接返回资金费率数组，取第一个元素
        const fundingRateData = this.safeValue(response, 0, {});
        return this.parseFundingRate(fundingRateData, market);
    }
    parseFundingRate(contract, market = undefined) {
        /**
         * @method
         * @name astralx#parseFundingRate
         * @description parses a funding rate structure from the exchange response
         * @param {object} contract the funding rate data from the exchange
         * @param {object} [market] the market to which the funding rate belongs
         * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
         */
        const marketId = this.safeString(contract, 'symbol');
        const symbol = this.safeSymbol(marketId, market);
        const fundingRate = this.safeNumber(contract, 'rate'); // API返回的是rate字段
        const intervalStart = this.safeInteger(contract, 'intervalStart');
        const intervalEnd = this.safeInteger(contract, 'intervalEnd');
        // 使用intervalEnd作为fundingTimestamp，intervalStart作为previousFundingTimestamp
        const fundingTimestamp = intervalEnd;
        const previousFundingTimestamp = intervalStart;
        const nextFundingTimestamp = intervalEnd ? intervalEnd + (intervalEnd - intervalStart) : undefined;
        // 处理None值的时间戳
        let fundingDatetime = undefined;
        let previousFundingDatetime = undefined;
        let nextFundingDatetime = undefined;
        if (fundingTimestamp !== undefined) {
            fundingDatetime = this.iso8601(fundingTimestamp);
        }
        if (previousFundingTimestamp !== undefined) {
            previousFundingDatetime = this.iso8601(previousFundingTimestamp);
        }
        if (nextFundingTimestamp !== undefined) {
            nextFundingDatetime = this.iso8601(nextFundingTimestamp);
        }
        return {
            'info': contract,
            'symbol': symbol,
            'markPrice': undefined,
            'indexPrice': undefined,
            'interestRate': undefined,
            'estimatedSettlePrice': undefined,
            'timestamp': fundingTimestamp,
            'datetime': fundingDatetime,
            'fundingRate': fundingRate,
            'fundingTimestamp': fundingTimestamp,
            'fundingDatetime': fundingDatetime,
            'nextFundingRate': undefined,
            'nextFundingTimestamp': nextFundingTimestamp,
            'nextFundingDatetime': nextFundingDatetime,
            'previousFundingRate': fundingRate,
            'previousFundingTimestamp': previousFundingTimestamp,
            'previousFundingDatetime': previousFundingDatetime,
        };
    }
    async fetchTrades(symbol, since = undefined, limit = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchTrades
         * @description get the list of most recent trades for a particular symbol
         * @param {string} symbol unified symbol of the market to fetch trades for
         * @param {int} [since] timestamp in ms of the earliest trade to fetch
         * @param {int} [limit] the maximum amount of trades to fetch
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        const request = {
            'symbol': market['id'],
        };
        if (limit !== undefined) {
            request['limit'] = limit;
        }
        const response = await this.publicGetOpenapiQuoteTrades(this.extend(request, params));
        return this.parseTrades(response, market, since, limit);
    }
    parseTrade(trade, market = undefined) {
        /**
         * @method
         * @name astralx#parseTrade
         * @description parses a trade structure from the exchange response
         * @param {object} trade the trade data from the exchange
         * @param {object} [market] the market to which the trade belongs
         * @returns {object} a [trade structure]{@link https://docs.ccxt.com/#/?id=public-trades}
         */
        const timestamp = this.safeInteger(trade, 'time');
        // 处理不同的marketId字段名
        const marketId = this.safeString2(trade, 'symbolId', 'symbol');
        const symbol = this.safeSymbol(marketId, market);
        // 处理不同的tradeId字段名
        const id = this.safeString2(trade, 'tradeId', 'id');
        const orderId = this.safeString(trade, 'orderId');
        const priceString = this.safeString(trade, 'price');
        // 处理不同的数量字段名
        const amountString = this.safeString2(trade, 'quantity', 'qty');
        const price = this.parseNumber(priceString);
        const amount = this.parseNumber(amountString);
        const cost = this.parseNumber(Precise.stringMul(priceString, amountString));
        // 处理方向信息
        let side = this.safeString(trade, 'side');
        if (side === 'BUY_OPEN' || side === 'BUY_CLOSE') {
            side = 'buy';
        }
        else if (side === 'SELL_OPEN' || side === 'SELL_CLOSE') {
            side = 'sell';
        }
        else if (side === undefined) {
            // 公共交易接口可能使用isBuyerMaker字段
            const isBuyerMaker = this.safeValue(trade, 'isBuyerMaker');
            if (isBuyerMaker !== undefined) {
                side = isBuyerMaker ? 'sell' : 'buy';
            }
        }
        const takerOrMaker = undefined; // API响应中没有maker/taker信息
        // 处理手续费信息
        let fee = undefined;
        const feeCost = this.safeNumber2(trade, 'fee', 'commission');
        if (feeCost !== undefined) {
            const feeCurrencyId = this.safeString2(trade, 'feeTokenId', 'commissionAsset');
            const feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            };
        }
        return this.safeTrade({
            'info': trade,
            'id': id,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'symbol': symbol,
            'order': orderId,
            'type': this.safeString2(trade, 'orderType', 'type'),
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }, market);
    }
    async fetchCurrencies(params = {}) {
        /**
         * @method
         * @name astralx#fetchCurrencies
         * @description fetches all available currencies on an exchange
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} an associative dictionary of currencies
         */
        await this.loadMarkets();
        const response = await this.publicGetOpenapiSymbol(params);
        const currencies = {};
        for (let i = 0; i < response.length; i++) {
            const market = response[i];
            const category = this.safeInteger(market, 'category');
            // 根据API文档，只处理category=4的swap类型市场
            if (category !== 4) {
                continue;
            }
            let baseId = this.safeString(market, 'baseTokenId');
            const quoteId = this.safeString(market, 'quoteTokenId');
            // 对于永续合约市场（category=4），使用tokenFutures.displayUnderlyingId作为baseTokenId
            const tokenFutures = this.safeDict(market, 'tokenFutures');
            if (tokenFutures !== undefined) {
                const displayUnderlyingId = this.safeString(tokenFutures, 'displayUnderlyingId');
                if (displayUnderlyingId !== undefined) {
                    baseId = displayUnderlyingId;
                }
            }
            if (baseId !== undefined && !(baseId in currencies)) {
                const code = this.safeCurrencyCode(baseId);
                currencies[baseId] = {
                    'id': baseId,
                    'code': code,
                    'name': baseId,
                    'active': true,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'deposit': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'networks': {},
                    'info': market,
                };
                // 为USDT、BTC和ETH设置withdraw和deposit标志
                if (code === 'USDT' || code === 'BTC' || code === 'ETH') {
                    currencies[baseId]['withdraw'] = true;
                    currencies[baseId]['deposit'] = true;
                }
            }
            if (quoteId !== undefined && !(quoteId in currencies)) {
                const code = this.safeCurrencyCode(quoteId);
                currencies[quoteId] = {
                    'id': quoteId,
                    'code': code,
                    'name': quoteId,
                    'active': true,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'deposit': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'networks': {},
                    'info': market,
                };
                // 为USDT、BTC和ETH设置withdraw和deposit标志
                if (code === 'USDT' || code === 'BTC' || code === 'ETH') {
                    currencies[quoteId]['withdraw'] = true;
                    currencies[quoteId]['deposit'] = true;
                }
            }
        }
        return currencies;
    }
    async fetchBalance(params = {}) {
        /**
         * @method
         * @name astralx#fetchBalance
         * @description query for balance and get the amount of funds available for trading or funds locked in orders
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
         */
        await this.loadMarkets();
        const response = await this.privateGetOpenapiContractAccount(params);
        // API直接返回币种余额对象，如：{"USDT": {...}}
        // 如果API没有返回时间戳，使用当前时间
        const timestamp = this.milliseconds();
        const datetime = this.iso8601(timestamp);
        const result = {
            'info': response,
            'timestamp': timestamp,
            'datetime': datetime,
        };
        const currencyIds = Object.keys(response);
        for (let i = 0; i < currencyIds.length; i++) {
            const currencyId = currencyIds[i];
            const balance = response[currencyId];
            const code = this.safeCurrencyCode(currencyId);
            const account = this.account();
            // 正确计算free、used和total余额
            const availableMargin = this.safeString(balance, 'availableMargin');
            const orderMargin = this.safeString(balance, 'orderMargin');
            const positionMargin = this.safeString(balance, 'positionMargin');
            const total = this.safeString(balance, 'total');
            account['free'] = availableMargin;
            // used余额应该是orderMargin + positionMargin
            let used = Precise.stringAdd(orderMargin, positionMargin);
            // 如果used为0，则强制计算used = total - free
            if (Precise.stringEquals(used, '0')) {
                used = Precise.stringSub(total, availableMargin);
            }
            account['used'] = used;
            account['total'] = total;
            result[code] = account;
        }
        return this.safeBalance(result);
    }
    async createOrder(symbol, type, side, amount, price = undefined, params = {}) {
        /**
         * @method
         * @name astralx#createOrder
         * @description create a trade order
         * @param {string} symbol unified symbol of the market to create an order in
         * @param {string} type 'market' or 'limit'
         * @param {string} side 'buy' or 'sell'
         * @param {float} amount how much of currency you want to trade in units of base currency
         * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        // 处理side参数映射：buy/sell -> BUY_OPEN/SELL_OPEN
        let apiSide = side.toUpperCase();
        if (apiSide === 'BUY') {
            apiSide = 'BUY_OPEN';
        }
        else if (apiSide === 'SELL') {
            apiSide = 'SELL_OPEN';
        }
        // 处理type参数映射：market/limit -> MARKET/LIMIT
        const apiType = type.toUpperCase();
        let priceType = 'INPUT';
        if (apiType === 'MARKET') {
            priceType = 'MARKET';
        }
        else if (apiType === 'LIMIT') {
            priceType = 'INPUT';
        }
        const request = {
            'symbol': market['id'],
            'side': apiSide,
            'orderType': 'LIMIT',
            'quantity': this.parseNumber(this.amountToPrecision(symbol, amount)) / market['contractSize'],
            'priceType': priceType,
            'leverage': '10',
            'timeInForce': 'GTC',
            'isCross': 'true', // 默认全仓模式
        };
        // 限价单需要价格参数
        if (type === 'limit') {
            request['price'] = this.priceToPrecision(symbol, price);
        }
        // 处理额外参数
        const clientOrderId = this.safeString(params, 'clientOrderId');
        if (clientOrderId === undefined) {
            request['clientOrderId'] = this.uuid();
        }
        const response = await this.privatePostOpenapiContractOrder(this.extend(request, params));
        // API响应直接返回订单数据，不需要提取data字段
        return this.parseOrder(response, market);
    }
    async createReduceOnlyOrder(symbol, type, side, amount, price = undefined, params = {}) {
        /**
         * @method
         * @name astralx#createReduceOnlyOrder
         * @description create a reduce-only order to close a position
         * @param {string} symbol unified symbol of the market to create an order in
         * @param {string} type 'market' or 'limit'
         * @param {string} side 'buy' or 'sell'
         * @param {float} amount how much of currency you want to trade in units of base currency
         * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
         */
        await this.loadMarkets();
        const market = this.market(symbol);
        // 处理side参数映射：buy/sell -> BUY_CLOSE/SELL_CLOSE (平仓方向)
        let apiSide = side.toUpperCase();
        if (apiSide === 'BUY') {
            apiSide = 'BUY_CLOSE';
        }
        else if (apiSide === 'SELL') {
            apiSide = 'SELL_CLOSE';
        }
        // 处理type参数映射：market/limit -> MARKET/LIMIT
        const apiType = type.toUpperCase();
        let priceType = 'INPUT';
        if (apiType === 'MARKET') {
            priceType = 'MARKET';
        }
        else if (apiType === 'LIMIT') {
            priceType = 'INPUT';
        }
        const request = {
            'symbol': market['id'],
            'side': apiSide,
            'orderType': 'LIMIT',
            'quantity': this.parseNumber(this.amountToPrecision(symbol, amount)) / market['contractSize'],
            'priceType': priceType,
            'leverage': '10',
            'timeInForce': 'GTC',
            'isCross': 'true', // 默认全仓模式
        };
        // 限价单需要价格参数
        if (type === 'limit') {
            request['price'] = this.priceToPrecision(symbol, price);
        }
        // 处理额外参数
        const clientOrderId = this.safeString(params, 'clientOrderId');
        if (clientOrderId === undefined) {
            request['clientOrderId'] = this.uuid();
        }
        const response = await this.privatePostOpenapiContractOrder(this.extend(request, params));
        // API响应直接返回订单数据，不需要提取data字段
        return this.parseOrder(response, market);
    }
    async cancelOrder(id, symbol = undefined, params = {}) {
        /**
         * @method
         * @name astralx#cancelOrder
         * @description cancels an open order
         * @param {string} id order id
         * @param {string} symbol unified symbol of the market the order was made in
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
         */
        await this.loadMarkets();
        if (symbol === undefined) {
            throw new ArgumentsRequired(this.id + ' cancelOrder() requires a symbol argument');
        }
        const market = this.market(symbol);
        const request = {
            'orderId': id,
            'symbol': market['id'],
            'orderType': 'LIMIT', // 根据API文档，必需参数，默认LIMIT
        };
        const response = await this.privateDeleteOpenapiContractOrderCancel(this.extend(request, params));
        const order = this.safeValue(response, 'data', response);
        return this.parseOrder(order, market);
    }
    async fetchOrder(id, symbol = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchOrder
         * @description fetches information on an order made by the user
         * @param {string} id the order id
         * @param {string} symbol unified symbol of the market the order was made in
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
         */
        await this.loadMarkets();
        const request = {
            'orderId': id,
        };
        if (symbol !== undefined) {
            const market = this.market(symbol);
            request['symbol'] = market['id'];
        }
        const response = await this.privateGetOpenapiContractOrder(this.extend(request, params));
        const order = this.safeValue(response, 'data', {});
        return this.parseOrder(order);
    }
    async fetchOpenOrders(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchOpenOrders
         * @description fetches information on all open orders made by the user
         * @param {string} symbol unified market symbol of the market orders were made in
         * @param {int} [since] the earliest time in ms to fetch orders for
         * @param {int} [limit] the maximum number of order structures to retrieve
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
         */
        await this.loadMarkets();
        const request = {};
        if (symbol !== undefined) {
            const market = this.market(symbol);
            request['symbol'] = market['id'];
        }
        const response = await this.privateGetOpenapiContractOpenOrders(this.extend(request, params));
        // API直接返回订单数组，没有data字段包装
        const orders = this.safeValue(response, 'data', response);
        return this.parseOrders(orders, undefined, since, limit);
    }
    async fetchMyTrades(symbol = undefined, since = undefined, limit = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchMyTrades
         * @description fetch all trades made by the user
         * @param {string} symbol unified market symbol
         * @param {int} [since] the earliest time in ms to fetch trades for
         * @param {int} [limit] the maximum number of trades structures to retrieve
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
         */
        await this.loadMarkets();
        const request = {};
        if (symbol !== undefined) {
            const market = this.market(symbol);
            request['symbol'] = market['id'];
        }
        if (since !== undefined) {
            request['startTime'] = since;
        }
        if (limit !== undefined) {
            request['limit'] = limit;
        }
        const response = await this.privateGetOpenapiContractMyTrades(this.extend(request, params));
        // API直接返回交易数组，没有data字段包装
        const trades = this.safeValue(response, 'data', response);
        return this.parseTrades(trades, undefined, since, limit);
    }
    async fetchPositions(symbols = undefined, params = {}) {
        /**
         * @method
         * @name astralx#fetchPositions
         * @description fetch all open positions
         * @param {string[]} [symbols] list of unified market symbols
         * @param {object} [params] extra parameters specific to the exchange API endpoint
         * @returns {Position[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
         */
        await this.loadMarkets();
        const request = {};
        // 如果指定了symbols参数，只查询指定symbol的仓位
        if (symbols !== undefined) {
            // 只支持查询一个symbol的仓位
            if (symbols.length === 1) {
                const market = this.market(symbols[0]);
                request['symbol'] = market['id'];
            }
        }
        const response = await this.privateGetOpenapiContractPositions(this.extend(request, params));
        // API直接返回数组格式的仓位数据
        const positions = response;
        const result = [];
        for (let i = 0; i < positions.length; i++) {
            const position = this.parsePosition(positions[i]);
            result.push(position);
        }
        // 当传入symbols参数时，确保返回数组格式
        if (symbols !== undefined) {
            const filtered = this.filterByArray(result, 'symbol', symbols);
            // 将过滤后的对象转换为数组
            return Object.values(filtered);
        }
        return result;
    }
    parsePosition(position, marketParam = undefined) {
        /**
         * @method
         * @name astralx#parsePosition
         * @description parse a position structure from the exchange response
         * @param {object} position the position data from the exchange
         * @param {object} [marketParam] the market to which the position belongs
         * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
         */
        const marketId = this.safeString(position, 'symbol');
        const market = this.safeMarket(marketId, marketParam);
        const symbol = market['symbol'];
        // 根据API文档解析仓位方向
        const side = this.safeStringLower(position, 'side');
        let positionSide = undefined;
        if (side === 'long') {
            positionSide = 'long';
        }
        else if (side === 'short') {
            positionSide = 'short';
        }
        // 根据API文档和示例数据解析字段
        const amount = this.safeNumber(position, 'position'); // 总数量（单位：张）
        const available = this.safeNumber(position, 'available'); // 可用数量（单位：张）
        const contracts = amount !== undefined ? amount : available; // 使用总数量作为合约数量
        const entryPrice = this.safeNumber(position, 'avgPrice'); // 开仓均价
        const unrealizedPnl = this.safeNumber(position, 'unrealizedPnL'); // 未实现盈亏
        const leverage = this.safeNumber(position, 'leverage'); // 杠杆
        const liquidationPriceRaw = this.safeNumber(position, 'flp'); // 强平价格
        let liquidationPrice = undefined;
        if (liquidationPriceRaw !== 0) {
            liquidationPrice = liquidationPriceRaw;
        }
        const markPrice = this.safeNumber(position, 'lastPrice'); // 标记价格
        const margin = this.safeNumber(position, 'margin'); // 仓位保证金
        const positionValue = this.safeNumber(position, 'positionValue'); // 持仓价值
        const marginRate = this.safeNumber(position, 'marginRate'); // 保证金率
        const realizedPnl = this.safeNumber(position, 'realizedPnL'); // 已实现盈亏
        const percentage = this.safeNumber(position, 'profitRate'); // 持仓收益率
        // 使用API返回的时间戳，如果没有则使用当前时间
        const timestamp = this.safeInteger(position, 'timestamp', this.milliseconds());
        // 计算实际合约数量（考虑合约大小）
        let actualContracts = contracts;
        if (contracts !== undefined && market['contractSize'] !== undefined) {
            actualContracts = contracts * market['contractSize'];
        }
        // 计算名义价值
        let notional = positionValue;
        if (notional === undefined && entryPrice !== undefined && contracts !== undefined) {
            notional = entryPrice * contracts * market['contractSize'];
        }
        return this.safePosition({
            'info': position,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'initialMargin': margin,
            'initialMarginPercentage': undefined,
            'maintenanceMargin': undefined,
            'maintenanceMarginPercentage': undefined,
            'entryPrice': entryPrice,
            'notional': notional,
            'leverage': leverage,
            'unrealizedPnl': unrealizedPnl,
            'contracts': actualContracts,
            'contractSize': market['contractSize'],
            'realizedPnl': realizedPnl,
            'side': positionSide,
            'hedged': undefined,
            'marginMode': 'cross',
            'liquidationPrice': liquidationPrice,
            'markPrice': markPrice,
            'collateral': margin,
            'initialCollateral': margin,
            'percentage': percentage,
            'marginRatio': marginRate,
        });
    }
    parseOrder(order, marketParam = undefined) {
        /**
         * @method
         * @name astralx#parseOrder
         * @description parse an order structure from the exchange response
         * @param {object} order the order data from the exchange
         * @param {object} [marketParam] the market to which the order belongs
         * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
         */
        // 直接使用传入的market参数，避免重新查找
        const market = marketParam !== undefined ? marketParam : this.safeMarket(this.safeString(order, 'symbol'));
        const symbol = market['symbol'];
        const timestamp = this.safeInteger(order, 'time');
        const price = this.safeNumber(order, 'price');
        // 需要将origQty乘以contractSize来还原实际数量
        const origQtyString = this.safeString(order, 'origQty');
        let amount = undefined;
        if (origQtyString !== undefined) {
            const origQty = parseFloat(origQtyString);
            amount = origQty * market['contractSize'];
        }
        const executedQtyString = this.safeString(order, 'executedQty');
        let filled = undefined;
        if (executedQtyString !== undefined) {
            const executedQty = parseFloat(executedQtyString);
            filled = executedQty * market['contractSize'];
        }
        let remaining = undefined;
        if (amount !== undefined && filled !== undefined) {
            remaining = Math.max(0, amount - filled);
        }
        let status = this.safeString(order, 'status');
        if (status === 'NEW') {
            status = 'open';
        }
        else if (status === 'FILLED') {
            status = 'closed';
        }
        else if (status === 'CANCELED') {
            status = 'canceled';
        }
        else if (status === 'PARTIALLY_FILLED') {
            status = 'open';
        }
        // Astralx使用BUY_OPEN/SELL_OPEN等方向值，需要映射到标准的buy/sell
        let side = this.safeString(order, 'side');
        if (side === 'BUY_OPEN' || side === 'BUY_CLOSE') {
            side = 'buy';
        }
        else if (side === 'SELL_OPEN' || side === 'SELL_CLOSE') {
            side = 'sell';
        }
        // 根据priceType确定订单类型：INPUT -> limit, MARKET -> market
        const priceType = this.safeString(order, 'priceType');
        let type = 'limit'; // 默认限价单
        if (priceType === 'MARKET') {
            type = 'market';
        }
        else if (priceType === 'INPUT') {
            type = 'limit';
        }
        const id = this.safeString(order, 'orderId');
        const clientOrderId = this.safeString(order, 'clientOrderId');
        const average = this.safeNumber(order, 'avgPrice');
        return this.safeOrder({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': this.iso8601(timestamp),
            'lastTradeTimestamp': undefined,
            'symbol': symbol,
            'type': type,
            'timeInForce': this.safeString(order, 'timeInForce'),
            'postOnly': undefined,
            'side': side,
            'price': price,
            'triggerPrice': undefined,
            'amount': amount,
            'cost': undefined,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': undefined,
            'trades': undefined,
        });
    }
    sign(path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        /**
         * @method
         * @name astralx#sign
         * @description signs the request with HMAC-SHA256
         * @param {string} path the API endpoint path
         * @param {string} api 'public' or 'private'
         * @param {string} method 'GET', 'POST', 'DELETE'
         * @param {object} params the parameters to include in the request
         * @param {object} [headers] additional headers to include
         * @param {object} [body] the request body
         * @returns {object} the signed request parameters
         */
        let url = this.urls['api'][api];
        url += '/' + path;
        const query = this.omit(params, this.extractParams(path));
        if (api === 'private') {
            this.checkRequiredCredentials();
            const timestamp = this.milliseconds();
            query['timestamp'] = timestamp.toString();
            const signature = this.hmac(this.encode(this.urlencode(query)), this.encode(this.secret), sha256);
            query['signature'] = signature;
            headers = {
                'APIKEY-HEADER': this.apiKey,
            };
        }
        if (Object.keys(query).length) {
            url += '?' + this.urlencode(query);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
    handleErrors(code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
        /**
         * @method
         * @name astralx#handleErrors
         * @description handles exchange errors
         * @param {int} code the HTTP status code
         * @param {string} reason the HTTP reason phrase
         * @param {string} url the URL of the request
         * @param {string} method the HTTP method used
         * @param {object} headers the HTTP headers
         * @param {string} body the response body
         * @param {object} response the parsed response
         * @param {object} requestHeaders the original request headers
         * @param {object} requestBody the original request body
         * @returns {void}
         */
        if (response === undefined) {
            return undefined;
        }
        const errorCode = this.safeString(response, 'code');
        if (errorCode !== undefined) {
            const message = this.safeString(response, 'msg', '');
            const feedback = this.id + ' ' + body;
            this.throwExactlyMatchedException(this.exceptions['exact'], errorCode, feedback);
            this.throwBroadlyMatchedException(this.exceptions['broad'], message, feedback);
            throw new ExchangeError(feedback);
        }
        return undefined;
    }
}
