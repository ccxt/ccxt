// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

/**
 * Deluthium DEX - Comprehensive Unit Tests
 *
 * Tests cover:
 * - Symbol format conversion (hyphen to slash)
 * - pairId caching mechanism
 * - Dual error format handling (string + numeric codes)
 * - Parameter style handling (snake_case vs camelCase)
 * - Cross-chain support
 * - Authentication (all endpoints require JWT)
 */
import assert from 'assert';
// ============================================================================
// Test: Symbol Format Conversion
// ============================================================================
function testSymbolFormatConversion(exchange) {
    const method = 'testSymbolFormatConversion';
    console.log(`  Testing: ${method}`);
    // Test cases for hyphen to slash conversion
    const testCases = [
        { input: 'WBNB-USDT', expected: 'WBNB/USDT' },
        { input: 'BTCB-USDT', expected: 'BTCB/USDT' },
        { input: 'WETH-USDC', expected: 'WETH/USDC' },
        { input: 'ETH-DAI', expected: 'ETH/DAI' },
        { input: 'LINK-BNB', expected: 'LINK/BNB' },
    ];
    for (const tc of testCases) {
        const result = tc.input.replace('-', '/');
        assert.strictEqual(result, tc.expected, `Symbol conversion failed: ${tc.input} should become ${tc.expected}, got ${result}`);
    }
    console.log(`    ✓ All symbol format conversions passed`);
}
// ============================================================================
// Test: pairId Cache Structure
// ============================================================================
function testPairIdCacheStructure(exchange) {
    const method = 'testPairIdCacheStructure';
    console.log(`  Testing: ${method}`);
    // Initialize cache if not exists
    exchange.options['pairIdCache'] = exchange.options['pairIdCache'] || {};
    // Simulate caching from fetchMarkets
    const mockMarkets = [
        { pair_id: 101, chain_id: 56, pair_symbol: 'WBNB-USDT' },
        { pair_id: 102, chain_id: 1, pair_symbol: 'WETH-USDC' },
        { pair_id: 103, chain_id: 8453, pair_symbol: 'WETH-USDC' },
    ];
    for (const market of mockMarkets) {
        const symbol = market.pair_symbol.replace('-', '/');
        exchange.options['pairIdCache'][symbol] = {
            pairId: market.pair_id,
            chainId: market.chain_id,
        };
    }
    // Verify cache structure
    const cache = exchange.options['pairIdCache'];
    assert('WBNB/USDT' in cache, 'WBNB/USDT should be in cache');
    assert('WETH/USDC' in cache, 'WETH/USDC should be in cache');
    assert.strictEqual(cache['WBNB/USDT'].pairId, 101, 'WBNB/USDT pairId should be 101');
    assert.strictEqual(cache['WBNB/USDT'].chainId, 56, 'WBNB/USDT chainId should be 56');
    // Note: WETH/USDC will be overwritten by Base chain entry (last one wins)
    // This tests the cache update behavior
    assert.strictEqual(cache['WETH/USDC'].chainId, 8453, 'WETH/USDC chainId should be 8453 (last entry)');
    console.log(`    ✓ pairId cache structure tests passed`);
}
// ============================================================================
// Test: Dual Error Format Detection
// ============================================================================
function testDualErrorFormatDetection(exchange) {
    const method = 'testDualErrorFormatDetection';
    console.log(`  Testing: ${method}`);
    // String error codes (Trading Service)
    const stringErrorResponses = [
        { code: 'INVALID_INPUT', message: 'Invalid request' },
        { code: 'INVALID_TOKEN', message: 'Bad token' },
        { code: 'INSUFFICIENT_LIQUIDITY', message: 'No liquidity' },
        { code: 'QUOTE_EXPIRED', message: 'Quote expired' },
        { code: 'MM_NOT_AVAILABLE', message: 'MMs unavailable' },
    ];
    for (const response of stringErrorResponses) {
        const code = exchange.safeString(response, 'code');
        assert(typeof code === 'string', `String error code should be string: ${code}`);
        assert(code !== '10000', 'Error code should not be success code');
    }
    // Numeric error codes (Market Data Service)
    const numericErrorResponses = [
        { code: 10095, message: 'Invalid parameters' },
        { code: 20003, message: 'Internal error' },
        { code: 20004, message: 'Not found' },
    ];
    for (const response of numericErrorResponses) {
        const code = exchange.safeInteger(response, 'code');
        assert(typeof code === 'number', `Numeric error code should be number: ${code}`);
        assert(code !== 10000, 'Error code should not be success code');
    }
    // Success codes (both formats)
    const successResponses = [
        { code: '10000', message: 'success', data: {} },
        { code: 10000, message: 'success', data: {} }, // Numeric success
    ];
    for (const response of successResponses) {
        const stringCode = exchange.safeString(response, 'code');
        const numericCode = exchange.safeInteger(response, 'code');
        // At least one should indicate success
        const isStringSuccess = stringCode === '10000';
        const isNumericSuccess = numericCode === 10000;
        assert(isStringSuccess || isNumericSuccess, 'Success response should be recognized in either format');
    }
    console.log(`    ✓ Dual error format detection tests passed`);
}
// ============================================================================
// Test: Parameter Style Handling
// ============================================================================
function testParameterStyleHandling(exchange) {
    const method = 'testParameterStyleHandling';
    console.log(`  Testing: ${method}`);
    // snake_case endpoints
    const snakeCaseParams = {
        'chain_id': 56,
        'token_address': '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        'src_chain_id': 56,
        'dst_chain_id': 56,
        'token_in': '0x55d398326f99059fF775485246999027B3197955',
        'token_out': '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        'amount_in': '100',
        'from_address': '0x1234567890123456789012345678901234567890',
        'to_address': '0x1234567890123456789012345678901234567890',
        'expiry_time_sec': 60,
        'indicative_amount_out': '81500000000000000',
    };
    // Verify snake_case format
    for (const key of Object.keys(snakeCaseParams)) {
        assert(key.includes('_') || !key.match(/[A-Z]/), `snake_case param should not have uppercase: ${key}`);
    }
    // camelCase endpoints (Market Data)
    const camelCaseParams = {
        'chainId': 56,
        'pairId': 101,
        'interval': '1h',
        'startTime': 1706832000000,
    };
    // Verify camelCase format (no underscores in multi-word params)
    for (const key of Object.keys(camelCaseParams)) {
        if (key.length > 5) { // Only check multi-word params
            assert(!key.includes('_'), `camelCase param should not have underscore: ${key}`);
        }
    }
    console.log(`    ✓ Parameter style handling tests passed`);
}
// ============================================================================
// Test: Chain ID Validation
// ============================================================================
function testChainIdValidation(exchange) {
    const method = 'testChainIdValidation';
    console.log(`  Testing: ${method}`);
    const supportedChains = [
        { id: 56, name: 'BSC' },
        { id: 8453, name: 'Base' },
        { id: 1, name: 'Ethereum' },
    ];
    // Verify default chain ID
    const defaultChainId = exchange.safeInteger(exchange.options, 'defaultChainId', 56);
    assert(supportedChains.some(c => c.id === defaultChainId), `Default chain ID ${defaultChainId} should be supported`);
    // Verify wrapped token addresses for each chain
    const wrappedTokens = exchange.safeDict(exchange.options, 'wrappedTokens', {});
    // BSC - WBNB
    if (56 in wrappedTokens) {
        const wbnb = wrappedTokens[56];
        assert(wbnb.startsWith('0x'), 'WBNB address should start with 0x');
        assert(wbnb.length === 42, 'WBNB address should be 42 characters');
    }
    // Base - WETH
    if (8453 in wrappedTokens) {
        const weth = wrappedTokens[8453];
        assert(weth.startsWith('0x'), 'WETH (Base) address should start with 0x');
    }
    // Ethereum - WETH
    if (1 in wrappedTokens) {
        const weth = wrappedTokens[1];
        assert(weth.startsWith('0x'), 'WETH (ETH) address should start with 0x');
    }
    console.log(`    ✓ Chain ID validation tests passed`);
}
// ============================================================================
// Test: Address Checksum Validation
// ============================================================================
function testAddressChecksumValidation(exchange) {
    const method = 'testAddressChecksumValidation';
    console.log(`  Testing: ${method}`);
    // These addresses should be properly checksummed
    const checksummedAddresses = [
        '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        '0x4200000000000000000000000000000000000006',
        '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
        '0x0000000000000000000000000000000000000000', // Native token address
    ];
    for (const address of checksummedAddresses) {
        // Basic validation
        assert(address.startsWith('0x'), `Address should start with 0x: ${address}`);
        assert(address.length === 42, `Address should be 42 chars: ${address}`);
        // Check it's a valid hex string
        const hexPart = address.slice(2);
        assert(/^[0-9a-fA-F]+$/.test(hexPart), `Address should be valid hex: ${address}`);
    }
    console.log(`    ✓ Address checksum validation tests passed`);
}
// ============================================================================
// Test: Slippage Parameter Handling
// ============================================================================
function testSlippageParameterHandling(exchange) {
    const method = 'testSlippageParameterHandling';
    console.log(`  Testing: ${method}`);
    // Default slippage
    const defaultSlippage = exchange.safeNumber(exchange.options, 'defaultSlippage', 0.5);
    assert(defaultSlippage >= 0, 'Slippage should be non-negative');
    assert(defaultSlippage <= 100, 'Slippage should be <= 100%');
    // Test slippage values
    const slippageTestCases = [
        { value: 0.1, valid: true, description: '0.1% - very tight' },
        { value: 0.5, valid: true, description: '0.5% - standard' },
        { value: 1.0, valid: true, description: '1.0% - cross-chain recommended' },
        { value: 5.0, valid: true, description: '5.0% - high volatility' },
        { value: 50.0, valid: true, description: '50% - extreme (but valid)' },
    ];
    for (const tc of slippageTestCases) {
        assert(tc.value >= 0 && tc.value <= 100, `Slippage ${tc.value} should be valid: ${tc.description}`);
    }
    console.log(`    ✓ Slippage parameter handling tests passed`);
}
// ============================================================================
// Test: Quote Structure Validation
// ============================================================================
function testQuoteStructureValidation(exchange) {
    const method = 'testQuoteStructureValidation';
    console.log(`  Testing: ${method}`);
    // Mock indicative quote response
    const indicativeQuoteResponse = {
        quote_id: 'q-12345',
        token_in: '0x55d398326f99059fF775485246999027B3197955',
        token_out: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        amount_in: '100000000000000000000',
        amount_out: '163200000000000000',
        price: '612.50',
        price_impact: '0.05',
        fee_amount: '100000000000000000',
        expiry_timestamp: 1706918460000,
    };
    // Required fields for indicative quote
    const requiredIndicativeFields = [
        'quote_id', 'token_in', 'token_out',
        'amount_in', 'amount_out', 'price', 'expiry_timestamp'
    ];
    for (const field of requiredIndicativeFields) {
        assert(field in indicativeQuoteResponse, `Indicative quote should have field: ${field}`);
    }
    // Mock firm quote response
    const firmQuoteResponse = {
        quote_id: 'firm-q-12345',
        token_in: '0x55d398326f99059fF775485246999027B3197955',
        token_out: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        amount_in: '100000000000000000000',
        amount_out: '163000000000000000',
        min_amount_out: '162185000000000000',
        router_address: '0xRouterAddress1234567890123456789012345678',
        calldata: '0x12345678abcdef...',
        expiry_timestamp: 1706918460000,
        gas_estimate: '250000',
    };
    // Additional required fields for firm quote
    const requiredFirmFields = [
        'router_address', 'calldata', 'min_amount_out'
    ];
    for (const field of requiredFirmFields) {
        assert(field in firmQuoteResponse, `Firm quote should have field: ${field}`);
    }
    // Verify calldata format
    assert(firmQuoteResponse.calldata.startsWith('0x'), 'Calldata should start with 0x');
    console.log(`    ✓ Quote structure validation tests passed`);
}
// ============================================================================
// Test: Order Response with Calldata
// ============================================================================
function testOrderResponseWithCalldata(exchange) {
    const method = 'testOrderResponseWithCalldata';
    console.log(`  Testing: ${method}`);
    // Mock parsed order response
    const mockOrder = {
        id: 'firm-q-12345',
        symbol: 'WBNB/USDT',
        type: 'market',
        side: 'buy',
        amount: 100,
        status: 'open',
        info: {
            calldata: '0x12345678abcdef...',
            router_address: '0xRouterAddress1234567890123456789012345678',
            gas_estimate: '250000',
        },
    };
    // Verify order structure
    assert(mockOrder.id !== undefined, 'Order should have id');
    assert(mockOrder.symbol !== undefined, 'Order should have symbol');
    assert(mockOrder.info !== undefined, 'Order should have info');
    // Verify calldata is in info (CCXT does NOT broadcast tx)
    assert(mockOrder.info.calldata !== undefined, 'Order.info should contain calldata for user to broadcast');
    assert(mockOrder.info.router_address !== undefined, 'Order.info should contain router_address');
    // Status should be 'open' as it's not executed yet (user must broadcast)
    assert.strictEqual(mockOrder.status, 'open', 'Order status should be open (pending user tx broadcast)');
    console.log(`    ✓ Order response with calldata tests passed`);
}
// ============================================================================
// Test: Cross-chain Order Parameters
// ============================================================================
function testCrossChainOrderParameters(exchange) {
    const method = 'testCrossChainOrderParameters';
    console.log(`  Testing: ${method}`);
    // Same-chain order (default)
    const sameChainParams = {
        src_chain_id: 56,
        dst_chain_id: 56, // Same as source
    };
    assert.strictEqual(sameChainParams.src_chain_id, sameChainParams.dst_chain_id, 'Same-chain order should have matching chain IDs');
    // Cross-chain order
    const crossChainParams = {
        src_chain_id: 56,
        dst_chain_id: 8453, // Base
    };
    assert.notStrictEqual(crossChainParams.src_chain_id, crossChainParams.dst_chain_id, 'Cross-chain order should have different chain IDs');
    // Cross-chain slippage recommendation
    const crossChainSlippage = 1.0; // Higher for cross-chain
    const sameChainSlippage = 0.5; // Standard for same-chain
    assert(crossChainSlippage >= sameChainSlippage, 'Cross-chain slippage should be >= same-chain slippage');
    console.log(`    ✓ Cross-chain order parameter tests passed`);
}
// ============================================================================
// Test: Timeframe Mapping
// ============================================================================
function testTimeframeMapping(exchange) {
    const method = 'testTimeframeMapping';
    console.log(`  Testing: ${method}`);
    // Supported timeframes from plan
    const supportedTimeframes = [
        '1m', '3m', '5m', '15m', '30m',
        '1h', '2h', '4h', '8h', '12h',
        '1d', '3d', '1w', '1M'
    ];
    const timeframes = exchange.safeDict(exchange, 'timeframes', {});
    for (const tf of supportedTimeframes) {
        if (Object.keys(timeframes).length > 0) {
            assert(tf in timeframes, `Timeframe ${tf} should be supported`);
        }
    }
    console.log(`    ✓ Timeframe mapping tests passed`);
}
// ============================================================================
// Test: Authentication Header Format
// ============================================================================
function testAuthenticationHeaderFormat(exchange) {
    const method = 'testAuthenticationHeaderFormat';
    console.log(`  Testing: ${method}`);
    // All endpoints require JWT Bearer token
    const mockApiKey = 'test_jwt_token_12345';
    exchange.apiKey = mockApiKey;
    // Expected header format
    const expectedAuthHeader = `Bearer ${mockApiKey}`;
    // Verify the format
    assert(expectedAuthHeader.startsWith('Bearer '), 'Auth header should start with "Bearer "');
    assert(expectedAuthHeader.includes(mockApiKey), 'Auth header should contain the JWT token');
    console.log(`    ✓ Authentication header format tests passed`);
}
// ============================================================================
// Test: Required Credentials Configuration
// ============================================================================
function testRequiredCredentialsConfiguration(exchange) {
    const method = 'testRequiredCredentialsConfiguration';
    console.log(`  Testing: ${method}`);
    // According to plan: only apiKey required, others optional
    const expectedCredentials = {
        apiKey: true,
        secret: false,
        walletAddress: false,
        privateKey: false, // Optional - CCXT does NOT broadcast
    };
    // Verify apiKey is required
    assert(expectedCredentials.apiKey === true, 'apiKey (JWT) should be required');
    // Verify others are optional
    assert(expectedCredentials.walletAddress === false, 'walletAddress should be optional');
    assert(expectedCredentials.privateKey === false, 'privateKey should be optional (CCXT does not broadcast)');
    console.log(`    ✓ Required credentials configuration tests passed`);
}
// ============================================================================
// Main Test Runner
// ============================================================================
async function testDeluthium(exchange, skippedProperties = {}) {
    console.log('\n========================================');
    console.log('Deluthium DEX - Comprehensive Unit Tests');
    console.log('========================================\n');
    // Initialize exchange options for testing
    exchange.options = exchange.options || {};
    exchange.options['pairIdCache'] = {};
    exchange.options['defaultChainId'] = 56;
    exchange.options['defaultSlippage'] = 0.5;
    exchange.options['wrappedTokens'] = {
        56: '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
        8453: '0x4200000000000000000000000000000000000006',
        1: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
    };
    try {
        // Run all unit tests
        testSymbolFormatConversion(exchange);
        testPairIdCacheStructure(exchange);
        testDualErrorFormatDetection(exchange);
        testParameterStyleHandling(exchange);
        testChainIdValidation(exchange);
        testAddressChecksumValidation(exchange);
        testSlippageParameterHandling(exchange);
        testQuoteStructureValidation(exchange);
        testOrderResponseWithCalldata(exchange);
        testCrossChainOrderParameters(exchange);
        testTimeframeMapping(exchange);
        testAuthenticationHeaderFormat(exchange);
        testRequiredCredentialsConfiguration(exchange);
        console.log('\n========================================');
        console.log('All Deluthium unit tests PASSED ✓');
        console.log('========================================\n');
        return true;
    }
    catch (error) {
        console.error('\n========================================');
        console.error('Deluthium unit tests FAILED ✗');
        console.error('========================================');
        console.error('Error:', error.message);
        throw error;
    }
}
export default testDeluthium;
