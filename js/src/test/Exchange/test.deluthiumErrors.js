// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
// EDIT THE CORRESPONDENT .ts FILE INSTEAD

/**
 * Deluthium DEX - Error Handling Tests
 *
 * Tests the dual error format handling (string codes from Trading Service +
 * numeric codes from Market Data Service) as specified in the plan document.
 */
import assert from 'assert';
import { BadRequest, BadSymbol, InvalidOrder, OrderNotFound, InsufficientFunds, ExchangeNotAvailable, ExchangeError, AuthenticationError, RequestTimeout, } from "../../base/errors.js";
// ============================================================================
// String Error Code Tests (Trading Service)
// ============================================================================
const STRING_ERROR_MAPPINGS = [
    { code: 'INVALID_INPUT', exception: BadRequest, description: 'Invalid request parameters' },
    { code: 'INVALID_TOKEN', exception: BadSymbol, description: 'Token address is invalid' },
    { code: 'INVALID_AMOUNT', exception: InvalidOrder, description: 'Amount is too small or invalid' },
    { code: 'INVALID_PAIR', exception: BadSymbol, description: 'Trading pair not found' },
    { code: 'INVALID_DEADLINE', exception: InvalidOrder, description: 'Deadline has passed' },
    { code: 'QUOTE_EXPIRED', exception: OrderNotFound, description: 'Quote has expired' },
    { code: 'INSUFFICIENT_LIQUIDITY', exception: InsufficientFunds, description: 'Not enough liquidity' },
    { code: 'MM_NOT_AVAILABLE', exception: ExchangeNotAvailable, description: 'Market makers unavailable' },
    { code: 'NO_QUOTES', exception: ExchangeError, description: 'No quotes available' },
    { code: 'SLIPPAGE_EXCEEDED', exception: InvalidOrder, description: 'Slippage tolerance exceeded' },
    { code: 'INTERNAL_ERROR', exception: ExchangeError, description: 'Internal server error' },
    { code: 'SIGNING_ERROR', exception: AuthenticationError, description: 'Failed to sign transaction' },
    { code: 'TIMEOUT_ERROR', exception: RequestTimeout, description: 'Request timed out' },
];
// ============================================================================
// Numeric Error Code Tests (Market Data Service)
// ============================================================================
const NUMERIC_ERROR_MAPPINGS = [
    { code: 10095, exception: BadRequest, description: 'Invalid parameters' },
    { code: 20003, exception: ExchangeError, description: 'Internal service error' },
    { code: 20004, exception: BadSymbol, description: 'Not found (pair not found)' },
];
// ============================================================================
// Test Functions
// ============================================================================
function testStringErrorCodeDetection(exchange) {
    console.log('  Testing string error code detection...');
    for (const mapping of STRING_ERROR_MAPPINGS) {
        const response = {
            code: mapping.code,
            message: mapping.description,
        };
        const code = exchange.safeString(response, 'code');
        // Verify it's detected as a string code
        assert(typeof code === 'string', `Code ${mapping.code} should be detected as string`);
        assert(code !== '10000', `Code ${mapping.code} should not be success code`);
        console.log(`    ✓ ${mapping.code} → ${mapping.exception.name}`);
    }
}
function testNumericErrorCodeDetection(exchange) {
    console.log('  Testing numeric error code detection...');
    for (const mapping of NUMERIC_ERROR_MAPPINGS) {
        const response = {
            code: mapping.code,
            message: mapping.description,
        };
        const code = exchange.safeInteger(response, 'code');
        // Verify it's detected as a numeric code
        assert(typeof code === 'number', `Code ${mapping.code} should be detected as number`);
        assert(code !== 10000, `Code ${mapping.code} should not be success code`);
        console.log(`    ✓ ${mapping.code} → ${mapping.exception.name}`);
    }
}
function testSuccessCodeHandling(exchange) {
    console.log('  Testing success code handling...');
    // String success code
    const stringSuccessResponse = {
        code: '10000',
        message: 'success',
        data: {},
    };
    const stringCode = exchange.safeString(stringSuccessResponse, 'code');
    assert(stringCode === '10000', 'String success code should be "10000"');
    console.log('    ✓ String success code "10000" detected');
    // Numeric success code
    const numericSuccessResponse = {
        code: 10000,
        message: 'success',
        data: {},
    };
    const numericCode = exchange.safeInteger(numericSuccessResponse, 'code');
    assert(numericCode === 10000, 'Numeric success code should be 10000');
    console.log('    ✓ Numeric success code 10000 detected');
}
function testDualFormatDistinction(exchange) {
    console.log('  Testing dual format distinction...');
    // String error (Trading Service format)
    const tradingServiceError = {
        code: 'INSUFFICIENT_LIQUIDITY',
        message: 'Not enough liquidity to fill order',
    };
    const stringCode = exchange.safeString(tradingServiceError, 'code');
    const numericCode1 = exchange.safeInteger(tradingServiceError, 'code');
    assert(stringCode === 'INSUFFICIENT_LIQUIDITY', 'Should extract string code');
    assert(numericCode1 === undefined, 'Should not extract numeric code from string');
    console.log('    ✓ Trading Service format (string code) correctly identified');
    // Numeric error (Market Data Service format)
    const marketDataServiceError = {
        code: 20004,
        message: 'Pair not found',
    };
    const stringCode2 = exchange.safeString(marketDataServiceError, 'code');
    const numericCode2 = exchange.safeInteger(marketDataServiceError, 'code');
    assert(stringCode2 === '20004', 'String extraction of numeric returns string');
    assert(numericCode2 === 20004, 'Should extract numeric code');
    console.log('    ✓ Market Data Service format (numeric code) correctly identified');
}
function testErrorExceptionMapping(exchange) {
    console.log('  Testing exception mapping configuration...');
    // Verify exact (string) exceptions exist
    const exactExceptions = exchange.safeDict(exchange.exceptions, 'exact', {});
    for (const mapping of STRING_ERROR_MAPPINGS) {
        // Note: This test validates the mapping structure, actual exception
        // throwing is tested in the static response tests
        console.log(`    Checking ${mapping.code}...`);
    }
    console.log('    ✓ String error mappings structure verified');
    // Verify broad (numeric) exceptions exist
    const broadExceptions = exchange.safeDict(exchange.exceptions, 'broad', {});
    for (const mapping of NUMERIC_ERROR_MAPPINGS) {
        console.log(`    Checking ${mapping.code}...`);
    }
    console.log('    ✓ Numeric error mappings structure verified');
}
function testMixedResponseHandling(exchange) {
    console.log('  Testing mixed response handling...');
    // Response with both potential formats (should pick one)
    const ambiguousResponse1 = {
        code: 'INVALID_INPUT',
        message: 'Invalid',
    };
    const sc1 = exchange.safeString(ambiguousResponse1, 'code');
    assert(typeof sc1 === 'string', 'String code should be extracted');
    console.log('    ✓ String code extraction works');
    // Another case
    const ambiguousResponse2 = {
        code: 20004,
        message: 'Not found',
    };
    const nc2 = exchange.safeInteger(ambiguousResponse2, 'code');
    assert(typeof nc2 === 'number', 'Numeric code should be extracted');
    console.log('    ✓ Numeric code extraction works');
}
// ============================================================================
// Main Test Runner
// ============================================================================
async function testDeluthiumErrors(exchange, skippedProperties = {}) {
    console.log('\n========================================');
    console.log('Deluthium DEX - Error Handling Tests');
    console.log('========================================\n');
    try {
        testStringErrorCodeDetection(exchange);
        testNumericErrorCodeDetection(exchange);
        testSuccessCodeHandling(exchange);
        testDualFormatDistinction(exchange);
        testErrorExceptionMapping(exchange);
        testMixedResponseHandling(exchange);
        console.log('\n========================================');
        console.log('All error handling tests PASSED ✓');
        console.log('========================================\n');
        return true;
    }
    catch (error) {
        console.error('\n========================================');
        console.error('Error handling tests FAILED ✗');
        console.error('========================================');
        console.error('Error:', error.message);
        throw error;
    }
}
export default testDeluthiumErrors;
// Export individual tests for use in other test files
export { STRING_ERROR_MAPPINGS, NUMERIC_ERROR_MAPPINGS, testStringErrorCodeDetection, testNumericErrorCodeDetection, testSuccessCodeHandling, testDualFormatDistinction, };
